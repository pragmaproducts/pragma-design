import {BaseElement} from "./../../baremetal/lib/base-element.js";
import {getElementBounds} from "./../../lib/dom-helper.js";

export class PragmaTooltip extends BaseElement {

    constructor() {
        super();
    }
    
    get target() {
        return this._target;
    }
    
    set target(newValue) {
        if (newValue == null) {
          this.setAttribute("aria-hidden", "true");
        }
        else{
            const bounds = getElementBounds(newValue);
            this.text = newValue.getAttribute("tooltip");
            this.setAttribute("aria-hidden", "false");
            this.moveTo(bounds); 
        }
        
        this._target = newValue;
    }
    
    set text(newValue) {
        this.textElement.innerHTML = newValue;
    }
    
    async connectedCallback() {
        await super.connectedCallback();
        this.touchDuration = 800;
        this._initTemplate();
        this._registerEvents();
        this.setAttribute("aria-hidden", "true");
    }

    disconnectedCallback() {
        this.container = null;
        super.disconnectedCallback();
    }


    _initTemplate() {
        const template = document.importNode(window.templates.get("pragma-tooltip-template"), true);
        this.textElement = template.querySelector(".tooltip-text");
        this.appendChild(template);
    }
    
    moveTo(bounds) {
        this.style.transform = `translate( ${bounds.left + ((bounds.width/2) - 50)}px, ${bounds.top - 100}px)`;
    }
    
    
    _touchStart(e) {
        if(this.lockTimer === true) return;
        const target =  this._getTargetFromPoint(e.touches[0].clientX, e.touches[0].clientY);
        if(target != null) {
            this.timer = setTimeout(this._longPressed.bind(this, target), this.touchDuration);
            this.lockTimer = true;
        }
    }
    
    _touchEnd() {
        //stops short touches from firing the event
        if (this.timer){
            clearTimeout(this.timer);
            this.lockTimer = false;
        }
    }

    _touchMove(e) {
        if (e.target.hasAttribute("tooltip") === false) {
            this.target = null;     
        } 
    }

    _mouseOver(e) {
        this.target =  this._getTargetFromPoint(e.pageX, e.pageY);
    }

    _getTargetFromPoint(x, y) {
        const elements =  document.elementsFromPoint(x, y);
        if ((elements || []).length === 0) return; 
        if(elements[0].hasAttribute("tooltip")) {
            return elements[0];
        }
    }

    _longPressed(target) {
        this.target = target;
    };
    
    _registerEvents() {
        this.registerEvent(window, "touchstart", this._touchStart.bind(this));
        this.registerEvent(window, "touchend", this._touchEnd.bind(this));
        this.registerEvent(window, "touchmove", this._touchMove.bind(this));
        this.registerEvent(window, "mouseover", this._mouseOver.bind(this));
    }
}

customElements.define('pragma-tooltip', PragmaTooltip);