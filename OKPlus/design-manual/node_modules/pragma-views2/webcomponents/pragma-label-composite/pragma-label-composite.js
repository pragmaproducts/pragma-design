import {findParentOfType} from "./../../lib/dom-helper.js";
import {BaseNavigation} from "./../../webcomponents/lib/base-navigation.js";
import {BaseElement} from "./../../baremetal/lib/base-element.js";

class PragmaLabelComposite extends BaseElement {
    connectedCallback() {
        this.initTemplate();
        this.navigation = new BaseNavigation(this);
        this.focusInHandler = this.focusIn.bind(this);
        this.focusOutHandler = this.focusOut.bind(this);
        this.checkValidityHandler = this.checkValidity.bind(this);
        this.keyUpHandler = this.keyUp.bind(this);

        this.addEventListener("focusin", this.focusInHandler);
        this.addEventListener("focusout", this.focusOutHandler);
        this.addEventListener("keyup", this.keyUpHandler);
        this.input.addEventListener("keyup", this.checkValidityHandler);

    }
  
    disconnectedCallback() {
        this.btnLookup = null;
        this.btnPeek = null;
        
        if (this.btnLookupClickHandler != null) {
            this.querySelector("#btnLookup").removeEventListener("click", this.btnLookupClickHandler);
            this.btnLookupClickHandler = null;
        }

        if (this.btnScanClickHandler != null) {
            this.querySelector("#btnScan").removeEventListener("click", this.btnScanClickHandler);
            this.btnScanClickHandler = null;
        }

        if (this.btnPeekClickHandler != null) {
            this.querySelector("#btnPeek").removeEventListener("click", this.btnPeekClickHandler);
        }

        this.removeEventListener("focusin", this.focusInHandler);
        this.removeEventListener("focusout", this.focusOutHandler);
        this.removeEventListener("keyup", this.keyUpHandler);
        this.input.removeEventListener("keyup", this.checkValidityHandler);

        this.navigation.dispose();
        this.navigation = null;
        this.focusInHandler = null;
        this.focusOutHandler = null;
        this.keyUpHandler = null;
        this.checkValidityHandler = null;
        this.form = null;
        this.ignoreFullValidityCheck = null;
        this.lookupCompleted = null;
    }

    get descriptor() {
        return this.getProperty("descriptor", ()=> this.getAttribute("descriptor"));
    }

    set descriptor(newValue) {
        this.setProperty("descriptor", newValue, ()=> {
            this.descriptor == null ? this._removeDescriptorElement() : this._addDescriptorElement();
        });
    }

    get label() {
        return this.getAttribute("label") || this._label;
    }

    set label(value) {
        this._label = value;
    }

    get labelFor() {
        return this.getAttribute("label-for") || this._labelFor;
    }

    set labelFor(value) {
        this._labelFor = value;
    }

    get lookup() {
        return this.getAttribute("lookup") || this._lookup;
    }

    set lookup(value) {
        this._lookup = value;
    }

    get lookupBusy() {
        return this._lookupBusy;
    }

    set lookupBusy(value) {
        this._lookupBusy = value;
        if(value == true) {
            this.input.setAttribute("disabled", true);
            this.btnLookup.classList.add("spinner");
            this.btnPeek.classList.add("spinner");
        }
        else{
            this.input.removeAttribute("disabled");
            this.btnLookup.classList.remove("spinner");
            this.btnPeek.classList.remove("spinner");
        }
    }

    get model() {
        return this._model;
    }

    set model(value) {
        this._model = value;
    }

    get peek() {
        return this.getAttribute("peek") || this._peek;
    }

    set peek(value) {
        this._peek = value;
    }

    get scannable() {
        return this.getAttribute("scannable") || this._scannable;
    }

    set scannable(value) {
        this._scannable = value;
    }

    _addDescriptorElement() {
        if(this.descriptorElement == null) {
            this.descriptorElement = document.createElement("div");
            this.descriptorElement.classList.add("descriptor");
            this.appendChild(this.descriptorElement);
        }
        this.descriptorElement.innerHTML = this._descriptor;
    }

    _removeDescriptorElement() {
        if(this.descriptorElement != null) {
            this.descriptorElement.parentNode.removeChild(this.descriptorElement);
        }
    }

    _getPragmaForm(){
        if (this.form == null){
            this.form = findParentOfType(this, "pragma-form");
        } 
        return this.form;
    }

    btnLookupClick() {
      this.doLookup();
    }

    btnPeekClick() {
        if (this.input.value.trim().length === 0) return;
        
        if (this.model != null && this.model.doPeek != null) {
            this.model.doPeek(this.lookup);
        }
        else {
            this._getPragmaForm().model.doPeek(this.peek);
        }
    }

    btnScanClick() {
        alert("do scan");
    }

    checkValidity() {
        this.lookupCompleted = false;
        
        if (this.input == null) return;

        const isValid = this.input.validity == null ? true : this.input.validity.valid;

        if (isValid != this.isValid) {
            this.setValidity(isValid);
        }
        
        if (this.input.value === "" && this.lookup != null) {
            this.clearLookupMappings();
        }
    }

    _getLookupMapping(model) {
        let mapping;
        const schema = model["__schema"];
        const lookupDefinition = model["__definition"].fields.find(item => item.name === this.lookup);
        
        if (lookupDefinition != null) {
            const lookupId = lookupDefinition.lookup;
            const lookups = schema.lookups;

            if (lookups != null) {
                const field = lookups.find(e => e.id === lookupId);

                if (field != null) {
                    mapping = field.mapping;
                }
            }
        }
        
        return mapping;
    }
    
    clearLookupMappings() {
        const model = this._getPragmaForm().model;
        const mapping = this._getLookupMapping(model);
        
        if (mapping != null) {
            const mappingFields = Object.keys(mapping);
            
            for (let key of mappingFields) {
                model[key] = null;
            }
        }
    }
    
    doLookup(filter) {
        if (this.lookupBusy === true) return;
        if (filter != null) {
            this.lookupBusy = true;    
        } 
        
        const callbackFn = (success) => {
            if (success === false) {
                this.clearLookupMappings();
            }
            this.lookupBusy = false;
        };
        
        if (this.model != null && this.model.doLookup != null) {
            this.model.doLookup(this.lookup, filter, callbackFn);
        }
        else {
            this._getPragmaForm().model.doLookup(this.lookup, filter, callbackFn);
        }
    }

    focusIn() {
        this.oldValue = this.input.value;
        this.dataset.status = this.isValid === false ? "invalid" : "focused";
    }

    focusOut(event) {
        this.dataset.status = this.isValid === false ? "invalid" : "normal";
        
        if (event.target.nodeName === "INPUT" && this.input.value !== "" && this.lookup != null && this.oldValue !== this.input.value &&  this.anyLookupMappingFieldsDirty() === true) {
            this.doLookup(this.input.value);
        }
        this.oldValue = null;
    }
    
    anyLookupMappingFieldsDirty() {
        let isDirty;
        const model = this._getPragmaForm().model;
        const mapping = this._getLookupMapping(model);
        
        if (mapping != null) {
            const mappingFields = Object.keys(mapping);
            const dirtyFields = Object.keys(model.getDirtyModel() || {});

            isDirty = dirtyFields.some(field => mappingFields.includes(field));
        }
        
        return isDirty;
    }
    
    initButtons(parent) {
        this.btnLookup = parent.querySelector("#btnLookup");
        const btnScan = parent.querySelector("#btnScan");
        this.btnPeek = parent.querySelector("#btnPeek");

        this.btnLookup.setAttribute("aria-label", `Lookup ${this.label}`);
        btnScan.setAttribute("aria-label", `Scan ${this.label}`);
        this.btnPeek.setAttribute("aria-label", `View ${this.label}`);

        if (this.lookup == null) {
            parent.removeChild(this.btnLookup);
        }
        else {
            this.btnLookupClickHandler = this.btnLookupClick.bind(this);
            this.btnLookup.addEventListener("click", this.btnLookupClickHandler);
        }

        if (this.scannable == null) {
            parent.removeChild(btnScan);
        }
        else {
            this.btnScanClickHandler = this.btnScanClick.bind(this);
            btnScan.addEventListener("click", this.btnScanClickHandler);
        }

        if (this.peek == null) {
            parent.removeChild(this.btnPeek);
        }
        else {
            this.btnPeekClickHandler = this.btnPeekClick.bind(this);
            this.btnPeek.addEventListener("click", this.btnPeekClickHandler);
        }
    }

    initDescriptor(instance) {
        this._descriptorElement = instance.querySelector(".descriptor");
    }

    initInputGroup(instance, group, input) {
        if (this.lookup == null && this.peek == null && this.scannable == null) {
            instance.replaceChild(input, group);
            return false;
        }

        group.insertBefore(input, group.children[0]);
        return true;
    }

    initTemplate() {
        const instance = document.importNode(window.templates.get("label-composite"), true);
        this.input = this.children[0];

        const inputGroup = instance.querySelector(".input-group");
        const label = instance.querySelector("label");

        this.removeChild(this.input);
        label.innerText = this.label;
       
        if (this.labelFor != null){
            label.htmlFor = this.labelFor;
        } 

        this.initDescriptor(instance);
        if (this.initInputGroup(instance, inputGroup, this.input)) {
            this.initButtons(inputGroup);
        }

        this.appendChild(instance);
    }

    keyUp(event) {
        if (event.target.nodeName !== "INPUT") return;
        
        if (event.key === this.navigation.keyCodes.enter) {
            if (this.input.value.trim().length !== 0 && this.lookup != null) {
                this.doLookup(this.input.value);
            }
        }
    }
    
    setValidity(isValid) {
        this.isValid = isValid;
        this.setAttribute("data-status", isValid === true ? "focused" : "invalid");
    }

    shallowValidate() {
        this.ignoreFullValidityCheck = true;
        this.checkValidity();
        this.ignoreFullValidityCheck = false;
    }
}

customElements.define("pragma-label-composite", PragmaLabelComposite);