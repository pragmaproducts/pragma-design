import {BaseElement} from "./../../baremetal/lib/base-element.js";

export class Svg extends BaseElement {

    /**
     * Get the name attribute value of the svg
     * @returns {*|string}
     */
    get name() {
        return this._name || this.getAttribute("name");
    }

    /**
     * Set the name attribute value of the svg
     * @returns {*|string}
     */
    set name(newValue) {
        this._name = newValue;
    }

    /**
     * Get the url attribute value of the svg
     * @returns {*|string}
     */
    get url() {
        return this._url || this.getAttribute("url");
    }

    /**
     * Set the url attribute value of the svg
     * @returns {*|string}
     */
    set url(newValue) {
        this._url = newValue;
    }

    /**
     * Get the position attribute value of the svg
     * @returns {*|string}
     */
    get position() {
        return this._position || this.getAttribute("position") || "0,0";
    }

    /**
     * Set the position attribute value of the svg
     * @returns {*|string}
     */
    set position(newValue) {
        this._position = newValue;
    }

    /**
     * Get the width/dimension attribute value of the svg. Initial value is set to fullsize
     * @returns {*|string}
     */
    get dimensions() {
        if(this._dimensions == null) {
            const value = this.getAttribute("dimensions") || "fullsize";
            this._dimensions = value === "fullsize" ? ["100%", "100%"] : value.split(",");
        }

        return this._dimensions;
    }

    /**
     * Set the width/dimension attribute value of the svg
     * @returns {*|string}
     */
    set dimensions(newValue) {
        this._dimensions = newValue;
        this.setDimensions();
    }

    get svg() {
        return this._svg;
    }

    /**
     * If there are values in readycallback then loop through and
     * @param newValue
     */
    set svg(newValue) {
        this._svg = newValue;
        if (this.readyCallbacks.length > 0) {
            for (const callback of this.readyCallbacks){
                callback();
            }
        }
    }

    constructor() {
        super();
        this.readyCallbacks = [];
    }

    async connectedCallback() {
        super.connectedCallback();
        await this._buildSVG();

        this.setAttribute("style", `transform:translate(${this.position})`);
        this.setDimensions();
    }

    disconnectedCallback() {
        super.disconnectedCallback();
        this.svg = null;
    }

    /**
     * Check if attribute name has a value and then run buildSVGFromName else run buildSVGFromUrl
     * @returns {Promise<void>}
     * @private
     */
    async _buildSVG() {
        if (this.name != null && this.name.trim().length > 0) {
            this._buildSVGFromName();
        }
        else {
            await this._buildSVGFromUrl();
        }
    }

    /**
     * Build the svg from the name attribute value.
     * @private
     */
    _buildSVGFromName() {
        this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this.appendChild(this.svg);

        const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
        use.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", `#${this.name}`);
        this.svg.appendChild(use);
    }

    /**
     * Once page is loaded, find and build the svg from url value in attribute
     * @returns {Promise<void>}
     * @private
     */
    async _buildSVGFromUrl() {
        const response = await fetch(this.url);
        const svgUrlText = await response.text();

        const div = document.createElement('div');
        div.innerHTML = svgUrlText;

        this.appendChild(div.firstChild);
        this.svg = this.querySelector('svg');
    }

    /**
     * Set the style width and height properties for this element from dimension
     */
    setDimensions() {
        this.style.width = this.dimensions[0];
        this.style.height = this.dimensions[1];
    }

    /**
     *
     * @param callback
     */
    registerReadyCallback(callback) {
        if (this.readyCallbacks.indexOf(callback) === -1) {
            this.readyCallbacks.push(callback);
        }
    }

    unregisterReadyCallback(callback) {
        const index = this.readyCallbacks.indexOf(callback);
        if (index !== -1) {
            this.readyCallbacks.splice(index, 1);
        }
    }
}

customElements.define('pr-svg', Svg);