import {padStart} from "../../lib/string-helpers.js";
import {BaseElement} from "../../baremetal/lib/base-element.js";
import {dateToIsoStringDate} from "../../lib/date-helpers.js";
import {ActionDialogManager} from "../../lib/action-dialog-manager.js";
import {PragmaDateTime} from "../pragma-date-time/pragma-date-time.js";

export class PragmaInputDate extends BaseElement {

    connectedCallback() {
        super.connectedCallback();

        // HACK GM/JB: When using this control on run time action dialogs this connectedCallback gets fired twice.
        //  - GM suggested that we check if the control is already added like below. To be fixed.            
        if (this.querySelector("#dateInput") != null)
            return;

        // NOTE JB: This control relies on regex validation
        //  - I first went with doing the validation myself but found this expression that also caters for leap years

        // Init default values
        //  Regular expression for date explanation
        //  - Format : dd/mm/yyyy
        //  - https://www.regextester.com/99021
        //
        //  When is a year a leap year
        //  - https://www.timeanddate.com/date/leapyear.html
        const displayPattern = "^([0-2][0-9]|[3][0-1])\\/([0][1-9]|[1][0-2])\\/\\d{4}$";
        const isoPattern = "^\\d{4}-([0][1-9]|[1][0-2])-([0-2][0-9]|[3][0-1])$";
        this._dateDisplayFormatRegex = new RegExp(displayPattern);
        this._dateIsoFormatRegex = new RegExp(isoPattern);
        this._date = null;
        this._dateChanging = false;

        this._initTemplate();

        // Create components
        this._dateInput = this.querySelector("#dateInput");
        this._dateInput.pattern = displayPattern;

        //Attributes
        this.readonly = this.readonly;
        this.required = this.required;

        // Event listeners
        this._dateInput.onkeyup = this._onKeyUpCompleted.bind(this);
        if (this._iconButton != null) {
            this.registerEvent(this._iconButton, "click", this._iconClick.bind(this));
        }
    }

    disconnectedCallback() {
        super.disconnectedCallback();

        this._dateInput.onkeyup = null;
        this._dateInput = null;
        this._date = null;
        this._dateIsoFormatRegex = null;
        this._dateDisplayFormatRegex = null;
        this.dateChangedCallback = null;
        this._calendar = null;
        this._iconButton = null;
    }

    get readonly() {
        if (this._readonly == null) {
            this.readonly = this.hasAttribute("readonly");
        }
        return this._readonly;
    }

    set readonly(value) {
        value = value === true;
        this._readonly = value;
        if (this._iconButton != null) this._iconButton.disabled = value;
        if (value) {
            this.setAttribute("readonly", "true");
            this._dateInput.setAttribute("readonly", "true");
        } else {
            this.removeAttribute("readonly");
            this._dateInput.removeAttribute("readonly");
        }
    }

    get required() {
        if (this._required == null) {
            this._required = this.hasAttribute("required");
        }
        return this._required;
    }

    set required(value) {
        if (value === true) {
            this._required = true;
            this.setAttribute("required", "true");
            this._dateInput.setAttribute("required", "true");
        } else {
            this._required = false;
            this.removeAttribute("required");
            this._dateInput.removeAttribute("required");
        }
    }

    get date() {
        return this._date || (this.hasAttribute("date") ? this.getAttribute("date") : null);
    }

    set date(isoDate) {
        if (this._dateChanging === false) {
            this._dateChanging = true;

            // The date property will be formatted in iso date string but the display date is formatted differently
            const oldDateValue = this._date;
            const date = this._tryParseDate(isoDate);
            if (date != null) {
                this._date = isoDate;
                if (this._dateInput != null) {
                    this._dateInput.value = `${padStart(date.day, 2)}/${padStart(date.month)}/${padStart(date.year, 4)}`;
                }
            } else {
                this._date = null;
            }

            // Notify if something changed
            if (this._date !== oldDateValue) {
                this.notifyPropertyChanged("date", this._date, true);
                if ((this.dateChangedCallback != null)) {
                    this.dateChangedCallback(this._date);
                }
            }

            this._dateChanging = false;
        }
    }

    _initTemplate() {
        const instance = this.parentElement instanceof PragmaDateTime ?
            document.importNode(window.templates.get("input-date"), true) :
            document.importNode(window.templates.get("input-date-icon"), true);

        this.appendChild(instance);
    }

    /**
     * DateTime control icon clicked.
     * @private
     */
    _iconClick() {
        if (this._iconButton.disabled === true) return;

        const fragment = document.createDocumentFragment();
        this._calendar = document.createElement("pr-calendar");
        const selectDate = document.createElement("selected-date");
        const initialDate = dateToIsoStringDate(new Date(this.date || new Date()));
        selectDate.setAttribute("date", initialDate);
        this._calendar.appendChild(selectDate);
        fragment.appendChild(this._calendar);

        const buttons = [
            {
                id: "select",
                title: window.translations.dateTime.select,
                remote: false,
                callback: async (dialog) => {
                    if (selectDate != null && selectDate.date instanceof Date) {
                        this.date = dateToIsoStringDate(selectDate.date);
                    }
                    dialog.dispose();
                }
            }
        ];

        const options = {
            contentElement: fragment,
            animatedCallback: this._dialogAnimated.bind(this),
            buttons: buttons,
            title: window.translations.dateTime.heading
        };

        new ActionDialogManager(options);
    }

    /**
     * Callback event that occurs after the modal dialog showing the calendar has loaded and
     * is finished rendering.
     * @private
     */
    _dialogAnimated() {
        if (this._calendar != null) {
            this._calendar.focusStart();
        }
    }

    _onKeyUpCompleted(eventArgs) {
        if (eventArgs.key != null) {
            const date = this._tryParseDisplayDate(this._dateInput.value);
            this.date = (date != null) ? this._formatDateToIsoString(date) : null;
        }
    }

    _tryParseDate(isoDate) {
        let dateStructure = null;
        if ((isoDate != null) && (isoDate !== "") && (this._dateIsoFormatRegex.test(isoDate) === true)) {
            const parts = isoDate.split("-");
            dateStructure = {
                year: parseInt(parts[0], 10),
                month: parseInt(parts[1], 10),
                day: parseInt(parts[2], 10)
            };
        }

        return this._validateDate(dateStructure) ? dateStructure : null;
    }

    _tryParseDisplayDate(displayDate) {
        let dateStructure = null;
        if ((displayDate != null) && (displayDate !== "") && (this._dateDisplayFormatRegex.test(displayDate) === true)) {
            const parts = displayDate.split("/");
            dateStructure = {
                year: parseInt(parts[2], 10),
                month: parseInt(parts[1], 10),
                day: parseInt(parts[0], 10)
            };
        }

        return this._validateDate(dateStructure) ? dateStructure : null;
    }

    /**
     * Check if the parsed date structure is valid.
     * @param {Object} dateStructure
     * @returns {boolean}
     */
    _validateDate(dateStructure) {
        let valid = false;

        // Check the ranges of month and year
        if ((dateStructure != null) && ((dateStructure.month > 0) || (dateStructure.month <= 12))) {
            const monthLength = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

            // Adjust for leap years
            //  -   In the Gregorian calendar three criteria must be taken into account to identify leap years:
            //      + The year can be evenly divided by 4;
            //      + If the year can be evenly divided by 100, it is NOT a leap year, unless; The year is also evenly
            //        divisible by 400. Then it is a leap year.
            if ((dateStructure.year % 400 === 0) || ((dateStructure.year % 100 !== 0) && (dateStructure.year % 4 === 0))) {
                monthLength[1] = 29;
            }

            // Check the range of the day
            //  - Instantiate date must be in iso format
            if ((dateStructure.day > 0) && (dateStructure.day <= monthLength[dateStructure.month - 1])) {
                valid = true;
            }
        }

        return valid;
    }

    _formatDateToIsoString(date) {
        return `${padStart(date.year, 4)}-${padStart(date.month)}-${padStart(date.day)}`;
    }
}

customElements.define('pragma-input-date', PragmaInputDate);