import {loadScript} from "./../../component-loader.js";

class VisualFilter extends HTMLElement {
    get data() {
        return this._data;
    }

    set data(newValue) {
        this._data = newValue;

        if (this._data[0]["filter-index"] == undefined) {
            let index = 0;
            for(let item of this._data) {
                item["filter-index"] = index;
                index += 1;
            }
        }

        this.initialize();
    }

    get xField() {
        return this.getAttribute("x-field") || this._xField;
    }

    set xField(newValue) {
        this._xField = newValue;
    }

    get yField() {
        return this.getAttribute("y-field") || this._yField;
    }

    set yField(newValue) {
        this._yField = newValue;
    }

    get axisUI() {
        if(this._axisUI == undefined) {
            this._axisUI = this.svg.append("g").attr("id", "chart-body")
        }

        return this._axisUI;
    }

    async initialize() {
        if (this.offsetWidth == 0 || d3 == undefined) {
            return requestAnimationFrame(_ => this.initialize())
        }

        const scriptPath = './third-party/d3.min.js';
        this.script = await loadScript(scriptPath, true, () => {
            this.setupChart();
            this.setupBrush();
            if (this.script != null) this.script.onload = null;
        });
    }

    disconnectedCallback() {
        delete this.svg;
        delete this._axisUI;
        delete this.brush;
        this.data = null;
        this.script = null;
    }

    setupChart() {
        if (this.xField == undefined || this.yField == undefined) {
            return console.error("xField and yField must be defined for the visual filter");
        }

        if (this.offsetWidth == 0) {
            return requestAnimationFrame(_ => this.setupChart())
        }

        this.svg = d3.select(this).append("svg").attr("width", this.offsetWidth).attr("height", this.offsetHeight);

        const xDomainArray = this.data.map(d => d[this.xField]);
        const yDomainArray = d3.extent(this.data, d => d[this.yField]);

        this.xScale = d3.scaleBand().domain(xDomainArray).range([0, this.offsetWidth]);
        this.yScale = d3.scaleLinear().domain(yDomainArray).range([this.offsetHeight, 0]);

        const area = d3.area()
            .x(d => this.xScale(d[this.xField]))
            .y0(this.offsetHeight)
            .y1(d => this.yScale(d[this.yField]));

        const dataJoin = this.svg.selectAll(".area")
            .data([this.data]);

        const enter = dataJoin
            .enter()
            .append('path')
            .attr("class", "area");

        dataJoin
            .merge(enter)
            .transition()
            .duration(500)
            .ease(d3.easeCubicOut)
            .attr("d", area)
    }

    setupBrush() {
        this.brush = d3.brushX()
            .extent([[0, 0], [this.offsetWidth, this.offsetHeight]])
            .on("brush end", this.brushed.bind(this));

        this.svg.append("g")
            .attr("class", "brush")
            .call(this.brush)
            .call(this.brush.move, this.xScale.range());
    }

    brushed() {
        if (d3.event.type != "end") {
            const pixelRange = d3.event.selection;
            const result = this.data.filter(d => {
               const x = this.xScale(d[this.xField]);
               return x >= pixelRange[0] && x <= pixelRange[1];
            });

            const event = new CustomEvent("filtered", {detail: result});
            this.dispatchEvent(event);
        }
    }
}

customElements.define("visual-filter", VisualFilter);
