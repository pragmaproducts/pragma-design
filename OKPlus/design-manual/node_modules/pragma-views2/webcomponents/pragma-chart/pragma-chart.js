import {addEventsFeatures, removeEventsFeatures} from "./../../baremetal/lib/mixin-events.js";
import {loadScript} from "./../component-loader.js";
import {ComponentUiStates} from "../../lib/component-ui-states.js";
import {DataSourceStateConstants} from "../../lib/datasource-constants.js";
import {registerDataCollectionState, unregisterDataCollectionState} from "./../lib/mixin-datacollection-state.js";
import {DataSourceVisualizationBase} from "./../lib/data-source-visualization-base.js";

class PragmaChart extends DataSourceVisualizationBase {
    get datasource() {
        return super.datasource;
    }
    
    set datasource(newValue) {
        if (newValue == null && this._datasource != null && this._datasource.uiStateManager != null) {
            this._datasource.uiStateManager.unregisterComponent(this);
        }

        super.datasource = newValue;

        if (newValue != null) {
            this.datasource.uiStateManager.registerComponent(this);
            this.datasourceChanged()
        }
    }

    get perspective() {
        return this.getAttribute("perspective") || this._perspective;
    }

    set perspective(newValue) {
        this._perspective = newValue;

        if(newValue != null) {
            this.getData({ perspective: newValue });
        }
    }

    get padding() {
        return this.getAttribute("padding") || this._padding;
    }

    set padding(newValue) {
        this._padding = newValue;
    }

    get paddingValues() {
        const p = this.padding.split(",");
        return {
            "top": Number(p[0]),
            "right": Number(p[1]),
            "bottom": Number(p[2]),
            "left": Number(p[3]),
            "width": this.offsetWidth - Number(p[1]) - Number(p[3]),
            "height": this.offsetHeight - Number(p[0]) - Number(p[2])
        }
    }

    get xAxis() {
        return this._xAxis;
    }

    set xAxis(newValue) {
        this._xAxis = newValue;
        if (this._xAxis != undefined && this._data != undefined) {
            this._xAxis.update(this._data);
        }
    }

    get yAxis() {
        return this._yAxis;
    }

    set yAxis(newValue) {
        this._yAxis = newValue;
        if (this.yAxis != undefined && this._data != undefined) {
            this.yAxis.update(this._data);
        }
    }

    constructor() {
        super();
        this.datasourceChangedHandler = this.datasourceChanged.bind(this);
    }
    
    async connectedCallback() {
        addEventsFeatures(this);
        registerDataCollectionState(this);
        this.uiState = ComponentUiStates.suspended;
        this.padding = "0, 0, 0, 0";
        this._charts = [];
        this._perspective = null;
        
        const scriptPath = './third-party/d3.min.js';
        this._script = await loadScript(scriptPath, true, () => {
            this.setupChart();
            this.registerEvent(window, "resize", this.resize.bind(this));
            if (this._script != null) this._script.onload = null;
        });
    }
    
    disconnectedCallback() {
        removeEventsFeatures(this);
        unregisterDataCollectionState(this);

        if(this.datasource.uiStateManager != null)
        {
            this.datasource.uiStateManager.unregisterComponent(this);
        }
        this.datasourceChangedHandler = null;
        this.xAxis = null;
        this.yAxis = null;
        this.charts = null;
        this.datasource = null;
        this._script = null;
    }

    datasourceChanged(ds) {
        if (this._datasource == undefined || this.state === ComponentUiStates.suspended) return;
        
        this.getData({ perspective: this.perspective });
    }

    async getData(perspective) {
        const data = await this._datasource.data(perspective);

        if(data != null) {
            this._data = data;
            this.update(data);
        }
    }

    update(data) {
        if (this.svg == undefined) return;

        const group = document.querySelector(".chart-body");

        if (group != undefined) {
            group.innerHTML = "";
        }

        if (this.xAxis != undefined) {
            this.xAxis.update(this._data);
        }

        if (this.yAxis != undefined) {
            this.yAxis.update(this._data);
        }

        for (let chart of this._charts) {
            chart.update(this._data);
        }
    }

    addChart(chart) {
        this._charts.push(chart);

        if (this._data != undefined) {
            chart.update(this._data);
        }
    }

    removeChart(chart) {
        const index = this._charts.indexOf(chart);
        this._charts.splice(index, 1);
    }

    setupChart() {
        if (this.offsetWidth == 0 || d3 == undefined) {
            return requestAnimationFrame(_ => this.setupChart())
        }

        this.svg = d3.select(this).append("svg").attr("width", this.offsetWidth).attr("height", this.offsetHeight);

        const padding = this.paddingValues;
        this.svg.append("g")
            .attr("class", "chart-body")
            .append("rect")
            .attr("id", "background")
            .attr("transform", `translate(${padding.left}, ${padding.top})`)
            .attr("width", this.offsetWidth - padding.left - padding.right)
            .attr("height", this.offsetHeight - padding.top - padding.bottom);

        if (this._data != undefined) {
            this.update(this._data);
        }
    }

    resize() {
        if (this.svg != undefined) {
            this.svg
                .attr("width", this.offsetWidth)
                .attr("height", this.offsetHeight);

            if (this._data != undefined) {
                this.update(this._data);
            }
        }
    }

    get uiState() {
        return this._uiState;
    }

    set uiState(newValue) {
        this._uiState = newValue;
        if(newValue === ComponentUiStates.active && this.datasource != null) {
            this.datasource.uiStateManager.componentStateChanged();
            this.stateChanged({state:this.datasource.state});
        }
    }

    async stateChanged({state}) {
        if(this.uiState === ComponentUiStates.suspended) return;
        if (state === DataSourceStateConstants.none) {
            this.getData({ perspective: this.perspective });
        }
    }
}

customElements.define("pragma-chart", PragmaChart);
