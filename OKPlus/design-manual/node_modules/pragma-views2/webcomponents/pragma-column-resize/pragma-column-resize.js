import {BaseElement} from "../../baremetal/lib/base-element.js";
import {createElement} from "../../lib/dom-helper.js";
import {enableAnimationLayer, disableAnimationLayer} from "../../lib/animation-layer.js";

export class PragmaColumnResize extends BaseElement {
    connectedCallback() {
        super.connectedCallback();
        this.registerEvent(this.parentElement, "ready", this.setup.bind(this));
    }

    disconnectedCallback() {
        this.breakdown();
        super.disconnectedCallback();
    }
    
    setup() {
        const columnElements = Array.from(this.parentElement.querySelectorAll('[role="columnheader"]'));
        if (this.parentElement.allowMultipleSelect == true) {
            columnElements.splice(0, 1);
        }
        
        this.columns = columnElements;

        for (let column of this.columns) {
            const element = createElement("div", ["col-resize"]);
            column.appendChild(element);
        }

        this.header = this.columns[0].parentElement;
        
        if (this.hasEvent(this.header, "mousedown") == false) {
            this.registerEvent(this.header, "mousedown", this.handleMouseDown.bind(this));
        }
    }

    breakdown() {
        this.header = null;
        const elementsToRemove = [];

        if (this.columns != null) {
            for (let column of this.columns) {
                const element = column.querySelector(".col-resize");
                if (element != null) {
                    elementsToRemove.push(element);
                }
            }

            for (let element of elementsToRemove) {
                element.parentElement.removeChild(element);
            }
        }

        this.columns = null;
    }

    handleMouseDown(event) {
        if (event.target.classList.contains("col-resize") == false) return;

        const initialPoint = {x: event.clientX, y: event.clientY};
        const rect = event.target.getBoundingClientRect();
        this.parent = event.target.parentElement;
        this.suppressRightColumns(parent);

        this.animateClone(event.target, {rect: rect, minX: rect.x - parent.offsetWidth + 10, initialPoint: initialPoint});
    }

    suppressRightColumns(element) {
        this.suppressedColumns = [];
        const index = this.columns.indexOf(element);
        if (index == -1) return;

        if (index < this.columns.length -1) {
            for (let i = index; i < this.columns.length; i++) {
                const column = this.columns[i];
                column.style.opacity = "0.2";
                this.suppressedColumns.push(column);
            }
        }
    }

    undoSuppression() {
        for (let column of this.suppressedColumns) {
            column.style.opacity = "";
        }

        this.suppressedColumns = null;
    }

    /**
     * Given a element, create a clone and move it around on the animation layer until mouse up happens
     * @param element: what element do you want to clone and move around?
     * @param point: what is the initial mouse event position kicking off this process
     */
    animateClone(element, options) {
        const animationLayer = enableAnimationLayer();
        const rect = options.rect;
        const clone = element.cloneNode(true);

        const opacity = element.style.opacity;
        element.style.opacity = options.opacity || "0";

        clone.classList.add("clone");
        clone.style.setProperty('--x', rect.x);
        clone.style.setProperty('--y', rect.y);
        clone.style.setProperty('--width', rect.width);
        clone.style.setProperty('--height', rect.height);

        animationLayer.appendChild(clone);
        
        this.initialPoint = options.initialPoint;

        const offsetX = options.initialPoint.x - options.rect.left;
        const offsetY = options.initialPoint.y - options.rect.top;
        const minX = (options.minX || 0);
        const minY = (options.minY || 0);

        animationLayer.onmousemove = (event) => {
            clone.style.setProperty('--x', event.clientX - offsetX);
        };

        animationLayer.onmouseup = (event) => {
            disableAnimationLayer();

            const minX = (options.minX || 0);
            const minY = (options.minY || 0);
            const result = {
                x: event.clientX > minX ? event.clientX : minX,
                y: event.clientY > minY ? event.clientY : minY
            };

            this.performResize(result);
            element.style.opacity = opacity;
        };
    }
    
    performResize(point) {
        const offset = point.x - this.initialPoint.x;
        if (offset == 0) return;
        
        const index = this.columns.indexOf(this.parent);
        const fieldName = this.parentElement.columns[index].field;

        const width = this.parent.offsetWidth + offset;
        this.parent.style.width = `${width}px`;
        this.undoSuppression();
        
        this.parent = null;
        this.initialPoint = null;
        
        const schema = this.parentElement.datasource.schema || {};
        
        if (schema.sideEffects != null) {
            schema.sideEffects.perform({
                target: "grid",
                id: this.parentElement.id,
                intentions: [
                    {
                        action: "setColumnWidth",
                        parameters: [fieldName, width]
                    }
                ]
            });
        }
        else {
            this.parentElement.setColumnWidth(fieldName, width)
        }
    }
}

customElements.define('pragma-column-resize', PragmaColumnResize);