import {TemplateParser} from "./../../lib/template-parser.js";
import {findParentWithClass} from "./../../lib/dom-helper.js";
import {ActionDialogManager} from "./../../lib/action-dialog-manager.js";
import {DatasetFactory} from "./../../lib/dataset-factory.js";
import {SchemaHelper} from "./../../lib/schema-helper.js";
import {createBehavioursFromString, releaseElements} from "./../../baremetal/lib/binding/binding-helpers.js";
import {
    addExpressionTriggers,
    performTriggersFor,
    addTriggers,
    observe,
    removeObserverFromCache
} from "./../../baremetal/lib/binding/observers.js";
import {ViewBinding} from "./../../baremetal/lib/binding/view-binding.js"
import {
    executeFunctionOnPath,
    setValueOnPath,
    deleteValueOnPath,
    getValueOnPath, prefixVariables
} from "./../../baremetal/lib/objectpath-helper.js";
import {isMobile} from "./../lib/device-helper.js";
import {AddValidation, ReverseValidation} from "./../../baremetal/lib/behaviours/validation-behaviour.js";
import {cloneObject} from "./../../baremetal/lib/class-helper.js";
import {BaseElement} from "./../../baremetal/lib/base-element.js";
import {createExecutionProxy} from "./../../baremetal/lib/actions/code-compiler.js";
import {buttonTypes, dialogTypes} from "./../../webcomponents/pragma-dialogs/pragma-dialogs-constants.js";
import {SchemaSideEffectManager} from "../../lib/schema-side-effects/schema-sideeffect-manager.js";
import {UIGraph} from "../../lib/ui-graph.js";
import {ComponentUiStates} from "../../lib/component-ui-states.js";
import {datasetToDraft} from "./../../lib/dataset-utils.js";
import {DataSet} from "./../../lib/dataset.js";
import {createDatasourceFromDefinition} from "../../lib/datasource-utils.js";


export class PragmaForm extends BaseElement {
    get isMobile() {
        if (this._isMobile == null) {
            this._isMobile = isMobile();
        }
        return this._isMobile;
    }

    get context() {
        return this._context;
    }

    set context(newValue) {
        this._context = newValue;
    }

    get model() {
        return this._model;
    }

    set model(newValue) {
        this._model = newValue;

        if ((newValue || {}).datasetFactory == null) {
            this.notifyPropertyChanged("model", newValue, true);
        }
        if (this.model != null && this.model.uiStateManager) {
            this.model.uiStateManager.registerComponent(this);
        }
    }

    get remote() {
        return this._remote || this.getAttribute("remote");
    }

    set remote(newValue) {
        this._remote = newValue;
        this.remoteChanged(newValue);
    }

    get schema() {
        return this._schema;
    };

    set schema(newValue) {
        if (newValue != null && newValue._isVisible === true) return;
        this._schema = newValue;
        this.schemaHasChanged();
    }

    get disposeModel() {
        return this.getProperty("disposeModel", () => this.dataset.disposeModel !== "false");
    }
    
    get templateId() {
        return this._templateId;
    }

    set templateId(newValue) {
        this._templateId = newValue;
    }

    get templates() {
        return this._templates;
    }

    set templates(newValue) {
        this._templates = newValue;
    }

    get type() {
        return this._type || this.getAttribute("type");
    }

    set type(newValue) {
        this._type = newValue;
    }

    get uiGraph() {
        return this._uiGraph;
    }

    set uiGraph(newValue) {
        this._uiGraph = newValue;
    }

    get uiState() {
        return this._uiState || ComponentUiStates.suspended;
    }

    set uiState(newValue) {
        this._uiState = newValue;
        if (this.model != null && newValue === ComponentUiStates.active) {
            this.model.uiStateManager.componentStateChanged();
        }
    }

    async schemaHasChanged() {
        let datasetDraft;
        if (this.model != null && this.model instanceof DataSet && this.disposeModel === true) {
            if(this._schema != null) {
                datasetDraft = datasetToDraft(this.model);
            }

            removeObserverFromCache(this.model);
            if (this.model.dispose != null) {
                this.model.dispose();
            }
        }

        await this.clear();
        if (this._schema != null && this._schema.sideEffects != null) {
            this._schema.sideEffects.dispose();
            this._schema.sideEffects = null;
        }


        if (this._schema != null) {
            await this.refreshFromSchema();
            this._schema.sideEffects = new SchemaSideEffectManager(this._schema, this);
            const event = new CustomEvent("loaded", {detail: { draft: datasetDraft }});
            this.dispatchEvent(event);
        }

    }

    async clear() {
        await this.releaseElements();
        await removeObserverFromCache(this.schema);

        if (this.detailsElement != undefined) {
            this.detailsElement.innerHTML = "";
        }
    }

    connectedCallback() {
        super.connectedCallback();
        this.initTemplate();
        this.binding = new ViewBinding(this);
        this.templates = new Map();
        this.templateParser = new TemplateParser();
        this.detailsElement = this.querySelector(".form-container");

        if (this.schema != undefined) {
            this.refreshFromSchema();
        }

        if (this.remote != undefined) {
            this.remoteChanged(this.remote);
        }

        this.registerEvent(this, "focusin", this.focus.bind(this));
        this.registerEvent(this, "focusout", this.focusOut.bind(this));

        this._validateElementHandler = this.validateElement.bind(this);
        window.eventEmitter.on("validate-element", this._validateElementHandler);

        this.schemaHelper = new SchemaHelper(this.schema);


        this._screenChangedHandler = this._screenChanged.bind(this);
        window.eventEmitter.on("screen-changed", this._screenChangedHandler);

    }

    async _screenChanged() {
        if (this.schema != null && this.schema.uiRules != null && this.schema.uiRules.length > 0) {
            this.schemaHasChanged();
        }
    }

    disconnectedCallback() {
        window.eventEmitter.remove("window-resized", this._screenChangedHandler);
        window.eventEmitter.remove("validate-element", this._validateElementHandler);
        this._screenChangedHandler = null;
        this._validateElementHandler = null;
        this.uiGraph.dispose();
        this.uiGraph = null;

        this.disposeFileInput();
        this.disposeProcessManager();
        this.disposeVariables(this.schema);

        super.disconnectedCallback();
    }

    disposeFileInput() {
        if (this.fileInput) {
            this.fileInput.removeEventListener("change", this.changeHandler);
            this.fileInput = null;
            this.changeHandler = null;
        }
    }

    disposeProcessManager() {
        if (this.processManager == undefined) {
            return;
        }

        this.processManager.dispose();
        this.processManager = null;
    }

    disposeVariables(schema) {
        if (schema == null) return;

        if (schema.variables != null){
            const disposeFn = (variableName)=> {
                if(schema.variables[variableName] != null) {
                    const keys = Object.keys(schema.variables[variableName]);
                    for (let key of keys) {
                        if (Number.isInteger(schema.variables[variableName][key]) === false) {
                            schema.variables[variableName][key].dispose();
                            schema.variables[variableName][key] = null;
                        }
                    }
                }
            };

            disposeFn("models");
            disposeFn("datasources");
        }

        schema.variables = null;
    }

    fetchSchema(remote, type) {
        if (this.remote != undefined && this.type != undefined) {
            window.eventEmitter.emit("fetch-schema",
                {
                    remote: remote,
                    type: this.type || "view",
                    callback: (schema) => this.schema = schema
                });
        }
    }

    focus(event) {
        const card = findParentWithClass(event.target, "card");

        if (card != null) {
            card.setAttribute("aria-selected", true);
            event.target.card = card;
        }
    }

    focusFirstInput() {
        const input = this.querySelector("input");

        if (input)
            input.focus();
    }

    focusOut(event) {
        if (event.target.card != undefined) {
            event.target.card.setAttribute("aria-selected", false);
            event.target.card = null;
        }
    }

    /**
     * Models are created externally and does not have context information, but we still want to give them context awareness without over exposing them.
     * To allow you to define property defaults on the model, we inflate the values as soon as it becomes part of the form because the form understands context.
     * @param model
     */
    inflateModelDefaults(model) {
        if (model == undefined || model.__definition == undefined) {
            return;
        }

        for (let field of model.__definition.fields) {
            if (field.default != undefined) {
                const defaultValue = this.schemaHelper.getAssociatedValue(this.model, field.default);
                field.initialValue = defaultValue;
                model.__defaults.set(field.name, defaultValue);
                model[field.name] = defaultValue;
            }
        }
    }

    initTemplate() {
        const instance = document.importNode(window.templates.get("pragma-form"), true);
        this.appendChild(instance);
    }

    loadContentFromFile(event) {
        const file = event.target.files[0];

        const fr = new FileReader();

        fr.onload = _ => {
            this.schema = JSON.parse(fr.result);
            this.disposeFileInput();
        };

        fr.readAsText(file);
    }

    async loadDatasetVariable(name) {
        const dsValue = this.schema.variables.models[name];

        if (Number.isInteger(dsValue)) {
            const factory = new DatasetFactory({schema: this.schema});

            const ds = factory.createDataSet(dsValue);
            ds.setInitialValues({});
            this.schema.variables.models[name] = ds;
            factory.dispose();
        } else {
            dsValue.resetToDefault();
        }
    }

    async createDataSourceVariable(name) {
        const dsValue = this.schema.variables.datasources[name];

        if (Number.isInteger(dsValue)) {
            const definition = this.schema.datasources.find(_=> _.id === dsValue);

            if(definition == null) return;

            const ds = createDatasourceFromDefinition(this.schema, definition, this.context.getRemoteData);
            this.schema.variables.datasources[name] = ds;
            if (definition["delay-fetch"] !== true) {
                ds.load();
            }
        }
    }

    loadHtml(html) {
        const container = this.querySelector(".form-container");
        container.innerHTML = html;

        this.binding.parse(this, this.children);

        window.eventEmitter.emit("form-updated", this);
    }
    
    reloadFromSchema() {
        this.unbindStuff();
        const html = this.templateParser.parse(this.schema);
        this.loadHtml(html)
    }

    loadTemplates() {
        this.templates.clear();

        if (this.schema.templates != undefined) {
            this.templateParser.initializeResources(this.schema);

            for (let template of this.schema.templates) {
                const html = this.templateParser.parseElements(template.elements);
                this.templates.set(template.id, html);
            }
        }
    }

    modelChanged(newValue) {
        if (this.schemaHelper != undefined) {
            this.schemaHelper.model = newValue;
        }
    }

    nextProcessStep() {
        this.processManager.next();
    }

    validateAction(action) {
        if (action.conditional == null) return true;

        let result = true;
        for (let condition of action.conditional) {
            let expression = condition.expression;
            if (expression.indexOf("@") != -1) {
                expression = this.updateVariablePath(expression);
            }

            const fn = createExecutionProxy(expression, new Map(), false);

            result = fn(this) == true;

            if (result == false) {
                if (condition.message != null) {
                    const msg = this.schemaHelper.getAssociatedValue(this.model, condition.message);
                    window.eventEmitter.emit("show-message", {type: dialogTypes.error, message: msg});
                }

                break;
            }
        }

        return result;
    }

    async confirmAction(action) {
        if (action.confirmation == null) return true;

        let result = true;

        for (let confirmation of action.confirmation) {
            let expression = confirmation.expression;

            if (expression != undefined) {
                if (expression.indexOf("@") != -1) {
                    expression = this.updateVariablePath(expression);
                }

                const fn = createExecutionProxy(expression, new Map(), false);
                result = fn(this) == true;

                if (result == true) {
                    result = await this.confirm(confirmation.message);
                    return result;
                }
            } else {
                result = await this.confirm(confirmation.message);
                return result;
            }
        }

        return result;
    }

    async confirm(msg) {
        return new Promise((resolve) => {
            window.eventEmitter.emit("show-message", {
                type: dialogTypes.warning,
                message: this.schemaHelper.getAssociatedValue(this.model, msg),
                buttons: buttonTypes.yes_no,
                callback: (result) => {
                    resolve(result);
                }
            });
        })
    }

    /**
     * NOTES:
     * Is there a current process running?
     * If there is and the action is UI related then show it in the process UI.
     * If not, and it is UI related then you need to show a dialog with the UI.
     * @param id
     * @param closeDialog
     * @param args
     * @returns {Promise<boolean>}
     */
    async performAction(id, closeDialog, args) {
        if (Array.isArray(id)) {
            for (let i of id) {
                await this.performAction(i, closeDialog, args);
            }
            return;
        }

        if (id != null) {
            const schemaAction = this.schema.actions.find(item => item.id === id);
            const action = cloneObject(schemaAction);

            if (this.validateAction(action) === false) return;

            if (await this.confirmAction(action) === false) return;

            const activityId = action.parameters == null ? -1 : action.parameters["activity-id"];

            if (activityId != null) {
                window.eventEmitter.emit(`activity_${activityId}`, "busy");
            }

            let result;

            let shouldRefreshModel = (action.parameters || {})["refresh-model"] != null && action.parameters["refresh-model"] === true;

            if (action.remote != null) {
                result = await this.performRemoteAction(action, shouldRefreshModel);
                if (result === false) {
                    return false;
                }
            } else if (this[action.action] != null) {
                if (action.parameters != null) {
                    action.parameters = this.schemaHelper.inflateParameters(this.model, action.parameters);
                }

                result = await this[action.action].call(this, action.parameters, args);
            } else if (action.action.indexOf(".") !== -1) {
                if (action.parameters != null) {
                    action.parameters = this.schemaHelper.inflateParameters(this.model, action.parameters);
                }
                result = await executeFunctionOnPath(this, action.action, action.parameters, args);
            }

            if (action.variable != null) {
                if (result != null && typeof result == "object") {
                    for (let key of Object.keys(result)) {
                        setValueOnPath(this, `schema.variables.${action.variable}.${key}`, result[key]);
                    }
                } else {
                    setValueOnPath(this, `schema.variables.${action.variable}`, result);
                }
            }


            // Note GM: If activity id set and refresh-model true, refresh the model on callback of action button
            const fn = shouldRefreshModel === true && action.template == null ? this.refreshModel.bind(this) : null;

            if (activityId != null) {
                window.eventEmitter.emit(`activity_${activityId}`, {
                    state: "done",
                    callback: fn
                });
            } else if (fn != null) {
                fn();
            }
        }
    }

    refreshModel() {
        if (this.model != null) {
            this.model.load();
        }
    }

    async performContextAction(action) {
        const a = Object.create(action);

        if (a.parameters != undefined) {
            a.parameters = this.schemaHelper.inflateParameters(this.model, a.parameters);
        }

        if (a.parameters != undefined && a.parameters.model != undefined) {
            if (a.parameters.model.raw != undefined) {
                // model is a dataset
                a.parameters.model = a.parameters.model.raw();
            } else {
                // model is a object literal
                a.parameters.model = JSON.parse(JSON.stringify(a.parameters.model));
            }
        }
        return await this.context.performAction(a);
    }

    async performProcess(id) {
        const process = this.schema.processes.find(item => item.id == id);
        this.showProcess(process.actions);
    }

    async performRemoteAction(action, refreshModel) {
        if (action.model != undefined) {
            const ds = this.schema.variables.models[action.model];
            this.inflateModelDefaults(ds);
        }

        if (this.context.performAction != undefined) {
            if (action.template == undefined) {
                return await this.performContextAction(action)
            } else {
                const dialogTitle = action.title != null ? this.templateParser.getVariableValue(action.title) : "";
                const html = this.templateParser.parseTemplate({template: action.template});

                let div = document.createElement("div");
                div.innerHTML = html;
                this.binding.parse(div);

                let buttons;

                let showAccept = action["show-accept"];
                if (showAccept == null || showAccept === true) {
                    buttons = [
                        {
                            id: "accept",
                            title: window.translations.pragmaDialogs.buttons.accept,
                            callback: async (dialog) => {
                                const result = await this.performContextAction(action);

                                // TODO GM/JN: Decide on how to handle errors when remote action fails
                                // TODO GM: Add pragma-action-button to pragma-action-dialog
                                // TODO GM: Decide if we want to close the dialog on accept on make the consumer use a process to close dialog
                                if (result != null && refreshModel === true) {
                                    this.refreshModel();
                                    dialog.dispose();
                                    resolve(result);
                                }
                            }
                        }
                    ];
                }

                return new Promise(resolve => {
                    if (this.dialog != null) {
                        return;
                    }

                    const options = {
                        contentElement: div,
                        buttons: buttons,
                        title: dialogTitle
                    };

                    new ActionDialogManager(options);
                });
            }
        }
    }

    perspective(id) {
        if (this.schema.perspectives == undefined) {
            return undefined;
        }

        return this.schema.perspectives.find(item => item.id == id);
    }

    async postMessage(parameters, args) {
        parameters.args = args;
        window.eventEmitter.postMessage(parameters.query, parameters);
    }

    emit(parameters) {
        window.eventEmitter.emit(parameters.key, parameters.message);
    }


    async releaseElements() {
        const elements = this.querySelectorAll("[behaviours]");
        return releaseElements(elements);
    }

    remoteChanged(newValue) {
        this.fetchSchema(newValue, this.type);
    }

    removeVariable(action) {
        const varName = this.schemaHelper.getAssociatedValue(this.model, action.parameters.name);
        deleteValueOnPath(this.schema, `schema.variables.${varName}`);
    }

    async refreshFromSchema() {
        if (this.schema == null) return;


        this.schema._isVisible = true;

        if (this.schemaHelper != null) {
            this.schemaHelper.schema = this.schema;
        }

        if (this.templateParser) {
            this.loadTemplates();

            await this.refreshUI();
        }
    }

    async refreshUI() {
        if (this.uiGraph != null) {
            this.uiGraph.dispose();
        }
        this.uiGraph = new UIGraph(this.detailsElement);
        const html = this.templateId == null ? await this.templateParser.parse(this.schema) : this.templateParser.parseTemplate({template: this.templateId});
        this.loadHtml(html);

        this.focusFirstInput();

        this.uiGraph.build();
        this.setupBehaviours();
        this.setupVariableModels();
        this.setupVariableDatasources();
        this.setupCustomActionEvents();
        this.setupCustomActionTriggers();
        this.setupContextMenus();
    }

    print(parameters) {
        const keys = Object.keys(parameters);
        console.group("Pragma-form print");
        for (let key of keys) {
            const value = this.schemaHelper.getAssociatedValue(this, parameters[key]);
            console.log(key, value);
        }
        console.groupEnd();
    }

    setValue(parameters) {
        const keys = Object.keys(parameters);
        for (let key of keys) {
            const varName = this.updateVariablePath(key);
            const varValue = this.schemaHelper.getAssociatedValue(this.model, parameters[key]);

            setValueOnPath(this, varName, varValue);
        }
    }

    setVariable(action) {
        const varName = this.schemaHelper.getAssociatedValue(this.model, action.name);
        const varValue = this.schemaHelper.getAssociatedValue(this.model, action.value);

        setValueOnPath(this.schema, `variables.${varName}`, varValue);
    }

    setValidation(parameters, tag, reversed) {
        const keys = Object.keys(parameters);
        for (let key of keys) {
            if (reversed != true) {
                AddValidation(this, key, parameters[key], tag);
            }
            else {
                ReverseValidation(this, key, parameters[key], tag);
            }
        }
    }

    setupBehaviours() {
        const elements = this.querySelectorAll("[behaviours]");
        const collection = Array.from(elements);

        for (let element of collection) {
            createBehavioursFromString(element.getAttribute("behaviours"), element);
        }
        ;
    }

    updateVariablePath(path) {
        if (path.indexOf("@") == -1) {
            return path;
        }

        return path.split("@").join("schema.variables.");
    }

    setupContextMenus() {
        if (this.schema.contextMenus == null || Array.isArray(this.schema.contextMenus) === false) return;
        const ids = Object.keys(this.schema.contextMenuElements);

        // We concat ids to only query DOM once
        const selector = ids.map(id=> `#${id}`).join(",");
        const elements = Array.from(this.querySelectorAll(selector));

        for (let id of ids) {
            const schemaElement = this.schema.contextMenuElements[id];
            const element = elements.find(_=> _.id === id);

            if(schemaElement.contextMenu != null) {
                const options = {
                    element: element,
                    eventHandler: (event)=> {
                        this.showContextMenu({contextMenu: schemaElement.contextMenu}, event)
                    }
                };
                window.eventEmitter.emit("register-context-menu", options);
            }
        }
    }

    showContextMenu(parameters, event) {
        const contextMenu = this.schema.contextMenus.find(_ => _.id === parameters.contextMenu);
        if(contextMenu == null) return false;

        // We check if the target matches any of our exclusion list to prevent context menu from opening
        if(contextMenu.exclude != null && event.target.matches(contextMenu.exclude.join(","))) return;

        const options = {
            title: this.schemaHelper.getAssociatedValue(this.model, contextMenu.title),
            callback: (menuItem) => {
                if(menuItem.action != null) {
                    this.performAction(menuItem.action, null, menuItem);
                }
            },
            datasource: this._getContextMenuDatasource(contextMenu),
            event: event
        };
        window.eventEmitter.emit("show-context-menu", options);
        return true;
    }

    _getContextMenuDatasource(contextMenu) {
        if(contextMenu.datasource != null) {
            return this.schemaHelper.getAssociatedValue(this.model, contextMenu.datasource);
        }

        if (contextMenu.items != null && contextMenu.items.length > 0) {
            for (const item of contextMenu.items) {
                let result = true;
                if (item.condition != null) {
                    let path = item.condition;
                    if (path[0] === "@"){
                        path = prefixVariables("schema.variables.","@", path);
                    }
                    const fn = window.compiler.add(path, false);
                    // TODO use map to clear set(item.condition);
                    result = fn(this);
                    window.compiler.remove(item.condition);
                }

                if(result === true)
                {
                    return this.schemaHelper.getAssociatedValue(this.model, item.datasource);
                }
            }
        }
    }

    setupCustomActionTriggers() {
        if (this.schema.customActionTriggers == undefined) return;
        if (Array.isArray(this.schema.customActionTriggers) == false) return;

        for (let customTrigger of this.schema.customActionTriggers) {
            this.setupCustomActionTrigger(customTrigger);
        }
    }

    setupCustomActionTrigger(customTrigger) {
        let expression = customTrigger.trigger;
        if (expression.indexOf("@") != -1) {
            expression = this.updateVariablePath(expression);
        }

        addTriggers(this, expression, () => this.performTriggeredActions(customTrigger));
    }

    setupVariableModels() {
        if (this.schema.variables == null || this.schema.variables.models == null) return;

        const models = this.schema.variables.models;
        if (models != undefined) {
            const keys = Object.keys(models);
            for (let key of keys) {
                if (key === "__globalId") continue;
                this.loadDatasetVariable(key);
            }
        }
    }

    setupVariableDatasources() {
        if (this.schema.variables == null || this.schema.variables.datasources == null) return;

        const datasources = this.schema.variables.datasources;
        if (datasources != null) {
            const keys = Object.keys(datasources);
            for (let key of keys) {
                this.createDataSourceVariable(key);
            }
        }
    }

    setupCustomActionEvents() {
        if (this.schema.customActionEvents == undefined) return;
        if (Array.isArray(this.schema.customActionEvents) == false) return;

        for (let customEvent of this.schema.customActionEvents) {
            this.setupCustomActionEvent(customEvent);
        }
    }

    setupCustomActionEvent(customEvent) {
        let expression = customEvent.event;
        if (expression.indexOf("@") != -1) {
            expression = this.updateVariablePath(expression);
        }

        const fnPassed = () => this.performTriggeredActions(customEvent);
        const fnFailed = () => this.performTriggeredActions(customEvent, true)

        addExpressionTriggers(this, expression, fnPassed, fnFailed);
    }

    performTriggeredActions(customAction, reversed) {
        for (let action of customAction.actions) {
            if (action.condition != undefined) {
                const cnd = window.compiler.add(action.condition);
                const result = cnd(this);
                if (result != true) {
                    continue;
                }
            }

            const parameters = this.schemaHelper.inflateParameters(this.model, action.parameters);

            if (action.action.indexOf(".") != -1) {
                return executeFunctionOnPath(this, action.action, parameters);
            }

            if (action.action == "setValue") {
                if (reversed != true) {
                    this.setValue(parameters);
                }
            } else if (action.action == "setValidation") {
                this.setValidation(parameters, customAction.event, reversed);
            } else if (action.action == "setVariable") {
                this.setVariable(parameters);
            } else if (this[action.action] != null) {
                this[action.action].call(this, parameters);
            }
        }
    }

    async showDialog(action) {
        this.dialog = new ActionDialogManager(action, this, () => {
            this.dialog.dispose();
            this.dialog = null;
        });
    }

    async closeDialog() {
        if (this.dialog != null) {
            this.dialog.dispose();
            this.dialog = null;
        }
    }

    async showProcess(actions) {
        for (let actionId of actions) {
            const result = await this.performAction(actionId);
            if (result === false) return;
        }
    }

    showSchemaTemplate(templateId) {
        if (this.templates.has(templateId)) {
            const html = this.templates.get(templateId);
            this.clear();
            this.loadHtml(html);
        }
    }

    template(id) {
        if (this.schema.templates == undefined) {
            return undefined;
        }

        return this.schema.templates.find(item => item.id == id);
    }

    typeChanged(newValue) {
        this.fetchSchema(this.remote, newValue);
    }

    validateElement(element) {
        // performViewElementValidation(this.viewSource.view, element);
    }

    /**
     * Inflate parameters with model as context
     * @param parameters
     * @returns {*}
     */
    inflateParameters(parameters) {
        return this.schemaHelper.inflateParameters(this.model, parameters);
    }
}

customElements.define('pragma-form', PragmaForm);