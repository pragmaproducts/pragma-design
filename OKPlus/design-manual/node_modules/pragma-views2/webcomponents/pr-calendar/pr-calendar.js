import {BaseElement} from "./../../baremetal/lib/base-element.js";
import {domHelper} from "./../../lib/dom-helper.js";
import {inflationUtils} from "../../baremetal/lib/virtualization/inflation-utils.js";
import {GridRenderer} from "./grid-renderer.js";
import {DataStore} from "./data-store.js"
import {Renderers} from "./renderers.js";
import {ListRenderer} from "./list-renderer.js";
import {dateHelpers} from "../../lib/date-helpers.js";
import {Focus} from "./focus.js";
import {Current} from "./current-date.js";

export class Calendar extends BaseElement {

    connectedCallback() {
        super.connectedCallback();

        this._rendererType = Renderers[this.getAttribute("renderer")];
        this._maxYearSelect = +(this.getAttribute("max-year-select") || 30);
        this._minYearSelect = +(this.getAttribute("min-year-select") || 30);
        this._fragment = document.createDocumentFragment();
        this._dataStore = new DataStore(this);
        this._focus = this.focus;

        if (this._rendererType === Renderers.list) {
            this._renderer = new ListRenderer(this);
        } else {
            this._renderer = new GridRenderer(this);
        }

        this._calendarContainer = this._initTemplate();
        const initialDate = new Date();
        this._buildSelectors(initialDate, this._calendarContainer, this._minYearSelect, this._maxYearSelect);
        this._detailsContainer = this._addDetailsContainer();
        this.viewDate = initialDate;
        this._yearSelect = this.querySelector(".year-select");
        this._monthSelect = this.querySelector(".month-select");
        this._previousMonthButton = this._calendarContainer.querySelector(".button-previous-month");
        this._nextMonthButton = this._calendarContainer.querySelector(".button-next-month");
        this.current.currentDate = initialDate;
        this._ariaTags();

        //Attach events
        this.registerEvent(this, "click", this._click.bind(this));
        this.registerEvent(this._yearSelect, "change", this._yearChange.bind(this));
        this.registerEvent(this._monthSelect, "change", this._monthChange.bind(this));
    }

    disconnectedCallback() {
        super.disconnectedCallback();

        for (const key of Object.keys(this)) {
            this[key] = null;
        }
    }

    get dataStore() {
        return this._dataStore;
    }

    /**
     * Used for unit testing.
     * @param newValue
     */
    set dataStore(newValue) {
        this._dataStore = newValue;
    }

    /**
     * Returns the day inflator function.
     * @returns {{inflateFn, defaultFn}}
     */
    get dayInflator() {
        return this._dayInflator;
    }

    /**
     * Returns the day template of the for #day
     * @returns {HTMLCollection}
     */
    get dayTemplate() {
        return this._dayTemplate;
    }

    get detailsContainer()  {
        return this._detailsContainer;
    }

    get fragment() {
        return this._fragment;
    }

    /**
     * Returns the head inflator function **Specific to grid view ATM**.
     * @returns {{inflateFn, defaultFn}}
     */
    get headInflator() {
        return this._headInflator;
    }

    /**
     * Returns the grid view head template.
     * @returns {HTMLCollection}
     */
    get headTemplate() {
        return this._headTemplate;
    }

    /**
     * Returns the grid view nav template containing selct boxes.
     * @returns {null|T|*}
     */
    get pragmaCalendarGridNavigationTemplate() {
        return this._pragmaCalendarGridNavigationTemplate;
    }

    get focus() {
        if (this._focus == null) {
            this._focus = new Focus(this);
        }
        return this._focus;
    }

    set focus(value) {
        this._focus = value;
    }

    get current() {
        if (this._current == null) {
            this._current = new Current(this);
        }
        return this._current;
    }

    set current(value) {
        this._current = value;
    }

    get renderer() {
        return this._renderer;
    }

    get viewDate() {
        return this._viewDate;
    }

    set viewDate(newValue) {
        if (newValue === null)
            return;

        const previousViewDate = this.viewDate;
        this._viewDate = newValue;
        this._dataStore.viewDate = newValue;

        if (previousViewDate == null || !dateHelpers.sameMonth(previousViewDate, newValue)) {
            this._updateSelectElements();
            this.current.render();
            this.focus.render();

            if (previousViewDate != null) {
                this.dispatchEvent(new CustomEvent("monthChanged", {
                    detail: {
                        newViewDate: new Date(+newValue),
                        oldDate: new Date(+previousViewDate)
                    }
                }));
            }
        }
    }

    /**
     * Adds the details container.
     * @returns {HTMLDivElement}
     * @private
     */
    _addDetailsContainer() {
        const details = document.createElement("div");
        details.classList.add("details");
        this._calendarContainer.appendChild(details);
        return details;
    }

    _ariaTags() {
        this._previousMonthButton.setAttribute("aria-label", window.translations.calendar.backButton);
        this._nextMonthButton.setAttribute("aria-label", window.translations.calendar.forwardButton);
        this._monthSelect.setAttribute("aria-label", window.translations.calendar.monthSelect);
        this._yearSelect.setAttribute("aria-label", window.translations.calendar.yearSelect);
    }

    /**
     * Builds the Month and Year select boxes.
     * @param {Date} renderDate The date to create the boxes for.
     * @param {DocumentFragment} container The fragment to append content to.
     * @param {Number} minYearSelect The number of years to show on the low side.
     * @param {Number} maxYearSelect The number of years to show on the high side.
     * @private
     */
    _buildSelectors(renderDate, container, minYearSelect, maxYearSelect) {
        const monthSelect = this.pragmaCalendarGridNavigationTemplate.querySelector(".month-select");
        const yearSelect = this.pragmaCalendarGridNavigationTemplate.querySelector(".year-select");
        const dateMonth = renderDate.getMonth();

        for (const month of this._dataStore.monthNames) {

            const option = document.createElement("option");
            option.innerText = month;
            option.value = this._dataStore.monthNames.indexOf(month);

            if (this._dataStore.monthNames.indexOf(month) === dateMonth) {
                option.selected = true;
                option.setAttribute("selected", "" + true);
            }
            monthSelect.appendChild(option);
        }

        const dateYear = renderDate.getFullYear();

        for (let year = dateYear - minYearSelect; year <= dateYear + maxYearSelect; year++) {
            const option = document.createElement("option");
            option.text = "" + year;
            option.value = "" + year;
            if (year === dateYear) {
                option.selected = true;
                option.setAttribute("selected", "" + true);
            }
            yearSelect.appendChild(option);
        }

        container.appendChild(this.pragmaCalendarGridNavigationTemplate.cloneNode(true));
    }

    /**
     * Click event handler for the day elements.
     * @param {Event} event
     */
    _click(event) {
        const clickedElement = event.target;

        if (clickedElement != null) {

            if (domHelper.findParentWithClass(clickedElement, "button-previous-month")) {
                this._moveToPreviousMonth();
                return;
            }

            if (domHelper.findParentWithClass(clickedElement, "button-next-month")) {
                this._moveToNextMonth();
            }
        }
    }

    /**
     * Imports the control template
     * @param {string} templateId
     * @returns {Node} Imported Element copy
     * @private
     */
    _importTemplate(templateId) {
        const template = window.templates.get(templateId);
        // noinspection JSValidateTypes
        return document.importNode(template, true);
    }

    /**
     * Sets up all calendar templates.
     * @returns {Element} Returns the calendar container.
     * @private
     */
    _initTemplate() {
        let calendarContainer = null;

        if (this._renderer instanceof GridRenderer) {
            const instance = this._importTemplate("grid-template");
            calendarContainer = instance.querySelector(".calendar-container-grid");
            this.appendChild(instance);
        } else {
            const instance = this._importTemplate("list-template");
            calendarContainer = instance.querySelector(".calendar-container-list");
            this.appendChild(instance);
        }

        this._pragmaCalendarGridNavigationTemplate = this._importTemplate("grid-navigation");

        const dayFragment = domHelper.createDocumentFragment();
        const dayContainerDiv = domHelper.createElement("div");
        dayContainerDiv.classList.add("#containerClass");
        dayContainerDiv.setAttribute("data-value", "#dataValue");
        dayContainerDiv.setAttribute("data-index", "#index");
        dayContainerDiv.setAttribute("tabindex", "0");
        dayContainerDiv.setAttribute("aria-label", "#aria");
        const dayContentContainer = domHelper.createElement("div");
        dayContentContainer.classList.add("day-content-container");
        dayContentContainer.setAttribute("role", "presentation");

        let dayTemplateNode = this.querySelector("[for=day]");
        dayTemplateNode = dayTemplateNode == null ? null : dayTemplateNode.content;
        dayTemplateNode = dayTemplateNode || this._importTemplate("day");
        dayContentContainer.appendChild(dayTemplateNode);
        dayContainerDiv.appendChild(dayContentContainer);
        dayFragment.appendChild(dayContainerDiv);

        this._dayInflator = inflationUtils.createInflatorFunction(dayFragment.firstElementChild);
        this._dayTemplate = dayFragment.firstElementChild;

        let headTemplateNode = this.querySelector("[for=header]");
        headTemplateNode = headTemplateNode == null ? null : headTemplateNode.content;
        headTemplateNode = headTemplateNode || this._importTemplate("header");
        this._headTemplate = headTemplateNode.children;
        this._headInflator = inflationUtils.createInflatorFunction(headTemplateNode.firstElementChild);

        return calendarContainer;
    }

    /**
     * Event Handler for when the month select box is changed.
     * @param {Event} event
     * @private
     */
    _monthChange(event) {
        const element = domHelper.findParentWithClass(event.target, "month-select");

        // noinspection SuspiciousTypeOfGuard
        if (event != null && element != null) {

            if (element.selectedOptions == null || element.selectedOptions.length === 0)
                return;
            const selectedValue = element.selectedOptions[0].value;

            if (selectedValue == null)
                return;

            const clonedDate = new Date(+this.viewDate);
            clonedDate.setMonth(+selectedValue, 1);
            this.viewDate = clonedDate;
        }
    }

    /**
     * Move to the next month by setting selectedDate.
     */
    _moveToNextMonth() {
        let month = this.viewDate.getMonth();
        let year = this.viewDate.getFullYear();

        if (month === 11) {
            year = year + 1;
            month = -1;
        }

        month = month + 1;
        this.viewDate = new Date(year, month, 1);
    }

    /**
     * Move to the previous month by setting selectedDate.
     */
    _moveToPreviousMonth() {
        let month = this.viewDate.getMonth();
        let year = this.viewDate.getFullYear();

        if (month === 0) {
            year = year - 1;
            month = 12;
        }

        month = month - 1;
        this.viewDate = new Date(year, month, 1);
    }

    /**
     * Updates the selection boxes.
     * @private
     */
    _updateSelectElements() {
        if (this._monthSelect != null) {
            this._monthSelect.selectedIndex = this.viewDate.getMonth();
        }
        if (this._yearSelect != null) {
            this._yearSelect.value = this.viewDate.getFullYear();
        }
    }

    /**
     * Event Handler for when the year selectbox is changed.
     * @param {Event} event
     * @private
     */
    _yearChange(event) {
        const element = domHelper.findParentWithClass(event.target, "year-select");

        // noinspection SuspiciousTypeOfGuard
        if (event != null && element != null) {

            if (element.selectedOptions == null || element.selectedOptions.length === 0)
                return;
            const selectedValue = element.selectedOptions[0].value;

            if (selectedValue == null)
                return;

            const clonedDate = new Date(+this.viewDate);
            clonedDate.setFullYear(+selectedValue);
            this.viewDate = clonedDate;
        }
    }

    focusStart() {
        const backButton = this._calendarContainer.querySelector(".button-previous-month");
        backButton.focus();
    }

    getDayContainersForDates(dates) {
        const models = this.dataStore.getDataModelsForDates(dates);

        if (models == null) {
            return null;
        }

        const returnValues = [];

        for (const element of this._detailsContainer.children) {
            const model = models.find(o => +o.index === +element.dataset.index);

            if (model != null) {
                returnValues.push({model, element});
            }
        }

        return returnValues;
    }
}

customElements.define('pr-calendar', Calendar);