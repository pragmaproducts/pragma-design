import {BaseNavigation} from "./base-navigation.js";

export class DialogNavigation extends BaseNavigation {
    
    constructor(element, closeHandler, args) {
        super();
        
        this.element = element;
        this.focusedBeforeOpen = null;
        this.focusable = [];
        this._closeHandler = closeHandler;
        this._args = args;
        
        this._keydownHandler = this.keydown.bind(this);
        this.element.addEventListener("keydown", this._keydownHandler);
    }
    
    dispose() {
        this.element.removeEventListener("keydown", this._keydownHandler);
        
        this._keydownHandler = null;
        this._closeHandler = null;
        this.focusedBeforeOpen = null;
        this.focusable = null;
        this._args = null;
        
        super.dispose();
    }

    /**
     * Place focus on the first focusable element in the dialog
     */
    _focusFirstDialogElement() {
        if (this.firstFocusable != null) {
            this.firstFocusable.focus();
        } 
    }

    /**
     * Saves the current focused element before the dialog is opened
     */
    _saveFocusedElementBeforeOpen() {
        this.focusedBeforeOpen = document.activeElement;
    }

    /**
     * Sets an array of all the focusable elements
     */
    _setFocusableElements() {
        const elements = Array.from(this.element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]'));
        
        for (let element of elements) {
            if (element.hasAttribute("aria-hidden") === false || element.getAttribute("aria-hidden") === "false") {
                this.focusable.push(element);
            }
        }
        
        if (elements.length > 0) {
            this.firstFocusable = this.focusable[0];
            this.lastFocusable = this.focusable[this.focusable.length - 1];
        } 
    }

    /**
     * Handler for tabbing backwards
     * @param event
     */
    _tabBackward(event) {
        if (this.focusable.length > 0 && document.activeElement === this.firstFocusable) {
            this.lastFocusable.focus();
        }
    }

    /**
     * Handler for tabbing forward
     * @param event
     */
    _tabForward(event) {
        if (this.focusable.length > 0 && document.activeElement === this.lastFocusable) {
           this.firstFocusable.focus();
        } 
    }
    
    /**
     * Returns focus to the element that had focus before the dialog opened
     */
    focusOpeningElement() {
        if(this.focusedBeforeOpen != null) {
            this.focusedBeforeOpen.focus();
        }
    }

    /**
     * keydown handler
     * @param event
     */
    keydown(event) {
        switch (event.key) {
            case this.keyCodes.escape: 
                if (this._closeHandler != null) {
                    this._closeHandler(this._args);
                    event.stopPropagation(); // Preventing multiple dialogs from closing when escape is pressed
                } 
                break;
            case this.keyCodes.tab:
                if (this.focusable.length === 1) {
                    event.preventDefault();
                    break;
                } 
                
                if (event.shiftKey === false) {
                    this._tabForward(event);
                } 
                else {
                    this._tabBackward(event);
                }
                break;
            default: 
                break;
        }
        this.focusable = [];
    }

    applyFocus() {
        this._saveFocusedElementBeforeOpen(); 
        this._setFocusableElements();
        this._focusFirstDialogElement();
    }
}