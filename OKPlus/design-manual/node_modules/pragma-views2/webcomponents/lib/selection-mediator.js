import {HierarchicalItem} from "./../../lib/hierarchical-item.js";
import {HierarchicalRenderer} from "./render-hierarchical.js";

export class SelectionMediator {
    constructor(dataSource, selectionReference, allowMultipleSelect, expandRef) {
        this.rules = [];
        this.allowMultipleSelect = allowMultipleSelect;
        this.dataSource = dataSource;
        this.addSelectionReferenceRule(selectionReference);
        this.compileRules();
        this.visibleSelection = {};
        this._expandRef = expandRef;
    }

    dispose() {
        if(this.rules.length > 0) {
            window.compiler.remove(this.ruleFn);
            this.ruleFn = null;
        }
        this.rules = null;
        this.allowMultipleSelect = null;
        delete this.dataSource;
    }

    _findAffectedItems(item, selectedItems = new Map()) {
        if (item instanceof HierarchicalItem && item.hasChildren) {
            for (const child of item.items) {
                this._findAffectedItems(child, selectedItems)
            }
        } else {
            selectedItems.set(this.getItemId(item), item);
        }
        return selectedItems;
    }

    _multipleSelect(item, selected) {
        const affectedItems = this._findAffectedItems(item);
        this._setDataSourceSelection(affectedItems, selected);
        this.dataSource.selectionChanged();
    }

    _setDataSourceSelection(affectedItems, selected) {
        for(const key of affectedItems.keys()) {
            const existingItem = this.dataSource.selectedItemsMap.get(key);
            if(existingItem != null && selected === false) {
                this.dataSource.selectedItemsMap.delete(key);
            }

            if(existingItem == null && selected === true) {
                this.dataSource.selectedItemsMap.set(key, this.getModel(affectedItems.get(key)));
            }
        }
    }

    _singleSelect(item) {
        if (item instanceof HierarchicalItem && (item.hasChildren === true || item.model[this._expandRef] === true)) return;
        this.dataSource.selectedItemsMap.clear();
        this.dataSource.selectedItemsMap.set(this.getItemId(item),this.getModel(item));
        this.dataSource.selectionChanged();
    }

    /**
     * This function adds a rule if a selection reference is specified. For example your data could have a property on them that could be "selectable: true".
     * Ihis expression will be evaluated if selection could be applied to an item.
     * @param selectionReference
     */
    addSelectionReferenceRule(selectionReference) {
        if (selectionReference != null) {
            this.rules.push(selectionReference);
        }
    }

    addToVisibleSelection(index, items) {
        let counter = index + 1;
        for(const child of items) {
            if(child.__isSelected === true) {
                this.visibleSelection[counter] = child;
            }
            counter++;
        }
    }

    applySelection(item, selected, deselectOthers = false) {
        if (this.validateRules(item)) {
            const fn = this.allowMultipleSelect === true && deselectOthers === false? this._multipleSelect.bind(this) : this._singleSelect.bind(this);
            fn(item, selected);
        }
    }

    checkIfItemShouldBeSelectedRecursive(item, idMap) {
        if (idMap == null) return false;
        if (item.hasChildren === true) {
            let counterIdsFound = 0;
            for (const child of item.items) {
                const idSelected = this.checkIfItemShouldBeSelectedRecursive(child, idMap);
                counterIdsFound += (idSelected === true) ? 1 : 0;
            }

            item.__isSelected = counterIdsFound === item.items.length
            return item.__isSelected;
        } else {
            const selectedItem = idMap.get(this.getItemId(item));
            item.__isSelected = selectedItem != null;
            return item.__isSelected;
        }
    }

    compileRules() {
        if(this.rules.length === 0) return;
        this.ruleFn = window.compiler.add(this.rules.join(" && "), false);
    }

    getItemId(item) {
        return this.getModel(item)[this.dataSource.idField];
    }

    getModel(item) {
        return item instanceof HierarchicalItem ? item.model : item;
    }

    removeFromVisibleSelection(index, items) {
        let counter = index + 1;
        for(const child of items) {
            if(child.__isSelected === true) {
                delete this.visibleSelection[counter];
            }
            counter++;
        }
    }

    validateRules(item) {
        if(this.rules.length === 0) return true;
        return this.ruleFn(item);
    }

    // TODO use datasource map
    visibleSelectionChanged(visibleItems) {
        const changedRecords = {};

        for (let i = 0; i < visibleItems.length; i++) {
            const model = visibleItems[i];

            model.__isSelected = this.checkIfItemShouldBeSelectedRecursive(model, this.dataSource.selectedItemsMap);
            if (model.__isSelected === true && this.visibleSelection[i] == null) {
                this.visibleSelection[i] = model;
                changedRecords[i] = model;
            }
            if (model.__isSelected === false && this.visibleSelection[i] != null) {
                delete this.visibleSelection[i];
                changedRecords[i] = model;
            }
        }

        return changedRecords;
    }
}