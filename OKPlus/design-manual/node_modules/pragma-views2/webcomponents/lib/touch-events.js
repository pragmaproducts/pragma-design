export class TouchEvents {
    constructor(element, options) {
        this.element = element;
        this.options = options;

        this.touchStartHandler = this.touchStart.bind(this);
        this.touchMoveHandler = this.touchMove.bind(this);
        this.touchEndHandler = this.touchEnd.bind(this);

        this.element.addEventListener('touchstart', this.touchStartHandler, { passive: true });
        this.element.addEventListener('touchmove', this.touchMoveHandler, { passive: true });
        this.element.addEventListener('touchend', this.touchEndHandler, true);
        this.element.addEventListener('touchcancel', this.touchEndHandler, true);

        this.dragging = false;
        this.longPressTimeout = 800;
    }

    dispose() {
        this.initialPoint = null;
        this.dragging = null;
        this.delay = null;
        this.longPressTimeout = null;
        
        this.element.removeEventListener('touchcancel', this.touchEndHandler);
        this.element.removeEventListener('touchend', this.touchEndHandler);
        this.element.removeEventListener('touchmove', this.touchMoveHandler);
        this.element.removeEventListener('touchstart', this.touchStartHandler);

        this.touchEndHandler = null;
        this.touchMoveHandler = null;
        this.touchStartHandler = null;

        this.options = null;
        this.element = null;
    }

    /**
     * Calls initialized long press handler.
     * @param event
     */
    performLongPress(event) {
        if (this.options.longPress != null) {
            this.options.longPress(event);
        }
    }

    /**
     * Calculates difference of start and end points to determine swipe direction and calls associated handler.
     * @param startPoint - Coordinates of initial touch
     * @param endPoint - Coordinates of final touch
     */
    performSwipe(startPoint, endPoint) {
        const xDifference = startPoint.x - endPoint.x;
        const yDifference = startPoint.y - endPoint.y;

        // noinspection JSSuspiciousNameCombination
        if (Math.abs(xDifference) > Math.abs(yDifference)) {
            return xDifference > 0 ? this.swipeLeft() : this.swipeRight();
        } else {
            return yDifference > 0 ? this.swipeUp() : this.swipeDown();
        }
    }

    /**
     * Calls initialized swipe down handler.
     */
    swipeDown() {
        if (this.options.swipeDown != null) {
            this.options.swipeDown();
        }
    }

    /**
     * Calls initialized swipe left handler.
     */
    swipeLeft() {
        if (this.options.swipeLeft != null) {
            this.options.swipeLeft();
        }
    }

    /**
     * Calls initialized swipe right handler.
     */
    swipeRight() {
        if (this.options.swipeRight != null) {
            this.options.swipeRight();
        }
    }

    /**
     * Calls initialized swipe up handler.
     */
    swipeUp() {
        if (this.options.swipeUp != null) {
            this.options.swipeUp();
        }
    }

    /**
     * Handles final touch event, if touch drag/move is detected perform the swipe action.
     * @param event - Touch end event object
     */
    touchEnd(event) {
        clearTimeout(this.delay);
        if (this.touching === true) {
            this.transformElement("", event);   
        }
        
        if (this.dragging === true) {
            const endPoint = {
                x: event.changedTouches[0].clientX,
                y: event.changedTouches[0].clientY
            };
            this.performSwipe(this.initialPoint, endPoint);
        }

        this.dragging = false;
        this.touching = false;
        this.initialPoint.x = null;
        this.initialPoint.y = null;
    }

    /**
     * Handles touch drag/move event, sets flag to denote dragging for later use.
     * @param event - Touch move event object.
     */
    touchMove(event) {
        clearTimeout(this.delay);
        this.currentX = event.touches[0].clientX;
        this.dragging = this.initialPoint.isValid();
    }

    /**
     * Handles touch start event, sets the initial point object of first touch.
     * @param event - Touch start event object.
     */
    touchStart(event) {
        this.delay = setTimeout(this.performLongPress.bind(this, event), this.longPressTimeout);
        this.initialPoint = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY,
            isValid: function () {
                return this.x != null && this.y != null;
            }
        };
        
        this.currentX = this.initialPoint.x;
        this.touching = true;
        requestAnimationFrame(() => this.updatePosition()); // Note (AA): Requesting animation frame here provides better performance
    }

    transformElement(value, touchEvent) {
        if (this.options.transformElement != null) {
            this.options.transformElement(value, touchEvent);
        } 
    }

    /**
     * Adjusts the translated value on the x-axis of the touch element
     */
    updatePosition() {
        if (this.touching === false) {
            return;
        }

        requestAnimationFrame(() => this.updatePosition());
        
        const translateX = Math.min(0, this.currentX - this.initialPoint.x);
        this.transformElement(`translateX(${translateX}px)`);
    }
}