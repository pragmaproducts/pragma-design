import {FlatListRenderer} from "./render-flatlist.js";
import {TemplateFactory} from "./template-factory.js";

export class CustomTemplateRenderer extends FlatListRenderer {
    constructor(container, scroller, dataStore, formatters, selection, templates, depthPadding, customFormattingFn) {
        super(container, scroller, dataStore, formatters);
        this.templateFactory = new TemplateFactory(templates, "condition", formatters);
        this.depthPadding = depthPadding;
        this.customFormattingFn = customFormattingFn;
    }

    dispose() {
        this.templateFactory.dispose();
        delete this.templateFactory;
        delete this.customFormattingFn;
        super.dispose();
    }

    setLastIndex(scrollTop) {
        let heightCount = 0;
        for (let i = 0; i < this.dataStore.data.length; i++) {
            if (scrollTop > heightCount) {
                heightCount += this.dataStore.data[i].__height;
            } else {
                this.lastDataIndex = i;
                break;
            }
        }
    }
    
    getHeight(index) {
        let height = 0;
        for (let i = 0; i < this.dataStore.data.length; i++) {
            if (index > i) {
                const item = this.dataStore.data[i];
                height += item.__height;
            } else {
                break;
            }
        }
        return height;
    }

    setItemSizes() {
        for (let i = 0; i < this.dataStore.data.length; i++) {
            const item = this.dataStore.data[i];
            this.setItemSize(item);
        }
    }
    
    setItemSize(item) {
        if (item.__height == null) {
            const template = this.templateFactory.getTemplateForItem(item);
            item.__height = template.value.dimensions.height;
        }
    }

    getItemFromStore(item) {
        const template = this.getItemTemplate(item);
        const element = template.value.store.getItem();
        element.__id = item.__id;
        const width = this.scroller.offsetWidth > this.dimensions.width? this.scroller.offsetWidth : this.dimensions.width;
        element.style.minWidth = `${width - 1}px`;
        if(this.depthPadding != null) {
            element.style.paddingLeft = `${(item.depth *2) - this.startingDepth || 0}rem`;
        }
        element.templateKey = template.key;

        template.value.inflate.inflateFn(element, item);
        
        if (this.customFormattingFn != null) {
            this.customFormattingFn(element, item);
        }
        
        return element;
    }

    getItemTemplate(item) {
        return this.templateFactory.getTemplateForItem(item);
    }

    totalHeight() {
        let height = 0;
        for (let i = 0; i < this.dataStore.data.length; i++) {
            const item = this.dataStore.data[i];
                const template = this.templateFactory.getTemplateForItem(item);
            height += template.value.dimensions.height;
        }
        return height;
    }

    async renderInitial(data) {
        this.setData(data);
        this.render();
    }

    render() {
        const size = this.capacity * 2;
        for (const item of this.dataStore.data) {
            const template = this.templateFactory.getTemplateForItem(item);
            item.__height = template.value.dimensions.height;
        }

        for (let i = 0; i < size; i++) {
            if (i > this.dataStore.data.length - 1) break;
            if (this.addRowBelow(i) === true) {
                this.lastDataIndex = i;
            }
        }

        this.container.appendChild(this.fragment);
        this.setScrollMarker();
        this.pageSize = (this.capacity * this.dimensions.height);
        this.topMargin = -this.pageSize / 2;
        this.bottomMargin = this.pageSize + (this.pageSize / 2);
    }

    returnItemToStore(element) {
        const template = this.templateFactory.get(element.templateKey);
        element.style.paddingLeft = "";
        template.store.returnItem(element, template.inflate.defaultFn);
    }

    setData(data) {
        this.dataStore.initialize(data);
        this.startingDepth = (this.dataStore.data[0] || {}).depth;
    }

    redrawItem(element, item) {
        const template = this.getItemTemplate(item);
        template.value.inflate.defaultFn(element);
        template.value.inflate.inflateFn(element, item);
    }

    setTemplateDimentions(key, dimensions) {
        const template = this.templateFactory.get(key);
        template.dimensions = dimensions;
        template.capacity = Math.round(this.container.parentElement.offsetHeight / dimensions.height) + 1;
    }

    async measureItem() {
        return new Promise((resolve) => {
            const measureFn = () => {
                for (const key of this.templateFactory.map.keys()) {
                    const templateOptions = this.templateFactory.get(key);
                    const item = templateOptions.store.getItem();
                    item.classList.add("offscreen");
                    this.container.appendChild(item);
                    const rect = item.getBoundingClientRect();
                    this.container.removeChild(item);
                    item.classList.remove("offscreen");
                    if (this.dimensions == null || this.dimensions.height > rect.height) {
                        this.dimensions = {
                            width: rect.width,
                            height: rect.height
                        }
                    }
                    this.setTemplateDimentions(key, {
                        width: rect.width,
                        height: rect.height
                    });
                }

                resolve();
            };

            if (this.scroller.offsetHeight === 0) {
                const interval = setInterval(() => {
                    if (this.scroller == null) {
                        return clearInterval(interval);
                    }
                    if (this.scroller.offsetHeight > 0) {
                        clearInterval(interval);
                        measureFn();
                    }
                }, 100)
            } else {
                measureFn();
            }
        })
    }
}