import {scrollItem, moveItemY} from "./../lib/virtualization-utils.js";
import {createInflatorFunction} from "../../baremetal/lib/virtualization/inflation-utils.js";

export class FlatListRenderer {
    get store() {
        return this._store;
    }
    
    set store(newValue) {
        this._store = newValue;
        
        if (newValue != null) {
            this.initStore();
        }
    }
    
    initStore() {
        this._store.initStore(1);

        let formattingCode = [];
        if (this.formatters != null) {
            for (let formatter of this.formatters) {
                formattingCode.push(formatter.getCode());
            }
        }
        this.inflate = createInflatorFunction(this._store.store[0], formattingCode);
    }
    
    get dimensions() {
        return this._dimensions;
    }
    
    set dimensions(newValue) {
        this._dimensions = newValue;
        this.capacity = Math.round(this.container.parentElement.offsetHeight / this._dimensions.height) + 1;
        this.lastItemTop = -this._dimensions.height;
    }

    get scrollCompletedCallback() {
        return this._scrollCompletedCallback;
    }

    set scrollCompletedCallback(value) {
        this._scrollCompletedCallback = value;
    }
    
    constructor(container, scroller, dataStore, formatters) {
        this.container = container;
        this.scroller = scroller;
        this.dataStore = dataStore;
        this.formatters = formatters;
        
        this.container.__top = 0;
        this.container.__left = 0;

        this.capacity = 0;
        this.store = null;
        this.inflate = null;
        this.scrollTop = 0;
        this.scrollLeft = 0;
        
        this.fragment = document.createDocumentFragment();
        
        this.firstItemTop = 0;
        this.firstDataIndex = 0;
        this.lastItemTop = 0;
        this.lastDataIndex = 0;
        
        this.cleanItemHandler = this.cleanItem.bind(this);
    }

    dispose() {
        this.container = null;
        this.scroller = null;
        this.store = null;
        this.inflate = null;
        this.formattingCode = null;
        this.cleanItemHandler = null;
        this.scrollCompletedCallback = null;
    }

    setScrollMarker() {
        const marker = this.scroller.querySelector(".scroll-marker");
        const top = this.totalHeight();
        marker.style.transform = `translate(${this.dimensions.width}px, ${top}px)`;
    }

    totalHeight() {
        return this.dataStore.data.length * this.dimensions.height;
    }
    
    clearFragment() {
        while(this.fragment.firstChild) {
            this.fragment.removeChild(this.fragment.firstChild);
        }
    }

    scrollItems(scrollTop, scrollLeft) {
        return Promise.resolve().then(() => {
            requestAnimationFrame(() => {
                const scrollingDown = this.scrollTop < scrollTop;
                const addFn = scrollingDown == true ? this.addBottomItems : this.addTopItems;
                const deleteFn = scrollingDown == true ? this.deleteTopItems : this.deleteBottomItems;

                const deltaY = scrollTop - this.scrollTop;
                const deltaX = scrollLeft - this.scrollLeft;

                let numberOfPages = 0;
                if (Math.abs(deltaY) > this.pageSize) {
                    numberOfPages = Math.abs(Math.round(deltaY / this.pageSize));
                }

                if (numberOfPages == 0) {
                    Promise.resolve().then(() => {
                        scrollItem(this.container, deltaY, deltaX);
                        addFn.call(this);
                        deleteFn.call(this);
                        if (this.scrollCompletedCallback != null) this.scrollCompletedCallback();
                    })
                } else {
                    Promise.resolve().then(() => {
                        this.clearAllItems();
                        moveItemY(this.container, -scrollTop, -scrollLeft);
                        this.drawPageForScrollTop(scrollTop);
                        this.container.appendChild(this.fragment);
                        this.clearFragment();
                        if (this.scrollCompletedCallback != null) this.scrollCompletedCallback();
                    })
                }

                this.scrollTop = scrollTop;
                this.scrollLeft = scrollLeft;
            });
        });
    }
    
    async renderInitial(data) {
        const size = this.capacity * 2;
        this.store.initStore(size);
        this.setData(data);

        for (let i = 0; i < size; i++) {
            if (i > this.dataStore.data.length - 1) break;
            if (this.addRowBelow(i) === true) {
                this.lastDataIndex = i;
            }
        }

        this.container.appendChild(this.fragment);

        this.pageSize = (this.capacity * this.dimensions.height);
        this.screenBottom = this.pageSize;
        this.topMargin = -this.pageSize / 2;
        this.bottomMargin = this.pageSize + (this.pageSize / 2);
    }
    
    setData(data) {
        this.dataStore.initialize(data.items  || data);
    }

    setLastIndex(scrollTop) {
        this.lastDataIndex = Math.round(scrollTop / this.dimensions.height);
    }
    
    drawPageForScrollTop(scrollTop) {
        this.setLastIndex(scrollTop);
        this.firstDataIndex = this.lastDataIndex;
        
        for (let i = 0; i < this.capacity; i++) {
            if(this.addRowBelow(this.lastDataIndex) === true) {
                this.lastDataIndex += 1;
            }
            else{
                break;
            }
        }

        // because the loop inc we just need to set it back one else we will skip a row.
        this.lastDataIndex--;
    }

    clearAllItems() {
        while(this.container.firstChild != null) {
            this.returnItemToStore(this.container.firstChild);
        }
    }
    
    getItemFromStore(item) {
        const element = this.store.getItem();
        this.inflate.inflateFn(element, item);
        return element;
    }
    
    returnItemToStore(element) {
        this.store.returnItem(element, this.cleanItemHandler);
    }
    
    addBottomItems() {
        let index = this.lastDataIndex;

        while (this.addRowBelow(index + 1) == true) {
            index++;
        }

        this.lastDataIndex = index;
        this.container.appendChild(this.fragment);
        this.clearFragment();
    }
    
    addTopItems() {
        let index = this.firstDataIndex;

        while (this.addRowAbove(index - 1) === true) {
            index--;
        }

        this.firstDataIndex = index;
        this.container.insertBefore(this.fragment, this.container.firstChild);
        this.clearFragment();
    }
    
    addRowBelow(dataIndex) {
        if (dataIndex > this.dataStore.data.length -1) return false;

        const top = this.getHeight(dataIndex);
        
        if (this.container.__top + top > this.bottomMargin) return false;

        const item = this.dataStore.data[dataIndex];
        const element = this.getItemFromStore(item);

        element.__top = top;
        element.__dataIndex = dataIndex;
        element.style.transform = `translate(0px, ${element.__top}px)`;

        this.fragment.appendChild(element);
        this.lastItemTop = top;
        
        return true;
    }
    
    getHeight(dataIndex) {
        return dataIndex * this.dimensions.height;
    }

    addRowAbove(dataIndex) {
        if (dataIndex < 0) return false;
        
        const top = this.getHeight(dataIndex);
        if (this.container.__top + top < this.topMargin) return false;

        const item = this.dataStore.data[dataIndex];
        const element = this.getItemFromStore(item)

        element.__top = top;
        element.__dataIndex = dataIndex;
        element.style.transform = `translate(0px, ${element.__top}px)`;
        
        this.fragment.appendChild(element);
        this.firstItemTop = top;
        
        return true;
    }

    redrawItem(element, item) {
        this.inflate.defaultFn(element, item);
        this.inflate.inflateFn(element, item);
    }
    
    deleteTopItems() {
        if (this.container.firstChild == null) return;
        
        let item = this.container.firstChild;
        
        while (this.container.__top + item.__top < this.topMargin) {
            this.returnItemToStore(item);

            item = this.container.firstChild;
            this.firstDataIndex = item.__dataIndex;
            this.firstItemTop = item.__top;
        }
    }

    deleteBottomItems() {
        let item = this.container.children[this.container.children.length -1];

        while (this.container.__top + item.__top > this.bottomMargin) {
            this.returnItemToStore(item);

            item = this.container.children[this.container.children.length -1];
            this.lastDataIndex = item.__dataIndex;
            this.lastItemTop = item.__top;
        }
    }
    
    cleanItem(element) {
        element.style.background = null;
    }
    
    redrawCurrentPage() {
        this.clearAllItems();
        this.drawPageForScrollTop(this.scrollTop);
        this.container.appendChild(this.fragment);
        this.clearFragment();
    }
}