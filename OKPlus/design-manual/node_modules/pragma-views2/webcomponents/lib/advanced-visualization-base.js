import { DataSourceVisualizationBase } from "./data-source-visualization-base.js";
import { DataSourceStateConstants } from "./../../lib/datasource-constants.js";
import { DataStore } from "./data-store.js";
import { isArraysSame } from "./../../lib/array-helpers.js"
import { ComponentUiStates } from "./../../lib/component-ui-states.js";
import { registerDataCollectionState, unregisterDataCollectionState } from "./../lib/mixin-datacollection-state.js";
import { KeyboardHelperBase } from "./keyboard-helper-base.js";
import { ScrollBase } from "./scroll-base.js";
import { FocusBase } from "./focus-base.js";
import { NavigationBase } from "./navigation-base.js";
import {DataSourceBase} from "./../../lib/datasource-base.js";

export class AdvancedVisualizationBase extends DataSourceVisualizationBase {
    /**
     * Scroller getter
     * @returns Scroller element (scroller-container class)
     */
    get scroller() {
        return this.getProperty("scroller", () => this.querySelector(".scroll-container"));
    }

    /**
     * Scroller setter
     * @param newValue: element or null
     */
    set scroller(newValue) {
        this.setProperty("scroller", newValue);
    }

    /**
     * Items container getter
     * @returns element to be used as items container
     */
    get container() {
        return this.getProperty("container", () => this.querySelector(".items-container"));
    }

    /**
     * Items container setter
     * @param newValue: element or null
     */
    set container(newValue) {
        this.setProperty("container", newValue);
    }

    /**
     * Formatters getter
     * @returns array of formatters (pragma-conditional-formatter)
     */
    get formatters() {
        return this.getProperty("formatters", () => Array.from(this.querySelectorAll("pragma-conditional-formatter")));
    }

    /**
     * Formatters setter
     * @param newValue: Array of formatters or null
     */
    set formatters(newValue) {
        this.setProperty("formatters", newValue);
    }

    /**
     * Templates getter
     * @returns Array of templates to be used in rendering for each template type defined
     */
    get templates() {
        return this.getProperty("templates", () => Array.from(this.querySelectorAll("template")));
    }

    /**
     * Templates setter
     * @param newValue: Array of template elements or null
     */
    set templates(newValue) {
        this.setProperty("templates", newValue);
    }

    get datasource() {
        return super.datasource;
    }

    set datasource(value) {
        super.datasource = value;
    }

    get renderer() {
        return this.getProperty("renderer", () => {
            return null;
        });
    }

    set renderer(value) {
        this.setProperty("renderer", value);
        if (value != null && this.render.scrollCompletedCallback == null) {
            this.renderer.scrollCompletedCallback = this.keyboardHelper.scrolled.bind(this);
        }


    }

    /**
     * @returns {KeyboardHelperBase}
     */
    get keyboardHelper() {
        return this.getProperty("keyboardHelper", () => {
            return new KeyboardHelperBase(this);
        });
    }

    /**
     * @param {KeyboardHelperBase} value
     */
    set keyboardHelper(value) {
        this.setProperty("keyboardHelper", value);
    }

    /**
     * @returns {ScrollBase}
     */
    get scroll() {
        return this.getProperty("scroll", () => {
            return new ScrollBase(this);
        });
    }

    /**
     * @param {ScrollBase} value
     */
    set scroll(value) {
        this.setProperty("scroll", value);
    }

    /**
     * @returns {FocusBase}
     */
    get focus() {
        return this.getProperty("focus", () => {
            return new FocusBase(this);
        });
    }

    /**
     * @param {FocusBase} value
     */
    set focus(value) {
        this.setProperty("focus", value);
    }

    /**
     * @returns {NavigationBase}
     */
    get navigation() {
        return this.getProperty("navigation", () => {
            return new NavigationBase(this);
        })
    }

    /**
     * @param {NavigationBase} value
     */
    set navigation(value) {
        this.setProperty("navigation", value);
    }

    get ready() {
        return this._ready;
    }

    set ready(newValue) {
        this._ready = newValue;
        if (this.readyCallback != null) {
            this.readyCallback(newValue);
        }
    }

    get selectedId() {
        return this._selectedId;
    }

    set selectedId(newValue) {
        if (newValue == null) return;

        if (this.datasource != null && !isArraysSame(newValue, this.datasource.selectedId)) {
            this.datasource.selectedId = newValue;
        }
        else if (this._selectedId == null || !isArraysSame(newValue, this.selectedId)) {
            this._selectedId = newValue;
            this.notifyPropertyChanged("selected-id", newValue);
        }
    }

    get uiState() {
        return this._uiState;
    }

    set uiState(newValue) {
        this._uiState = newValue;
        if (newValue === ComponentUiStates.active && this.datasource != null) {
            this.datasource.uiStateManager.componentStateChanged();
            this.stateChanged();
        }
    }

    connectedCallback() {
        super.connectedCallback();
        registerDataCollectionState(this);

        const dataStoreOptions = {
            perspective: this.perspective
        };
        this.dataStore = new DataStore(dataStoreOptions);
        this.dataStore.datasource = this.datasource;

        if (this.uiState == null) {
            this.uiState = ComponentUiStates.suspended;
        }
        this.setAttribute("tabIndex", "0");

        this.registerInputIntent(this, "contextmenu", this.rightClick.bind(this));
        this.registerInputIntent(this, "click", this.click.bind(this));
    }

    disconnectedCallback() {
        this.scroller = null;
        this.container = null;
        this.formatters = null;
        this.templates = null;
        this.scroller = null;
        this.keyboardHelper = null;
        this.focus = null;
        this.scroll = null;
        this.navigation = null;
        unregisterDataCollectionState(this);
        if (this.datasource != null && this.datasource.uiStateManager != null) {
            this.datasource.uiStateManager.unregisterComponent(this);
        }
        super.disconnectedCallback();
    }

    async clear() { }

    /**
     * Raise custom events that can be consumed by callers
     * @param eventName
     * @param parameters
     */
    dispatchCustomEvent(eventName, parameters) {
        if (parameters == null) parameters = {};

        const event = new CustomEvent(eventName, {
            bubbles: true,
            detail: parameters
        });
        this.dispatchEvent(event);
    }

    itemsAdded({ items, perspectives }) {
        this.dataStore.itemsAdded(items, perspectives);
        this.renderer.redrawCurrentPage();
        this.renderer.setScrollMarker();
    }

    itemsDeleted({ items, perspectives }) {
        this.dataStore.itemsDeleted(items, perspectives);
        this.renderer.redrawCurrentPage();
        this.renderer.setScrollMarker();
    }

    itemsUpdated({ items, perspectives }) {
        this.dataStore.itemsUpdated(items, perspectives);
        this.renderer.redrawCurrentPage();
        this.renderer.setScrollMarker();
    }

    /**
     * To be overridden in implementation.
     * @param {number} index 
     */
    getItemDimensions(index) { }

    /**
     * Render function to be overridden in base implementations
     * @returns {Promise<void>}
     */
    async render() { }

    async performRender(dataReadyCallback) {
        if (this.uiState === ComponentUiStates.suspended || this.isRendering === true) return;

        this.isRendering = true;
        this.clear();

        await this.measureItem();

        this.isLoaded = true;

        if (this.datasource != null && this.datasource.state === DataSourceStateConstants.none) {
            this.datasource.data({ perspective: this.perspective }).then(async (items) => {
                if (dataReadyCallback != null) {
                    dataReadyCallback(items);
                }
            });
        }
        this.isRendering = false;
    }

    performDatasourceValidation(newValue, callback) {
        if ((newValue != null && newValue instanceof DataSourceBase === false) || newValue === this.datasource) return;
        if (this.datasource != null) {
            this.datasource.readyCallback = null;
        }
        super.datasource = newValue;
        if (newValue != null) {
            this.datasource.uiStateManager.registerComponent(this);
            if (this.dataStore != null) {
                this.dataStore.datasource = newValue;
            }

            callback();

            if (this.datasource.state === DataSourceStateConstants.none) {
                this.stateChanged();
            }
        }
    }

    /**
     * State change handler, render visualisation when sate is none
     * @returns {Promise<void>}
     */
    async stateChanged() {
        if (this.uiState === ComponentUiStates.suspended) return;

        if (this.datasource.state === DataSourceStateConstants.none) {
            if (this.selectedId != null && this.selectedId.length > 0) {
                this.datasource.selectedId = this.selectedId;
            }
            await this.render();
        }
        else if (this.datasource.state === DataSourceStateConstants.busy) {
            await this.clear()
        }
    }

    calculateRunway(numberOfItems) {
        if (this.renderer.dimentions == null) return;

        const top = numberOfItems * this.renderer.dimentions.height;
        this.scrollMarker.style.transform = `translate(${this.renderer.dimentions.width}px, ${top}px)`;
    }

    selectionChanged(selectedItems, callback) {
        const changedMap = this.dataStore.selectionChanged();
        this.selectedId = this.datasource.selectedId;
        const rows = Array.from(this.querySelectorAll(".items-container > div"));

        for (const keyValue of Object.entries(changedMap)) {
            const row = rows.find(r => r.__dataIndex === Number(keyValue[0]));
            if (row != null) {
                this.renderer.redrawItem(row, keyValue[1]);
            }
        }

        if (callback != null) {
            callback();
        }
    }

    /**
     * Override this in derived class to add functionality
     * @param event
     * @returns {Element[]}
     */
    click(event) {
        let elements = document.elementsFromPoint(event.pageX, event.pageY);
        if (elements[0].className == "scroll-container") {elements = elements.slice(1); }
        return elements;
    }

    /**
     * Override this in derived class to add functionality
     * @param e
     * @returns {Element[]}
     */
    rightClick(e) {
        this.click(e);
    }
    
    /**
     * Scrolls to the row index and cell index, scrolling into view if necessary.
     * @param {String} verticalScrollDirection
     * @param {String} horizontalScrollDirection
     * @param {number} index
     * @returns {Promise<void>}
     */
    async scrollAndFocus(verticalScrollDirection, horizontalScrollDirection, index) {
        if (this.renderer == null) return;
        this.focus.index = index == null ? this.focus.index : index;
        await this.scroll.scroll(verticalScrollDirection, horizontalScrollDirection, this.focus.index);
        this.focus.focus();
    }
}