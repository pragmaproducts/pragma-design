import {selectionMode} from './../lib/selection-mode.js'
import {BaseElement} from '../../baremetal/lib/base-element.js';
import {DataSourceStateConstants} from "./../../lib/datasource-constants.js";

export class VisualizationBase extends BaseElement {
    constructor() {
        super();
    }

    get batchSize() {
        return this._batchSize;
    }

    set batchSize(value) {
        this._batchSize = value;
    }

    get datasource() {
        return this._datasource;
    }

    set datasource(newValue) {
        if (newValue != null) {
            this._datasource = newValue;
            this._datasource = this.datasource;

            if (this._datasource.state === DataSourceStateConstants.none) {
                this._fetchDataFromDataSource();
            }
        }
    }

    get idField() {
        return this._idField || this.getAttribute("id-field");
    }

    set idField(value) {
        this._idField = value;
    }

    get perspective() {
        return this.getAttribute("perspective") || this._perspective;
    }

    set perspective(newValue) {
        this._perspective = newValue;

        if (newValue != null) {
            this.getData({perspective: newValue});
        }
    }

    get selectedId() {
        return this.getAttribute("selected-id") || this._selectedId;
    }

    set selectedId(newValue) {

    }

    get selection() {
        return this.getAttribute("selection") || this._selection;
    }

    set selection(value) {
        this._selection = value;
    }
    
    /**
     *
     * @param event
     * @private
     */
    _workerMessage(event) {
        const data = event.data;

        if (data.items.length > 0) {
            this.updateUI(data);
        }
        else {
            this.disposeWorker(data.id);
        }
    }

    /**
     * Called when the datasource is being processed
     * Sets the initial data collection that the derived class will use
     * Sets if the data structure is hierarchical
     */
    async checkDatasourceStructure(data) {
        if (data == null) {
            return;
        }

        if (Array.isArray(data) && data.length > 0) {
            this.isHierarchical = data[0].constructor != null && data[0].constructor.name === "HierarchicalItem";

            if (this.isHierarchical === true) {
                // NOTE JN: For Hierarchical data, when the root's child items are empty, perform a fetch
                if (data[0].depth === 0 && data[0].items == null) {
                    await this._datasource.load(null, data[0]);
                }
                this.data = data[0].items;
            }
            else {
                this.data = data;
            }
        }
        else {
            if (data.items != null) {
                this.data = data.items;
            }
        }
    }

    /**
     * Override in derived class to provide functionality
     */
    clear() {
    }

    /**
     * Reset the value of selected id based on the selection mode
     */
    clearSelectedId() {
        //this.datasource.selectedId = [];
    }

    /**
     * Click event handler
     * @param event
     */
    click(event) {
    }

    async connectedCallback() {
        this.initTemplate();

        this.workers = new Map();
        this.clickHandler = this.click.bind(this);
        this.doubleClickHandler = this.doubleClick.bind(this);
        this.keyUpHandler = this.keyUp.bind(this);
        this._workerMessageHandler = this._workerMessage.bind(this);

        this.addEventListener("click", this.clickHandler);
        this.addEventListener("dblclick", this.doubleClickHandler);
        this.addEventListener("keyup", this.keyUpHandler);

        this.loadIndicator = document.createElement("pragma-action-icon");
        this.appendChild(this.loadIndicator);
        this.loadIndicator.classList.add("vis-loading");
        this.loadIndicator.setAttribute("state", "busy");
    }

    /**
     * Data source state change handler, will set load indicator state, fetch data and update UI
     * @param state
     * @returns {Promise<void>}
     */
    async dataSourceStateChanged(state) {
        if (this._datasource == null) return;

        if (state === DataSourceStateConstants.none) {
            await this._fetchDataFromDataSource();
        }
    }

    /**
     * Fetch data from data source
     * @returns {Promise<void>}
     * @private
     */
    async _fetchDataFromDataSource() {
        if (this.data != null) {
            this.clear();
        }

        if (this._datasource.definition.perspective == null) {
            return this.getData(null);
        }

        if (this.perspective != null) {
            await this.getData({perspective: this.perspective});
        }
    }

    disconnectedCallback() {
        this.removeEventListener("click", this.clickHandler);
        this.removeEventListener("dblclick", this.doubleClickHandler);
        this.removeEventListener("keyup", this.keyUpHandler);

        this.clickHandler = null;
        this.doubleClickHandler = null;
        this.keyUpHandler = null;
        this.data = null;
        this.workers = null;
        this.isHierarchical = null;
        this._idField = null;
        this._datasource = null;
        this._batchSize = null;
        this._perspective = null;
        this._selectedId = null;
        this._selection = null;
        this.loadIndicator = null;
    }

   

    /**
     * Terminates a worker and removes it from the map
     * @param id
     */
    disposeWorker(id) {
        if (this.workers.has(id)) {
            const composite = this.workers.get(id);
            composite.worker.terminate();
            this.workers.delete(id);
        }
    }

    /**
     * Double click event handler
     * @param event
     */
    doubleClick(event) {
    }

    async getData(perspective) {
        this.loadIndicator.setAttribute("state", "busy");
        try {
            const data = await this._datasource.data(perspective);

            if (data != null) {
                this.data = data;
                await this.update(data);
            }
        }
        finally {
            this.loadIndicator.setAttribute("state", "none");
        }
    }

    /**
     * Get a instance of the template you want to load
     * Override this in the inherited component
     */
    getTemplateInstance() {
    }

    /**
     *
     * @param id
     * @returns {*}
     */
    getWorker(id) {
        if (this.workers != null && this.workers.has(id)) {
            return this.workers.get(id);
        }

        const composite = {
            page: 0,
            worker: new Worker("./batch-worker.js")
        };

        composite.worker.addEventListener("message", this._workerMessageHandler);
        this.workers.set(id, composite);

        return composite;
    }

    /**
     * Initialises the selection mode on the component
     * Selection mode can either be single or multi-select
     */
    initSelectionMode() {
        const mode = this.selection == null ? selectionMode.multiple : selectionMode[this.selection];
        const isArray = Array.isArray(this.selectedId) === true;

        this.classList.add(mode);

        if (mode === selectionMode.multiple) {
            if (this.selectedId != null && isArray === false) {
                console.error(`Incorrect component usage. Selected id should be an array when selection mode is ${mode}.`);
            }
            else {
                if (this.selectedId == null) {
                    this.selectedId = [];
                }
            }
        }
        else if (this.selectedId != null && isArray) {
            console.error(`Incorrect component usage. Selected id cannot be an array when selection mode is ${mode}.`);
        }
    }

    /**
     * Load the component template
     */
    initTemplate() {
    }

    /**
     * Checks if a value is selected
     * @param value: value to check
     * @returns {boolean}
     */
    isSelected(value) {
        if(value == null) {
            return false;
        }

        return Array.isArray(this.selectedId) === true
            ? this.selectedId.find(t => t == value) != null
            : this.selectedId == value;
    }

    /**
     * Keyup event handler
     * @param event
     */
    keyUp(event) {
    }

    /**
     * Removes the child elements from a node in the DOM
     * @param parentElement
     */
    removeChildren(parentElement) {
        if (parentElement == null) return;
        while (parentElement.firstChild) {
            parentElement.removeChild(parentElement.firstChild);
        }
    }

    /**
     * Implement on derived class
     * @param removedItems
     * @param perspectives
     */
    removeItems(removedItems, perspectives) {
        if (this.selection === selectionMode.multiple) {
            const newSelectedId = this.selectedId;
            const dataItems = Array.from(this.items.values());
            for (const item of removedItems) {
                if (newSelectedId.indexOf(item[this.idField]) !== -1) {
                    newSelectedId.splice(newSelectedId.indexOf(item[this.idField]), 1);
                }
                const dataItem = dataItems.find(dataItem => {
                    if (this.isHierarchical){
                      return dataItem.hasChildren === false && dataItem.model.id === item.id; 
                    } 
                    else{
                        return dataItem.id === item.id;
                    }
                });
                if (dataItem != null) {
                    this._deleteItem(dataItem.key);
                }
            }
            this.selectedId = newSelectedId;
        }
    }

    /**
     * Implement on derived class
     * @param addedItems - List of items to add to list
     * @param perspectives
     */
    addItems(addedItems, perspectives) {
        if (this.perspective == null) {
            for (const item of addedItems) {
                const clonedItem = this._setItemKey(null, item);
                this.items.set(clonedItem.key, clonedItem);
                this.addElement(clonedItem);
            }
            return;
        }

        for (const perspective of perspectives) {
            if (perspective.perspective.toString() === this.perspective){
                const items = Array.from(this.items.values());
                for (const item of perspective.items) {
                    if (this.isHierarchical) {
                        this._addItemRecursively(item.newItemPath[0].items, items);
                    }
                    else {
                        const clonedItem = this._setItemKey(null, item.newItem);
                        this.items.set(clonedItem.key, clonedItem);
                        this.addElement(clonedItem);
                    }
                }    
            }
        } 
    }

    /**
     * Implement on derived class
     * @param updatedItems - List of items to add to list
     * @param perspectives
     */
    updateItems(updatedItems, perspectives) {
        const items = Array.from(this.items.values());
        if (this.perspective == null) {
            for (const item of updatedItems) {
                const oldItem = items.find(oldItem => oldItem.id === item.id);
                const dataItem = this.items.get(oldItem.key);
                Object.assign(dataItem, item);
                this.updateElement(dataItem.key, dataItem);
            }
            return;
        }

        for (const perspective of perspectives) {
            if (perspective.perspective.toString() === this.perspective){
                const items = Array.from(this.items.values());
                for (const item of perspective.items) {

                    const oldItem = items.find(oldItem => {
                        const id = this.isHierarchical ? oldItem.model.id : oldItem.id;
                        return id === item.newItem.id;
                    });
                    
                    if (oldItem == null) continue;

                    if (item.groupingChanged === true) {
                        this._deleteItem(oldItem.key);
                        items.splice(items.indexOf(oldItem), 1);
                        this._updateGroupRecursive(item.oldItemPath[0].items, items);
                        this._addItemRecursively(item.newItemPath[0].items, items);
                    }
                    else {
                        const dataItem = this.items.get(oldItem.key);
                        const model = this.isHierarchical ? dataItem.model : dataItem;
                        Object.assign(model, item.newItem);
                        this.updateElement(dataItem.key, dataItem);
                    }
                }
            }
        }
    }

    _updateGroupRecursive(path, items, parentGroup) {
        for (const item of path) {
            if (item.hasChildren === true) {
                let dataGroup = items.find(dataItem => {
                    if (parentGroup == null || dataItem.parentKey === parentGroup.key) {
                        if (dataItem.depth === item.depth && dataItem.model.id === item.model.id) {
                            return true;
                        }
                    }
                    return false;
                });
                this._updateGroup(item, dataGroup);
                this._updateGroupRecursive(item.items, items, dataGroup);
            }
        }
    }

    _updateGroup(updatedGroup, group) {
        let dataItem = this.items.get(group.key);
        Object.assign(dataItem, updatedGroup);
        delete dataItem.items;
        this.updateElement(dataItem.key, updatedGroup);
    }


    _deleteItem(key, onlyDeleteIfNoChildren) {
        const item = this.items.get(key);
        const children = this._findItemsByDepth(item.depth + 1, item.key);

        if (onlyDeleteIfNoChildren === true && children.length !== 0) {
            return;
        }

        if (children.length > 0) {
            for (const child of children) {
                this._deleteItem(child.key)
            }
        }

        this.items.delete(item.key);

        this.removeElement(item);

        if (item.parentKey != null) {
            this._deleteItem(item.parentKey, true);
        }
    }


    _addItemRecursively(newItemPath, items, parent) {
        for (const item of newItemPath) {
            if (item.hasChildren === true) {
                let dataGroup = items.find(dataItem => dataItem.depth === item.depth && dataItem.model.id === item.model.id);
                if (dataGroup == null) {
                    const clonedItem = this._setItemKey(parent, item);
                    this.items.set(clonedItem.key, clonedItem);
                    this.addElement(clonedItem);
                    dataGroup = clonedItem;
                }
                else {
                    this._updateGroup(item, dataGroup);
                }
                this._addItemRecursively(item.items, items, dataGroup);
            }
            else {
                const clonedItem = this._setItemKey(parent, item);
                this.items.set(clonedItem.key, clonedItem);
                this.addElement(clonedItem);
            }
        }
    }

    _setItemKey(parent, item) {
        const clonedItem = {};
        Object.assign(clonedItem, item);
        let index;
        if (parent != null) {
            clonedItem.parentKey = parent.key;
            const items = this._findItemsByDepth(parent.depth + 1, parent.key);
            index = items.length;
        }
        else {
            index = this.items.size;
        }

        clonedItem.key = parent == null ? index.toString() : `${parent.key}_${index}`;

        delete clonedItem.items;
        return clonedItem;
    }


    /**
     * Implement on derived class
     */
    updateElement() {

    }

    /**
     * Implement on derived class
     */
    removeElement() {

    }

    /**
     * Implement on derived class
     */
    addElement() {

    }


    /**
     * Requests a batch of data from the batch-worker
     * for a specific id
     * @param data: Request data
     */
    requestBatch(data) {
        const composite = this.getWorker(data.id);
        data.page = composite.page;
        composite.worker.postMessage(data);
        composite.page++;
    }

    // /**
    //  * Sets the id value on selectedId.
    //  * If the selection state is multiselect the id is added
    //  * to the array otherwise selectedId is the id value
    //  * @param id: id to set
    //  * @param selected: selected status
    //  */
    // selectionChanged(id, selected) {
    //     if (this.selection === selectionMode.multiple) {
    //         const newSelectedId = this.selectedId;
    //         if (selected === true) {
    //             if (newSelectedId.indexOf(id))
    //                 this.selectedId.push(id);
    //             this.notifyPropertyChanged("selected-id", this.selectedId);
    //
    //         }
    //         else {
    //             const index = this.selectedId.indexOf(id);
    //             this.selectedId.splice(index, 1);
    //             this.notifyPropertyChanged("selected-id", this.selectedId);
    //         }
    //     }
    //     else {
    //         this.selectedId = id;
    //
    //     }
    // }

    _findAffectedSelectedIds(item, isSelected, ids) {

        ids = ids == null ? [] : ids;

        if (item.hasChildren === true) {
            const children = this._findItemsByDepth(item.depth + 1, item.key);

            for (const child of children) {
                this._findAffectedSelectedIds(child, isSelected, ids);
            }
        }
        else {
            ids.push(this._getItemId(item));
        }
        return ids;
    }

    _getItemId(item) {
        return this.isHierarchical ? item.model[this.idField] : item[this.idField];
    }

    itemSelectionChanged(key, isSelected) {
        if (this.selection === selectionMode.multiple) {
            let currentSelectedIds = this.datasource.selectedId == null ? [] : this.datasource.selectedId.splice(0);
            
            // Note GM: Converting to map to increase performance of locating item in list. Much much faster than indexOf
            let selectedIdMap = {};
            for (const id of currentSelectedIds) {
                selectedIdMap[id] = id
            }
            
            const item = this.items.get(key);
            const affectedIds = this._findAffectedSelectedIds(item, isSelected);

            for (const affectedId of affectedIds) {
                const idInMap = selectedIdMap[affectedId];
                if (isSelected && idInMap == null) {
                    selectedIdMap[affectedId] = affectedId;
                }
                else if (idInMap != null && isSelected === false) {
                   delete selectedIdMap[affectedId];
                }
            }
           // this.datasource.selectedId = Object.values(selectedIdMap);
        }
        else {
            if (isSelected === true) {
                const item = this.items.get(key);
                //this.datasource.selectedId = [this._getItemId(item)];
            }
        }
    }

    applySelection() {
        if (this.items == null || this.datasource == null || this.datasource.selectedId == null) {
            return;
        }

        let selectedIdMap = {};
            for (const id of this.datasource.selectedId) {
                selectedIdMap[id] = id;
            }
        
        for (const item of this.items.values()) {
            item.isSelected = selectedIdMap[this._getItemId(item)] != null;
        }
       
        if (this.selection === selectionMode.multiple) {
            for (const item of this._findItemsByDepth(1)) {
                if (item.hasChildren === true) {
                    item.isSelected = this._setGroupToSelectedRecursive(item);
                }
            }
        }
    }

    _setGroupToSelectedRecursive(group) {
        const items = this._findItemsByDepth(group.depth + 1, group.key);
        let selectedCount = 0;
        for (const item of items) {
            if (item.hasChildren) {
                item.isSelected = this._setGroupToSelectedRecursive(item);

            }

            if (item.isSelected === true) {
                selectedCount += 1;
            }
        }
        return selectedCount === items.length;
    }


    /**
     * Called when the data is ready on the datasource.
     * Handles the data based on the type
     * @param data
     */
    async update(data) {
        await this.checkDatasourceStructure(data);

        this.items = new Map();
        this._flattenData(this.data);

        const items = this.isHierarchical ? this._findItemsByDepth(1) : Array.from(this.items.values());

        const requestData = {
            dataset: items,
            id: "root",
            page: 0,
            size: this.batchSize
        };
        if(this.selectedId) {
            
            //GM: Temp hack till we move to new visualizations. Fix timing issue when visualization selectedId id is set but datasource not ready
            const id = Array.isArray(this.selectedId) ? this.selectedId : [this.selectedId];
            this.selectedId = null;
            if (this.datasource != null && this.datasource.selectedId == null){
                this.datasource.selectedId = id;
            }
            this.applySelection();
        }
       
        this.requestBatch(requestData);
    }

    _findItemsByDepth(depth, parentKey) {
        const items = [];
        for (const value of this.items.values()) {
            if (value.depth === depth) {
                if ((parentKey != null && value.parentKey === parentKey) || parentKey == null) {
                    items.push(value);
                }
            }
        }
        return items;
    }


    _flattenData(data, parentKey) {
        for (let [index, item] of Object.entries(data)) {

            const key = parentKey == null ? index.toString() : `${parentKey}_${index}`;
            if (parentKey != null) {
                item.parentKey = parentKey;
            }

            item.key = key;
            this.items.set(key, item);
            if (item.hasChildren === true) {
                this._flattenData(item.items, key);
            }
            delete item.items;
        }
    }

    /**
     * Override in derived class to provide functionality
     */
    updateUI() {
    }

    /**
     * Implement in derived class
     * @param selectedId - Item to select
     */
    selectionChanged(selectedId) {
        this.selectedId = selectedId;
    }

    selectedItems() {
        const items = Array.from(this.items.values());
        if (this.selection === "multiple") {
            return items.filter((item) => {
                const model = this.isHierarchical  ? item.model : item;
                return this.selectedId.indexOf(model[this.idField]) !== -1  
            }).map(item=> {
                return this.isHierarchical ? item.model: item 
            });
        }
        else {
            return items.filter((item) => {
                const model = this.isHierarchical  ? item.model : item;
                return model[this.idField] === Number(this.selectedId)  
            }).map(item=> {
                return this.isHierarchical ? item.model: item
            });
        }
    }
}