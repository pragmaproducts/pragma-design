import {Platform} from "./platform.js";
import {BaseShortcuts} from "./base-shortcuts.js";

export class TreeShortcuts extends BaseShortcuts {
    
    constructor(element) {
        super();
        
        this._selectedIndex = 0;
        this._selectedItem = null;
        this._keyupHandler = this.keyup.bind(this);
        this._clickHandler = this._click.bind(this);
        this._inputClickedHandler = this._inputClicked.bind(this);
        this.element = element;
        this._platform = new Platform();
        this._combinations = new Map(
            [["alt + Enter", this._inputClickedHandler]]
        );
        
        this.element.addEventListener("keyup", this._keyupHandler);
        this.element.addEventListener("click", this._clickHandler);
        this.updateChildren();
    }
    
    dispose() {
        this.element.removeEventListener("keyup", this._keyupHandler);
        this.element.removeEventListener("click", this._clickHandler);
        this.element = null;
        this._combinations = null;
        this._keyupHandler = null;
        this._clickHandler = null;
        this._inputClickedHandler = null;
        this._children = null;
        this._selectedItem = null;
        this._selectedIndex = null;
        this._platform = null;
    }

    /**
     * Keyup event handler for the component
     * Invokes the appropriate action based on the key pressed
     * @param event
     */
    keyup(event) {
        
        if (event.altKey === true) {
            return this._keyCombination(event);
        } 
        
        switch (event.keyCode) {
            case this.keyCodes.downArrow:
               this._focusNext();
                break;
            case this.keyCodes.upArrow:
                this._focusPrevious();
                break;
            case this.keyCodes.home: 
                this._focusFirst();
                break;
            case this.keyCodes.end: 
                this._focusLast();
                break;
            case this.keyCodes.leftArrow:
                this._collapse();
                break;
            case this.keyCodes.rightArrow: 
                this._expand();
                break;
            case this.keyCodes.space: 
                this._spacebarClicked(event);
                break;
            case this.keyCodes.enter:
                this._enterClicked(event);
                break;
            default:
                break;
        }
    }

    /**
     * Initialise call for the shortcuts
     * Sets focus to the first element on the tree
     */
    initialize() {
        this._focusFirst();
    }

    /**
     * Places focus on the first item in the tree
     * @private
     */
    _focusFirst() {
        if (this._children.length > 0) {
            this._selectedIndex = 0;
            this._focusItem();
        } 
    }

    /**
     * Places focus on the last item in the tree
     * @private
     */
    _focusLast() {
        if (this._children.length > 0) {
            this._selectedIndex = this._children.length - 1;
            this._focusItem();
        }
    }

    /**
     * Moves focus to the next element
     * @private
     */
    _focusNext() {
        this._selectedIndex++;
        this._ensureBounds();
        this._focusItem(); 
    }

    /**
     * Moves focus to the previous element
     * @private
     */
    _focusPrevious() {
        this._selectedIndex--;
        this._ensureBounds();
        this._focusItem();
    }

    /**
     * Finds the item at the selected index and sets focus on it
     * If a current item has focus it is removed
     * @private
     */
    _focusItem() {
       const item = this._getItem(this._selectedIndex);
       
       if (item != null) {
           if (this._selectedItem != null) {
               this._blur(this._selectedItem);
           } 
           
           this._selectedItem = item;
           this._focus(item);
       } 
    }

    /**
     * Sets focus to the element and adds a focus class
     * @param element
     * @private
     */
    _focus(element) {
        const container = element.querySelector(".item-container");

        super.focus(element);
        container.classList.add("focus");
    }

    /**
     * Removes focus from the element and removes the focus class
     * @param element
     * @private
     */
    _blur(element) {
        const container = element.querySelector(".item-container");
        container.classList.remove("focus");
        super.blur(element);
    }

    /**
     * Ensures that the selected row index remains within bounds of the 
     * number of children available in the tree
     * @private
     */
    _ensureBounds() {
       if (this._selectedIndex < 0) {
           this._selectedIndex = 0;
       } 
       
       if (this._selectedIndex > this._children.length) {
           this._selectedIndex = this._children.length;
       } 
    }

    /**
     * Spacebar click handler
     * Toggles the selection state of a node
     * @param event
     * @private
     */
    _spacebarClicked(event) {
        const item = this._getItem(this._selectedIndex);
        
        if (item != null) {
            const isBranch = this._isBranchNode(item);
            
            if (isBranch === true) {
                const input = item.querySelector("input[type='checkbox']");
                input.click();
            }
        } 
    }

    /**
     * Click event handler for the enter key
     * If the clicked item is a branch it will be expanded/collapsed
     * If the clicked item is a leaf it will be selected
     * @param event
     * @private
     */
    _enterClicked(event) {
        const item = this._getItem(this._selectedIndex);
        
        if (item != null) {
            const isBranch = this._isBranchNode(item);
            const expanded = this._isExpanded(item);
            
            if (isBranch === true && expanded === false) {
                this._expand();
            } 
            else if (isBranch === true && expanded === true) {
                this._collapse();
            }
            else {
                item.click();
            }
        } 
    }

    /**
     * Click handler for the component
     * If the clicked item is different to the current focused item, 
     * the current focused item will be set to the clicked item
     * @param event
     * @private
     */
    _click(event) {
        const target = event.target;
        const li = target.closest("li");

        if (li != null) {
            this.updateChildren();

            const child = this._children.find(t => t == li);

            if (child != null) {

                const index = this._children.indexOf(child);
                
                if (index !== this._selectedIndex) {
                    this._selectedIndex = index;
                    this._focusItem();
                }
            } 
        } 
    }

    /**
     * Performs a click operation on the input box in a list item
     * @param event
     * @private
     */
    _inputClicked(event) {
        const li = event.target.closest("li");
        
        if (li != null) {
            const input = li.querySelector("input[type='checkbox']");
            input.click();
        }
    }
    

    /**
     * Updates the visbility children on the element
     */
    updateChildren() {
        this._children = Array.from(this.element.querySelectorAll("li"));
    }

    /**
     * Finds an item in the children collection based on the index
     * @param index
     * @returns {*}
     * @private
     */
    _getItem(index) {
       if (this._children != null && this._children.length > 0) {
           if (index < this._children.length) {
               return this._children[index];
           } 
       } 
       
       return null;
    }

    /**
     * Expands an item on the tree. If is a branch, 
     * the visible children is updated and the node is expanded
     * If it is a branch and it is expanded, the first child is focused on
     * @private
     */
    _expand() {
        const item = this._getItem(this._selectedIndex);
        
        if (item != null) {
            const isBranch = this._isBranchNode(item);
            const expanded = this._isExpanded(item);
            
            if (isBranch === true && expanded === false) {
                const button = item.querySelector("pragma-icon-button");
                button.click();
                this.updateChildren();
            } 
            else if (isBranch === true && expanded === true) {
                this._selectedIndex++;
                this._ensureBounds();
                this._focusItem();
            }
        } 
    }

    /**
     * Collapses a branch node on the tree
     * @private
     */
    _collapse() {
        const item = this._getItem(this._selectedIndex);
        
        if (item != null) {
            const isBranch = this._isBranchNode(item);
            const expanded = this._isExpanded(item);
            
            if (isBranch === true && expanded === true) {
                const button = item.querySelector("pragma-icon-button");
                button.click();

                this.updateChildren();
            }
            else {
                this._selectedIndex--;
                this._ensureBounds();
                this._focusItem();
            }
        }
    }
    
    _keyCombination(event) {
        const combo = this._platform.keycombo(event);

        if (combo && this._combinations.has(combo)) {
            const shortcut = this._combinations.get(combo);

            shortcut.apply(this, [event]);
        }
    }

    /**
     * Checks if an item is a branch node
     * @param item
     * @returns {*}
     * @private
     */
    _isBranchNode(item) {
        return item.classList.contains("branch-node");
    }

    /**
     * Checks if item is expanded
     * @param item
     * @returns {boolean}
     * @private
     */
    _isExpanded(item) {
        return item.getAttribute("aria-expanded") === "true";
    }
} 