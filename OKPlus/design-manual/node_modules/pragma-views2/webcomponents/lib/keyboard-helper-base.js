import { addEventsFeatures, removeEventsFeatures } from "../../baremetal/lib/mixin-events.js";
import { ScrollDirection } from "./scroll-direction.js";
import { AdvancedVisualizationBase } from "./advanced-visualization-base.js";

export class KeyboardHelperBase {
    /**
     * @param {AdvancedVisualizationBase} target 
     */
    constructor(target) {
        this._target = target;
        addEventsFeatures(this);
        this.registerEvent(this._target, "keydown", this.keyUp.bind(this));
    }

    /***
     * Cleanup
     */
    dispose() {
        removeEventsFeatures(this);
        delete this._target;
        delete this;
    }

    async ArrowDown() {
        this._target.focus.focusDown();
        await this._target.scrollAndFocus(ScrollDirection.Bottom, ScrollDirection.Left);
    }

    async ArrowUp() {
        this._target.focus.focusUp();
        await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Left);
    }

    /***
     * Navigate End, last child cell of a row. If the Ctrl key is pressed navigate to
     * the last row, last cell of the parent collapsible row.
     * @returns {Promise<void>}
     * @constructor
     */
    async End() {
        this._target.focus.index = this._target.navigation.itemCount;
        await this._target.scrollAndFocus(ScrollDirection.Bottom, ScrollDirection.Left);
    }

    async Enter() {
        const row = this._target.navigation.getRowByIndex(this._target.focus.index);
        this._target.dataStore.toggleSelection(row.__dataIndex, false);
    }

    /***
     * Navigate home, first row.
     * @returns {Promise<void>}
     * @constructor
     */
    async Home() {
        this._target.focus.index = 0;
        await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Left);
    }

    // noinspection JSUnusedGlobalSymbols
    async NumpadEnter() {
        const row = this._target.navigation.getRowByIndex(this._target.focus.index);
        this._target.dataStore.toggleSelection(row.__dataIndex, false);
    }

    // noinspection JSUnusedGlobalSymbols
    async PageDown() {
        await this._pageFn(ScrollDirection.Bottom, ScrollDirection.Left, 5);
    }

    // noinspection JSUnusedGlobalSymbols
    async PageUp() {
        await this._pageFn(ScrollDirection.Top, ScrollDirection.Left, -5);
    }

    // noinspection JSUnusedGlobalSymbols
    async Space() {
        const row = this._target.navigation.getRowByIndex(this._target.focus.index);
        this._target.dataStore.toggleSelection(row.__dataIndex, false);
    }

    /***
     * Pages by an increment provided.
     * @param {String} verticalScrollDirection
     * @param {String} horizontalScrollDirection
     * @param {number} increment
     * @returns {Promise<void>}
     * @private
     */
    async _pageFn(verticalScrollDirection, horizontalScrollDirection, increment) {
        const targetIndex = this._target.focus.index + increment;
        if (targetIndex >= 0 && targetIndex <= this._target.navigation.itemCount) {
            this._target.focus.index = this._target.focus.index + increment;
            await this._target.scrollAndFocus(verticalScrollDirection, horizontalScrollDirection);
        }
    }

    /***
     * Call relevant keycode function.
     * @param event keyboard event
     */
    keyUp(event) {
        if (event.code != null) {
            if (this[event.code] != null) {
                this[event.code](event);
            }
        }
    }

    scrolled() {
        this.focus.focus();
    }
}