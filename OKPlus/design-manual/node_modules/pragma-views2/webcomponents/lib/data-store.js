import {HierarchicalItem} from "../../lib/hierarchical-item.js";
import {cloneObject} from "./../../baremetal/lib/class-helper.js";
import {getValueOnPath} from "../../baremetal/lib/objectpath-helper.js";

export class DataStore {

    constructor(options) {
        this.data = [];
        this.datasource = null;
        this.nextGroupId = 0;
        this.options = options;
    }

    dispose() {
        this.data = null;
        this.options = null;
        this.datasource = null;
        this.options = null;
    }

    get datasource() {
        return this._datasource;
    }

    set datasource(newValue) {
        if (newValue == null) return;
        this._datasource = newValue;
    }

    get selectionMediator() {
        return this._selectionMediator;
    }

    set selectionMediator(newValue) {
        if (newValue == null) return;
        this._selectionMediator = newValue;
    }

    _addOrUpdateItemRecursively(newItemPath, items, parent, updateGroup) {
        for (const item of newItemPath) {
            if (item.hasChildren === true) {
                const dataGroup = this._addOrUpdateGroup(parent, item, items);
                this._addOrUpdateItemRecursively(item.items, dataGroup.items, dataGroup, updateGroup);
            } else {
                if (updateGroup === true) {
                    const oldItem = items.find(dataItem => this.getItemId(dataItem) === this.getItemId(item));
                    this._assignValues(item, oldItem)
                } else {
                    this._addToParent(parent, item);
                }
            }
        }
    }

    /**
     *
     * @param parent
     * @param item - New or modified item
     * @param children
     * @returns {*}
     * @private
     */
    _addOrUpdateGroup(parent, item, children) {
        let dataGroup = children.find(dataItem => dataItem.depth === item.depth && dataItem.model.id === item.model.id);
        if (dataGroup == null) {
            dataGroup = this._addToParent(parent, item);
            dataGroup.items = [];
        } else {
            this._assignValues(item, dataGroup);
        }
        return dataGroup;
    }


    _addToParent(parent, item) {
        const clonedItem = this._createClone(item);
        delete clonedItem.items;
        if (parent == null)
        {
            this.data.push(clonedItem);
            return clonedItem;
        }
        parent.items.push(clonedItem);
        if (parent.__isExpanded === true) {
            this.data.splice(this.data.indexOf(parent) + parent.items.length + 1, 0, clonedItem);
        }
        parent.__childCount += 1;
        return clonedItem;
    }

    _createClone(item) {
        return Object.assign(Object.create(Object.getPrototypeOf(item)), item);
    }

    _removeItemRecursively(oldItemPath, items, parent) {
        for (const item of oldItemPath) {
            if (item.hasChildren === true) {
                let dataGroup = items.find(dataItem => dataItem.depth === item.depth && dataItem.model.id === item.model.id);
                this._assignValues(item, dataGroup);
                const count = this._removeItemRecursively(item.items, dataGroup.items, dataGroup);
                if (count === 0) {
                    dataGroup.items.splice(parent.items.indexOf(dataGroup), 1);
                    if (dataGroup.__isExpanded === true) {
                        const index = this.data.indexOf(dataGroup);
                        this.data.splice(index, 1);
                    }
                }
                else {
                    dataGroup.__childCount = count;
                }

            } else {
                let subItem = items.find(dataItem => dataItem.depth === item.depth && dataItem.model.id === item.model.id);
                parent.items.splice(parent.items.indexOf(subItem), 1);
                if (parent.__isExpanded === true) {
                    this.data.splice(this.data.indexOf(subItem), 1);
                }

                return parent.items.length;
            }
        }
    }

    _assignValues(updatedGroup, group) {
        Object.assign(group.model, updatedGroup.model);
    }

    async addChildrenOf(parentItem, index) {
        await this.loadChildren(parentItem);
        this.selectionMediator.addToVisibleSelection(index, parentItem.items);
        this.data.splice(index + 1, 0, ...parentItem.items);

        parentItem.__childCount = parentItem.items.length;
        parentItem.__isExpanded = true;
    }

    async loadChildren(parentItem) {
        if(( parentItem.items || []).length === 0) {
            await this.datasource.load(null, parentItem)
        }
    }

    collapseAndCount(index) {
        const item = this.data[index];
        let count = item.__childCount || 0;

        if (count === 0) {
            return 0;
        }

        if (item.__isExpanded === true) {
            for (let i = 1; i <= count; i++) {
                const childIndex = index + i;
                count += this.collapseAndCount(childIndex);
            }

            item.__isExpanded = false;
            item.__childCount = 0;
        }

        return count;
    }

    deselectedAll() {
        this.datasource.selectedId = [];
    }

    findAllChildrenIdsRecursive(item, idsFound = []) {
        if (item.hasChildren === true) {
            for (const child of item.items) {
                this.findAllChildrenIdsRecursive(child, idsFound)
            }
        } else {
            idsFound.push(this.getItemId(item));
        }
        return idsFound;
    }

    getItemId(item) {
        return item instanceof HierarchicalItem ? item.model[this.datasource.idField] : item[this.datasource.idField];
    }

    getModel(item) {
        return item instanceof HierarchicalItem ? item.model : item;
    }

    initialize(data) {
        if (data == null) return;

        // If data is an array use it as it is else process the data
        if (Array.isArray(data) === false) {
            if (data.items != null) {
                data = data.items;
            }
        }


        this.data = data;
        this.setIdValues();
        this.selectionMediator.visibleSelectionChanged(this.data);
    }

    itemsAdded(addedItems, perspectives) {
        // When using flat data the data will already be added to the array in the datasource
        if (this.options.perspective != null) {
            for (const perspective of perspectives) {
                if (perspective.perspective.toString() === this.options.perspective) {
                    for (const item of perspective.items) {
                        if ((item.newItemPath || [])[0] != null) {
                            this._addOrUpdateItemRecursively(item.newItemPath, this.data);
                        }
                        else{
                            this.data.push(item.newItem);
                        }
                    }
                }
            }
        }
    }

    itemsDeleted(deletedItems, perspectives) {
        // When using flat data the data will already be removed from the array in the datasource
        if (this.options.perspective != null) {
            for (const perspective of perspectives) {
                if (perspective.perspective.toString() === this.options.perspective) {
                    for (const item of perspective.items) {
                        if ((item.oldItemPath || [])[0] != null) {
                            this._removeItemRecursively(item.oldItemPath, this.data);
                        }
                        else{
                            let index = this.data.findIndex(dataItem => this.getItemId(dataItem) === this.getItemId(item.oldItem));
                            this.data.splice(index, 1);
                        }
                    }
                }
            }
        }
    }

    itemsUpdated(updatedItems, updatedPerspectives) {
        // When using flat data the data will already be removed from the array in the datasource   

        if (this.options.perspective != null) {
            for (const perspective of updatedPerspectives) {
                if (perspective.perspective.toString() === this.options.perspective) {
                    for (const item of perspective.items) {
                        if ((item.newItemPath || [])[0] != null) {
                            this._addOrUpdateItemRecursively([item.newItemPath[0]], this.data, null, item.groupingChanged !== true);
                            if (item.groupingChanged === true) {
                                this._removeItemRecursively(item.oldItemPath[0], this.data);
                            }
                        }
                        else{
                            let model = this.data.find(dataItem => this.getItemId(dataItem) === this.getItemId(item.newItem));
                            Object.assign(model, item.newItem);
                        }
                    }
                }
            }
        }
    }

    removeChildrenOf(parentItem, index) {
        const startIndex = index + 1;
        const count = this.collapseAndCount(index);
        this.selectionMediator.removeFromVisibleSelection(index, parentItem.items);
        this.data.splice(startIndex, count);
        parentItem.__isExpanded = false;
        parentItem.__childCount = 0;
    }

    selectAll() {
        this.datasource.selectAll();
    }

    selectionChanged() {
       return this.selectionMediator.visibleSelectionChanged(this.data);
    }

    setIdValues() {
        if ((this.data[0] instanceof HierarchicalItem) === false) return;

        for (let d of this.data) {
            d.__id = `Group_${this.nextGroupId}`;
            this.nextGroupId += 1;
        }
    }

    async toggleExpand(index) {
        const item = this.data[index];

        if (item instanceof HierarchicalItem) {
            item.__isExpanded === true ? this.removeChildrenOf(item, index) : await this.addChildrenOf(item, index);
        }
    }

    toggleBusy(index) {
        const item = this.data[index];

        if (item instanceof HierarchicalItem) {
            item.__isBusy = !(item.__isBusy || false);
        }
    }


    toggleSelection(index, deselectOthers) {
        const item = this.data[index];
        this.selectionMediator.applySelection(item, !item.__isSelected, deselectOthers);
    }

    /**
     *
     * @param path - Array of objects which contain id and optionally the type
     * @param typeRef - If types are used use it to find unique item in level
     * @param expandLast - If true it will expand last item in path
     * @returns {Promise<void>}
     */
    async expandTo(path, typeRef, expandLast) {
        let result;
        for (let i = 0; i < path.length; i++) {
            const index = this.data.findIndex(x=> this._evaluatePathMatch(path[i], x, typeRef));
            const dataItem = this.data[index];

            if(dataItem == null) return;

            if((i+1) === path.length) {
                this.toggleSelection(index, true);
                result = {index: index, item: dataItem};
            }

            if(dataItem.__isExpanded !== true || ((i+1) === path.length) && expandLast === true) {
               await this.addChildrenOf(dataItem, index);
            }
        }
        return result;
    }

    _evaluatePathMatch(pathItem, item, typeRef) {
        let result = this.getItemId(item) === pathItem.id;
        if(result === true && typeRef != null) {
            result = getValueOnPath(this.getModel(item),typeRef) === pathItem.type;
        }
        return result;
    }

}