import {FlatListRenderer} from "./render-flatlist.js";
import {ElementStore} from "./../../baremetal/lib/virtualization/element-store.js";
import {createGroupTemplate} from "../pragma-advanced-grid/pragma-advanced-grid-utils.js";
import {createInflatorFunction} from "../../baremetal/lib/virtualization/inflation-utils.js";
import {HierarchicalItem} from "../../lib/hierarchical-item.js";

export class HierarchicalRenderer extends FlatListRenderer {
    constructor(container, scroller, dataStore, formatters, selection) {
        super(container, scroller, dataStore, formatters);
        this.startingLevel = 0;
        this.initializeGroupStore(selection);
        this.cleanItemHandler = this.cleanItem.bind(this);
    }
    
    dispose() {
        this.groupStore = null;
        this.groupInflate = null;
        this.cleanItemHandler = null;
        super.dispose();
    }
    
    initializeGroupStore(allowMultipleSelect) {
        const template = createGroupTemplate(allowMultipleSelect);
        this.groupStore = new ElementStore(template);
        this.groupInflate = createInflatorFunction(this.groupStore.store[0]);
    }

    setData(data) {
        this.dataStore.initialize(data);
        // Set the starting level to determine where indentation should start. The reason for this check is the group worker returns a level 0 root item.
        //this.startingLevel = data[0] != null? data[0].depth : 0;
        this.setScrollMarker();
    }
    
    getItemFromStore(item) {
        const isHierarchical = item instanceof HierarchicalItem;
        const isGroupNode = isHierarchical && item.hasChildren === true ;
        const element = isGroupNode === true ? this.groupStore.getItem() : this.store.getItem();
        element.__isHierarchical = isGroupNode;
        element.__id = item.__id;
       
        if (isGroupNode === true) {
            this.groupInflate.inflateFn(element, item);
            element.style.width = `${this.scroller.offsetWidth - 1}px`;
            element.style.paddingLeft = `${(item.depth)*2}rem`;
        }
        else {
            this.inflate.inflateFn(element, item);
        }
        
        return element;
    }

    cleanItem(element) {
        this.inflate.defaultFn(element);
        element.background = null;
    }

    returnItemToStore(element) {
        element.style.paddingLeft = "";
        element.__isHierarchical === true ? this.groupStore.returnItem(element, this.groupInflate.defaultFn) : this.store.returnItem(element, this.cleanItemHandler);
    }

    redrawItem(element, item) {
        const inflate = item.hasChildren === true? this.groupInflate : this.inflate;
        inflate.defaultFn(element,  item);
        inflate.inflateFn(element,  item);
    }
}