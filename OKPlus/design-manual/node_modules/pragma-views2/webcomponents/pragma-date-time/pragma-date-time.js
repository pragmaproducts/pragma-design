import {BaseElement} from "../../baremetal/lib/base-element.js";
import {padStart} from "../../lib/string-helpers.js";
import {ActionDialogManager} from "../../lib/action-dialog-manager.js";
import {dateToIsoStringDate} from "../../lib/date-helpers.js";

export class PragmaDateTime extends BaseElement {

    connectedCallback() {
        super.connectedCallback();
        this.initTemplate();

        // Controls
        this._inputDate.dateChangedCallback = (date) => this._updateDate(date);
        this._inputTime.timeChangedCallback = (time) => this._updateTime(time);

        // Attributes                
        this._inputTime.includeSeconds = this.hasAttribute("include-seconds");
        this.readonly = this.readonly;
        this.required = this.required;

        // Init variables
        this._dateChanging = false;
        this._timeChanging = false;

        //Apply Aria Tags
        this._ariaTags();

        //Register Events
        this.registerEvent(this._iconButton, "click", this._iconClick.bind(this));
    }

    disconnectedCallback() {
        super.disconnectedCallback();

        this._inputDate.dateChangedCallback = null;
        this._inputDate = null;
        this._inputTime.timeChangedCallback = null;
        this._inputTime = null;
        this._iconButton = null;
        this._calendar = null;
        this.datetime = null;
    }

    get readonly() {
        if (this._readonly == null) {
            this.readonly =  this.hasAttribute("readonly");
        }
        return this._readonly;
    }

    set readonly(value) {
        value = value === true;
        this._inputTime.readonly = value;
        this._inputDate.readonly = value;
        this._readonly = value;
        this._iconButton.disabled = value;
    }

    get required() {
        if (this._required == null) {
            this.required =  this.hasAttribute("required");
        }
        return this._required;
    }

    set required(value) {
        value = value === true;
        this._required = value;
        this._inputDate.required = value;
        this._inputTime.required = value;
    }

    get datetime() {
        return this._datetime || (this.hasAttribute("datetime") ? this.getAttribute("datetime") : null);
    }

    set datetime(isoDateTime) {
        const oldDateTime = this._datetime;
        let dateTime = null;
        if (isoDateTime != null) {
            this._dateChanging = true;
            this._timeChanging = true;

            const fullDate = new Date(isoDateTime);
            const date = this._extractDateString(fullDate);
            const time = this._extractTimeString(fullDate);
            this._inputDate.date = date;
            this._inputTime.time = time;
            dateTime = fullDate.toISOString();

            this._dateChanging = false;
            this._timeChanging = false;
        }

        this._datetime = dateTime;
        if (this._datetime !== oldDateTime) {
            this.notifyPropertyChanged("datetime", this._datetime, true);
        }
    }

    initTemplate() {
        const instance = document.importNode(window.templates.get("pragma-date-time-template"), true);
        this.appendChild(instance);
    }

    /**
     * Set aria tags for accessability.
     * @private
     */
    _ariaTags() {
        this._iconButton.setAttribute("aria-label", window.translations.dateTime.iconAria);
    }

    _updateDate(newDate) {
        if (this._dateChanging === false) {
            //Setting time to 00:00 if it is null to allow the date to be set independantly.
            const time = this._inputTime.time || "00:00";
            this.datetime = this._combineDateAndTime(newDate, time);
        }
    }

    /**
     * DateTime control icon clicked.
     * @private
     */
    _iconClick() {
        if (this._iconButton.disabled === true) return;

        const fragment = document.createDocumentFragment();
        this._calendar = document.createElement("pr-calendar");
        const selectDate = document.createElement("selected-date");
        const initialDate = dateToIsoStringDate(new Date(this.datetime || new Date()));
        selectDate.setAttribute("date", initialDate);
        this._calendar.appendChild(selectDate);
        fragment.appendChild(this._calendar);

        const buttons = [
            {
                id: "select",
                title: window.translations.dateTime.select,
                remote: false,
                callback: async (dialog) => {
                    if (selectDate != null && selectDate.date instanceof Date) {
                        this._updateDate(dateToIsoStringDate(selectDate.date));
                    }
                    dialog.dispose();
                }
            }
        ];

        const options = {
            contentElement: fragment,
            animatedCallback: this._dialogAnimated.bind(this),
            buttons: buttons,
            title: window.translations.dateTime.heading
        };

        new ActionDialogManager(options);
    }

    /**
     * Callback event that occurs after the modal dialog showing the calendar has loaded and
     * is finished rendering.
     * @private
     */
    _dialogAnimated() {
        if (this._calendar != null) {
            this._calendar.focusStart();
        }
    }

    _combineDateAndTime(date, time) {
        // We do the conversion to utc time here
        //  - YYYY-MM-DDTHH:mm:ss.sssZ
        let isoString = null;
        if ((date != null) && (time != null)) {
            const currentDateTime = new Date(`${date}T${time}`);
            isoString = currentDateTime.toISOString();
        }

        return isoString;
    }

    _extractDateString(fullDate) {
        let date = null;
        if (fullDate != null) {
            const day = padStart(fullDate.getDate()).toString();
            const month = padStart((fullDate.getMonth() + 1).toString());
            const year = fullDate.getFullYear();

            date = `${year}-${month}-${day}`;
        }

        return date;
    }

    _extractTimeString(fullDate) {
        let time = null;
        if (fullDate != null) {
            const hours = padStart(fullDate.getHours().toString());
            const minutes = padStart(fullDate.getMinutes().toString());
            const seconds = padStart(fullDate.getSeconds().toString());
            const milliSeconds = padStart(fullDate.getMilliseconds().toString(), 3);
            time = `${hours}:${minutes}:${seconds}.${milliSeconds}`;
        }

        return time;
    }

    _updateTime(newTime) {
        if (this._timeChanging === false) {
            this.datetime = this._combineDateAndTime(this._inputDate.date, newTime);
        }
    }
}

customElements.define('pragma-date-time', PragmaDateTime);