import {BaseElement} from "../../baremetal/lib/base-element.js";
import {HotSpotsApi} from "../../lib/hotSpot-api/hotSpot-api.js";
import {isMobile} from "../../lib/device-helper.js";
import {disableAnimationLayer, enableAnimationLayer} from "../../lib/animation-layer.js";

export class PragmaColumnMove extends BaseElement {
    /**
     * gets rects
     * @returns {!Promise<?JSHandle>|*|Promise|Promise<any>}
     */
    get rects() {
        return this.getProperty("rects", () => new Map());
    }

    /**
     * sets rects
     * @param newValue {Map} receives a map of rects.
     */
    set rects(newValue) {
        this.setProperty("rects", newValue);
    }

    /**
     * gets header
     * @returns {!Promise<?JSHandle>|*|Promise|Promise<any>}
     */
    get header() {
        return this.getProperty("header", () => this.parentElement.querySelector('[role="rowgroup"]:not([tabindex="-1"])'));
    }

    /**
     * sets header
     * @param newValue
     */
    set header(newValue) {
        this.setProperty("header", newValue);
    }

    /**
     * gets hotSpotApi
     * @returns {!Promise<?JSHandle>|*|Promise|Promise<any>}
     */
    get hotSpotApi() {
        return this.getProperty("hotSpotApi", () => new HotSpotsApi())
    }

    /**
     *  sets hotSpotApi
     * @param newValue
     */
    set hotSpotApi(newValue) {
        this.setProperty('hotSpotApi', newValue);
    }

    /**
     * connectedBallback sets class properties when the class is instantiated
     */
    connectedCallback() {
        super.connectedCallback();
        this.timer = 0;
        this.isMobile = isMobile();
        this.hasEnded = false;
        this.registerInputIntent(this.header, 'dragstart', this.handleMouseDown.bind(this))
    }

    disconnectedCallback() {
        this.rects = null;
        this.header = null;
        this.hotSpotApi = null;
        super.disconnectedCallback();
    }

    /**
     * handleMouseDown instantiates functions of column move
     * @param event {event} : is the mouse/touch event that is fired.
     */
    handleMouseDown(event) {
        this.parentElement.style.userSelect = "none";
        if (event.target.getAttribute("role") != "columnheader" ) return;
        this.hasEnded = false;
        this.animationLayer = enableAnimationLayer();
        this.addColumnClone(event);
        this.addCaret();
        this.hotSpotApi.addHotSpots(this.animationLayer);
        this.configureHotspots();
        const coordinates = this.clientCoordinates(event);
        const target = this.getTargetElement(coordinates.x, coordinates.y);

        if (target == null) return;

        this.focusTarget(target, coordinates.x);

        const element = this.isMobile ? this.parentElement : this.animationLayer;
        this.registerInputIntent(element, "drag", this.onMouseMove.bind(this));
        this.registerInputIntent(element, "dragend", this.onMouseUp.bind(this));
    }

    /**
     * onMouseMove handles the mouse move event
     * @param event {Event} : is the mouse/touch event that is fired.
     */
    onMouseMove(event) {
        this.hasEnded = false;
        const coordinates = this.clientCoordinates(event);
        const target = this.getTargetElement(coordinates.x, this.clone.rects.top + (this.clone.rects.height/2));
        if (target != null) this.focusTarget(target, coordinates.x);

        this.checkIfCaretIsMoving();

        requestAnimationFrame(() => {
            if (this.clone != null ) {
                this.clone.style.transform = `translate(${coordinates.x - (this.clone.rects.width / 2)}px, ${coordinates.y - (this.clone.rects.height/2)}px)`;
            }
        })
    }

    /**
     * onMouseUp handles the mouseup event
     * @param event {Event} is the mouse/touch event that is fired.
     */
    onMouseUp(event) {
        this.performColumnMove();

        const regElement = this.isMobile ? this.parentElement : this.animationLayer;
        for (const key of this.hotSpotApi.hotSpots.keys() ) {
            const element = this.animationLayer.querySelector(`.hotspot-${key}`);
            element.style.pointerEvents = 'none';
        }

        this.fromIndex = null;
        this.clone = null;
        this.caret = null;
        this.animationLayer = null;
        this.currentTarget = null;
        this.hasEnded = true;
        this.unRegisterIntention(regElement, "drag", this.onMouseMove.bind(this));
        this.unRegisterIntention(regElement, "dragend", this.onMouseMove.bind(this));

        disableAnimationLayer();
    }

    configureHotspots() {
        for (const key of  this.hotSpotApi.hotSpots.keys()) {
            const hotSpot =  this.hotSpotApi.hotSpots.get(key);
            hotSpot.element = this.animationLayer.querySelector(`.hotspot-${key}`);
            hotSpot.scrollhandler = this.performScroll.bind(this);
            this.hotSpotApi.hotSpotElements.push(hotSpot);
            if(this.isMobile === true) {
                this.hotSpotApi.hotSpotEvents(hotSpot.element.addEventListener, ["touchstart","touchmove", "touchend"], [hotSpot.scrollhandler, hotSpot.scrollhandler, hotSpot.scrollhandler]);
            }
            else {
                this.hotSpotApi.hotSpotEvents(hotSpot.element.addEventListener, ["mouseover","mouseout"], [hotSpot.scrollhandler, hotSpot.scrollhandler]);
            }
        }
    }

    /**
     * ddCaret function adds the navigation caret to the animation layer
     * @param rects
     */
    addCaret() {
        this.caret = document.createElement("span");
        const caretAnimation = document.createElement("span");
        const bounds = this.getRect(this.clone);
        caretAnimation.classList.add("caret-animation");
        this.caret.classList.add("caret");
        this.caret.style.transform = `translate(${bounds.left + bounds.width }px, ${bounds.top}px)`;
        this.caret.appendChild(caretAnimation);

        this.animationLayer.appendChild(this.caret)
    }

    /**
     * performs the scroll left or right
     * @param event
     */
    performScroll(event) {
        let direction;
        if (this.animationLayer == null) return;
        if (event.type === 'touchend') this.hasEnded = true ;
        if (this.isMobile === true) {
            const hotSpotLeft  = this.animationLayer.querySelector('.hotspot-left');
            const hotSpotright = this.animationLayer.querySelector('.hotspot-right');
            const coordiantes = this.clientCoordinates(event);

            if (coordiantes == null) return;

            if (coordiantes.x <= (hotSpotLeft.offsetLeft + hotSpotLeft.offsetWidth)) {
                direction = 'left';
            }
            else if (coordiantes.x > (hotSpotright.offsetLeft )) {
                direction = 'right';
            } else {
                this.hasEnded = true;
                direction = null;
            }
        } else  {
            direction = event.target.getAttribute("data-direction");
        }

        requestAnimationFrame(()=>{
            this.hotSpotApi.performElementScroll(event,this.parentElement, direction, this.hasEnded);
        });
    }
    
    /**
     * addColumnClone clones and append the clone to the animation layer.
     * @param event
     */
    addColumnClone(event) {
        const target =  event.target;
        this.fromIndex = Array.from(target.parentNode.childNodes).indexOf(target);
        this.colParent = target.parentNode;

        this.clone = target.cloneNode(true);
        this.clone.classList.add("column-clone");

        this.clone.rects = this.getRect(target);

        this.clone.style.setProperty('--height', target.height);
        this.clone.style.setProperty('--width', target.width);
        this.clone.style.transform = `translate(${this.clone.rects.left}px ,${this.clone.rects.top}px)`;
        this.animationLayer.appendChild(this.clone);
    }

    /**
     * performColumnMove method performs the column move
     * @param event
     */

    performColumnMove() {
        const toIndex = Array.from(this.colParent.childNodes).indexOf(this.currentTarget) + this.toIndexOffset;
        const fromIndex = this.parentElement.allowMultipleSelect === true ? this.fromIndex -1 : this.fromIndex;
        const schema = this.parentElement.datasource.schema || {};

        if (schema.sideEffects != null) {
            schema.sideEffects.perform({
                target: "grid",
                id: this.parentElement.id,
                intentions: [
                    {
                        action: "moveColumn",
                        parameters: [fromIndex, toIndex]
                    }
                ]
            });
        }
        else {
            this.parentElement.moveColumn(fromIndex, toIndex);
        }
    }

    /**
     * checkIfCaretIsMoving checks whether or not the navigation caret is moving and applies the correct animation.
     */
    checkIfCaretIsMoving() {
        if(this.caret == null ) return;
        if (this.timer !== 0 ) {
            clearTimeout(this.timer);
            this.caret.classList.remove("pause");
        }
        this.timer = setTimeout(() => {
            // todo ZM - why the is the caret missingg
            if (this.caret != null)  {
                this.caret.classList.add("pause");
            }
        }, 200);
    }

    /**
     * focusTarget focuses the element that is received.
     * @param element
     */
    focusTarget(element, x) {
        if (this.currentTarget !== element) {
            this.currentTarget = element;
        }
        
        const currentRect = this.getRect(element);
        const middle = currentRect.left + currentRect.width / 2;
        const right = currentRect.left + currentRect.width;
        
        // JHR: toIndexOffset is used to update the to index in performColumnMove so that if you move if left of the target it will be placed before the target.
        // ZM: this is beautiful thinking :)
        this.toIndexOffset = x > middle ? 0 : -1;
        
        const point = {
            x: x  > middle ? right - 4 : currentRect.left,
            y: currentRect.top
        };
        this.moveCaret(point);
    }

    /**
     * moveCaret moves the caret to point X and Y.
     * @param point
     */
    moveCaret(point) {
        const firstChild = this.parentElement.allowMultipleSelect === true ? Array.from(this.colParent.childNodes)[1] :  Array.from(this.colParent.childNodes)[0];
        const lastChild = this.colParent.lastChild;
        const min = firstChild.offsetLeft;
        const max = lastChild.offsetLeft + lastChild.offsetWidth + firstChild.offsetWidth;
        requestAnimationFrame(() => {
            if(this.caret != null ) {
                if (point.x >= min  && point.x < max) {
                    this.caret.style.transform = `translate(${point.x}px, ${point.y}px)`;
                }
            }
        });
    }

    /**
     *
     * @param event
     * @returns {{x: any, y: any}}
     */

    clientCoordinates(event) {
        if(event.type === "touchend") return ;
        const coordinates = {
            x: this.isMobile ? event.touches[0].clientX : event.clientX,
            y: this.isMobile ? event.touches[0].clientY : event.clientY
        };
        return coordinates;
    }

    /**
     * getTargetElement gets the target element
     * @param x
     * @param y
     * @returns {null|Element}
     */
    getTargetElement(x,y) {
        this.animationLayer.style.pointerEvents = "none";
        const target = document.elementFromPoint(x, y);
        this.animationLayer.style.pointerEvents = "all";
        this.animationLayer.focus();
        if(target == null) return;

        if (target.getAttribute("role") == "columnheader") {
            return target;
        }
        return null;
    }

    /**
     * getRect gets the rects of the element
     * @param target
     * @returns {ClientRect | DOMRect|*}
     */
    getRect(target) {
        const rect = target.getBoundingClientRect();
        this.rects.set(target, rect);
        return rect;
    }
}

customElements.define('pragma-column-move', PragmaColumnMove);