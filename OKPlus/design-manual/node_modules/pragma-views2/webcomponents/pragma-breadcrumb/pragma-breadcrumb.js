import {BaseElement} from "./../../baremetal/lib/base-element.js";
import {findParentLi} from "./../../lib/dom-helper.js";
import {createInflatorFunction} from "./../../baremetal/lib/virtualization/inflation-utils.js";


/**
 * Notes:
 * Overflow must still be done
 * Use offsets to determine overflow instead of getClientBoundingRect
 * Overflow must be implemented in a way that it can be reused in other components/views like the overflow toolbar button
 * Dropdown displaying overflowed content can be be the same dropdown component we use for drop down buttons. Keep that in mind when developing
 */

class PragmaBreadcrumb extends BaseElement {

    constructor() {
        super();
    }

    connectedCallback() {
        super.connectedCallback();
        this._initTemplate();
        this.registerEvent(this._ol, "click", this.click.bind(this));
    }

    disconnectedCallback() {
        super.disconnectedCallback();
        this._crumbTemplate = null;
        this._ol = null;
        this._inflate = null;
    }

    _initTemplate() {
        const instance = document.importNode(window.templates.get("pragma-breadcrumb"), true);
        this.appendChild(instance);
        this._crumbTemplate = this.querySelector("#crumb-template");
        this._inflate = createInflatorFunction(this._crumbTemplate.content);
        this._ol = this.querySelector("ol");
    }

    get mediator() {
        return this._mediator;
    }

    set mediator(newValue) {
        this._mediator = newValue;
        if (this._mediator != null) {
            this._mediator.itemAddedCallback = this.add.bind(this);
            this._mediator.itemUpdatedCallback = this.update.bind(this);
            this._mediator.clearCallback = this.clear.bind(this);
            this.render();
        }
    }
    
    get data() {
        return this.mediator.data();
    }

    render() {
        const fragment = document.createDocumentFragment();
        let itemCount = 0;
        if (this.data == null || this.data.length === 0) return; 
        for (const item of this.data) {
            itemCount +=1;
            const li = this._createListItem();
            this.renderItem(li, item.key, itemCount, item.parameters);
            fragment.appendChild(li);
        }
        this._ol.appendChild(fragment);
    }
    
    _createListItem() {
        const li = document.createElement("li");
        const clonedTemplate = document.importNode(this._crumbTemplate.content, true);
        li.appendChild(clonedTemplate);
        return li;
    }
    
    renderItem(li, key, order, parameters) {
        const inflateItem = {
            key: key,
            parameters: parameters
        };
        li.dataset.key = key;
        li.dataset.order = order;

       
        this._inflate.inflateFn(li, inflateItem);

        // TODO: Add attribute inflation
        const a = li.querySelector("a");
        a.setAttribute("href", inflateItem.key);

    }

    click(event) {
        if (event.target.nodeName === "OL") return;

        const li = findParentLi(event.target);

        if (Number(li.dataset.order) === this.data.length) return;

        // Check if the mediator has a perform function and perform if it has
        if (this.mediator.perform == null || this.mediator.perform(li.dataset.key)){
            // If mediator perform check passed remove all the items after the clicked item
            
            const siblings = this.querySelectorAll("[data-order]");
            for (const element of Array.from(siblings)) {
                if (Number(element.dataset.order) > li.dataset.order) {
                    this.mediator.remove(element.dataset.key);
                    element.parentNode.removeChild(element);
                }
            }    
        } 
    }
    
    update(key, oldKey, parameters) {
        const li = this.querySelector(`[data-key="${oldKey}"]`);
        if (li != null) {
            this._inflate.defaultFn(li);
            this.renderItem(li, key,li.dataset.order,  parameters);
        }
    }

    add(key, parameters) {
        if (this.mediator == null) return; 
        const li = this._createListItem();
        this.renderItem(li, key, this.data.length, parameters);
        this._ol.appendChild(li);
    }

    clear() {
        while(this._ol.firstChild)
        {
            this._ol.removeChild(this._ol.firstChild);
        }
    }
}


customElements.define('pragma-breadcrumb', PragmaBreadcrumb);