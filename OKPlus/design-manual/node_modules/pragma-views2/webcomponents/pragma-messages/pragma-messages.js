import {inflateTemplate} from './../../baremetal/lib/template-inflator.js'
import {BindableElement} from './../lib/bindable-element.js';
import {PragmaMessagesStates} from './../lib/pragma-messages-states.js';
import {findParentLi} from "./../../lib/dom-helper.js";
import {isMobile} from "./../../lib/device-helper.js";

class PragmaMessages extends BindableElement {

    constructor() {
        super();

        this._idCounter = 0;
        this._items = [];
        this.isOpen = false;
    }

    get isOpen() {
        return this.getAttribute("isOpen") == "true" || this._isOpen;
    }

    set isOpen(value) {
        this._isOpen = value;
        this.setAttribute("isOpen", value);
        if (value == "true" || value == true) {
            this.show();
        }
        else {
            this.hide();
        }
    }

    get state() {
        return this.getAttribute("state") || this._state;
    }

    set state(value) {
        this._state = value;
        this.setAttribute("state", value);
        window.eventEmitter.emit("pragma-messages-state-changed", {state: value})
    }

    _createItemElement(item, context, allowClose) {
        const cardInstance = document.importNode(window.templates.get("pragma-messages-item-template"), true);
        const li = cardInstance.querySelector("li");

        li.classList.add(item.severity);
        li.dataset.context = context;
        li.dataset.id = item.id;
        li.dataset.code = item.code;
        li.dataset.message = item.message;

        if (item.code == "" || item.code == undefined) {
            const codeSection = li.querySelector(".message-code");
            li.removeChild(codeSection);
        }
        else {
            const toggleButton = li.querySelector(".btnMoreInfo");
            toggleButton.innerHTML = window.translations.pragmaMessages.buttons.moreInfo;

            if (item.severity !== "information") {
                const errorCodeHeading = li.querySelector(".message-code-body-title");
                errorCodeHeading.innerHTML = window.translations.pragmaMessages.headings.errorCode;
            }
        }

        if (allowClose !== true) {
            const closeButton = li.querySelector(".btnCloseCard");
            closeButton.style.display = "none";
        }

        return inflateTemplate(cardInstance, item);
    }

    _createSection(name) {
        const sectionInstance = document.importNode(window.templates.get("pragma-messages-section-template"), true);
        const section = inflateTemplate(sectionInstance, {name: window.translations.pragmaMessages.headings[name]});
        const li = section.querySelector("li");
        li.dataset.section = name;
        return section;
    }

    _findSection(name) {
        return this._ul.querySelector(`li[data-section="${name}"]`);
    }

    /**
     * Get data from event object target
     * @param e: Event object
     * @returns {number|DOMStringMap}
     * @private
     */
    _getData(e) {
        const liElement = findParentLi(e.target);
        if (liElement != null) {
            return liElement.dataset;
        }
    }

    _getNewId() {
        this._idCounter += 1;
        return this._idCounter;
    }

    // Public methods

    _initTemplate() {
        const instance = document.importNode(window.templates.get("pragma-messages-template"), true);
        this.appendChild(instance);
    }

    _removeElementsForContext(context) {
        const elements = document.querySelectorAll(`[data-context="${context}"]`);
        elements.forEach(node => node.parentNode.removeChild(node))
    }

    _removeEmptySections() {
        const emptyListsInSections = this._ul.querySelectorAll("ul");
        emptyListsInSections.forEach(list => {
            if (list.childElementCount == 0) {
                this._ul.removeChild(list.parentNode)
            }
        });
        if (this._ul.childElementCount == 0) {
            this.isOpen = false;
        }
    }

    _removeItemsForContext(context) {
        const contextItems = this._items.filter(item => item.context == context);
        contextItems.forEach((item) => {
            this._items.splice(this._items.findIndex(x => x.id = item.id), 1);
        });
    }

    // Events

    _setFocus(element) {
        element.tabIndex = 0;
        element.focus();
    }

    _toggleCodeExpanded(element) {
        // Toggle code content if code is set
        if (element.parentNode.children[0].getAttribute("aria-expanded") == "true") {
            element.innerText = window.translations.pragmaMessages.buttons.moreInfo;
            element.parentNode.children[0].setAttribute("aria-expanded", false);
        }
        else {
            element.innerText = window.translations.pragmaMessages.buttons.lessInfo;
            element.parentNode.children[0].setAttribute("aria-expanded", true);
        }
    }

    btnCloseClick() {
        this.isOpen = false;
    }

    connectedCallback() {
        this._initTemplate();
        super.connectedCallback();

        this.setAttribute("role", "complementary");
        this.setAttribute("aria-live", "assertive ");
        this.setAttribute("aria-labelledby", "messages-title");
        
        this._ul = this.querySelector("ul");

        window.pragmaMessages = {
            addMessages: this.createItems.bind(this),
            clearContext: this.removeItemsForContext.bind(this)
        }
    }

    /**
     * Finds relevant message item and emits event to copy value to the clipboard
     * @param id: message item id
     * @param context: message item context
     */
    copyMessageToClipboard(id, context) {
        const message = this._items.find(item => item.id == id && item.context == context);
        if (message != null) {
            window.eventEmitter.emit("copy-to-clipboard", {
                value: message
            });
        }
    }

    createItems(context, messages, section, allowClose) {
        //TODO simplify
        // Get only new items
        const newItems = messages.filter(message => !(this._items.some(_ => {
            return (_.message == message.message && _.code == message.code);
        })));

        let newSection = false;
        let sectionElement = this._findSection(section);
        if (sectionElement == undefined) {
            sectionElement = this._createSection(section);
            newSection = true;
        }
        const ul = sectionElement.querySelector("ul");
        const fragment = document.createDocumentFragment();
        newItems.forEach(item => {
            item.id = this._getNewId();
            item.context = context;
            fragment.appendChild(this._createItemElement(item, context, allowClose));
        });

        ul.appendChild(fragment);
        if (newSection == true) {
            this._ul.appendChild(sectionElement);
        }
        this._items.push(...newItems);
        this.isOpen = true;
    }

    disconnectedCallback() {
        this._ul = null;

        this._idCounter = null;
        this._items = null;

        window.pragmaMessages = null;
    }

    focus() {
        if (this.state != PragmaMessagesStates.empty) {
            this.show();
        }
        this.focusElement = this.querySelector(".message");
        this._setFocus(this.focusElement);
    }

    async handleCardClick(e) {
        // Remove card if click on close
        if (e.target.classList.contains("btnCloseCard")) {
            const data = this._getData(e);
            this.removeItem(data.id, data.context);
            window.eventEmitter.emit("close-notification-items");
        }

        if (e.target.classList.contains("btnMoreInfo")) {
            this._handleMoreInfo(e.target);
        }

        if (e.target.classList.contains("btnCopyMessage")) {
            const data = this._getData(e);
            this.copyMessageToClipboard(data.id, data.context);
        }
    }
    
    _handleMoreInfo(element) {
        const listItem = findParentLi(element);
        const notificationItem = this._items.find(item => item.id == listItem.dataset.id);
        if (notificationItem != null && notificationItem.hasOwnProperty("details")) {
            window.eventEmitter.emit("load-notification-items", {
                items: notificationItem.details,
                detailContext: notificationItem.detailContext
            });
        }
        if (isMobile() === true) {
            this.hide();
        } 
        else {
            this._toggleCodeExpanded(element);
        }
    }

    hide() {
        if (this._items.length > 0) {
            this.state = PragmaMessagesStates.hidden;
        }
        else {
            this.state = PragmaMessagesStates.empty;
        }
        this.setAttribute("aria-hidden", "true");
    }

    onKeyDown(e) {
        if (e.keyCode == 38 || e.keyCode == 40) {

            const messages = [...this._ul.querySelectorAll(".message")];
            const currentItemIndex = messages.indexOf(e.target);

            const nextItemIndex = (e.keyCode == 38 ? currentItemIndex - 1 : currentItemIndex + 1);

            if (messages[nextItemIndex] != undefined) {
                e.target.tabIndex = -1;
                this._setFocus(messages[nextItemIndex]);
            }
        }
    }

    onKeyUp(e) {
        if (e.keyCode == 32 || e.keyCode == 13) {
            if (e.target.id == "btnCloseMessages") {
                this.hide();
            }
        }
    }

    onMessage(params) {
        if (this[params.message] != undefined) {
            this[params.message]();
        }
    }

    removeItem(id, context) {
        const node = document.querySelector(`[data-id="${id}"][data-context="${context}"]`);
        // Slide off the screen
        if (node != undefined) {
            const itemIndex = this._items.findIndex(item => item.id == id);
            this._items.splice(itemIndex, 1);

            node.classList.add("close");
            const onAnimationComplete = (e) => {
                e.target.parentNode.removeChild(e.target);
                this._removeEmptySections();
            }
            node.addEventListener('transitionend', onAnimationComplete, {once: true});
        }
    }

    async removeItemsForContext(context) {
        await Promise.all([this._removeElementsForContext(context), this._removeItemsForContext(context)]);
        // Remove empty sections
        this._removeEmptySections();
    }

    show() {
        if (this._items.length > 0) {
            this.state = PragmaMessagesStates.visible;
            this.setAttribute("aria-hidden", false);
        }
    }

    toggle() {
        this.isOpen = !this.isOpen;
    }
}


customElements.define('pragma-messages', PragmaMessages);