import { ElementStore } from "./../../baremetal/lib/virtualization/element-store.js";
import { createRowTemplate, createHeaderCheckboxColumn } from "./pragma-advanced-grid-utils.js";
import { GridFlatListRenderer } from "./grid-render-flatlist.js";
import { GridHierarchicalRenderer } from "./grid-render-hierarchical.js";
import { DataStore } from "./../lib/data-store.js";
import { AdvancedVisualizationBase } from "./../lib/advanced-visualization-base.js";
import { DataSourceStateConstants } from "./../../lib/datasource-constants.js";
import { SelectionMediator } from "./../lib/selection-mediator.js";
import { createElement, findParentOfType, findParentWithClass } from "./../../lib/dom-helper.js";
import { ComponentUiStates } from "./../../lib/component-ui-states.js";
import { KeyboardHelper } from "./keyboard-helper.js";
import { Scroll } from "./scroll.js";
import { Focus } from "./focus.js";
import { Navigation } from "./navigation.js";
import { addGroups, resizeGroups } from "./../lib/column-group-helper.js";

class PragmaAdvancedGrid extends AdvancedVisualizationBase {
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute("tabindex", 0);

        this.columns = Array.from(this.querySelectorAll("pragma-grid-column"));
        let index = -1;
        for (let column of this.columns) {
            index++;
            column.index = index;
        }

        this.formatters = Array.from(this.querySelectorAll(":scope > pragma-conditional-formatter")).concat(this.columns);

        const dataStoreOptions = {
            selectionChangedCallback: this.selectionChanged.bind(this),
            itemsAddedCallback: this.itemsAdded.bind(this),
            itemsUpdatedCallback: this.itemsUpdated.bind(this),
            itemsDeletedCallback: this.itemsDeleted.bind(this),
            perspective: this.perspective
        };
        this.dataStore = new DataStore(dataStoreOptions);
        this.dataStore.datasource = this.datasource;
        this.initTemplate();

        this.registerInputIntent(this, "dblclick", this.dblClick.bind(this));
        this.allowMultipleSelect = this.getAttribute("selection") !== "single";
        this.selectionReference = this.getAttribute("selectionRef");
        this.features = [];
        this.keyboardHelper;
    }

    disconnectedCallback() {
        this.body = null;
        this.wrapper = null;
        this.scroller = null;
        this.runwayMaker = null;
        this.formatters = null;
        this.columns = null;
        this.allowMultipleSelect = null;
        this.selectionReference = null;
        this.keyboardHelper = null;
        this.scroll = null;
        this.focus = null;
        this.navigation = null;
        super.disconnectedCallback();
    }

    get datasource() {
        return this.getProperty("datasource", () => {
            return super.datasource;
        })
    }

    set datasource(newValue) {
        this.performDatasourceValidation(newValue, () => {
            const targetRenderer = this._isGrouped() ? GridHierarchicalRenderer : GridFlatListRenderer;
            this.renderer = new targetRenderer(this.container, this.scroller, this.dataStore, this.formatters, this.allowMultipleSelect);
            this.dataStore.selectionMediator = new SelectionMediator(this.datasource, this.selectionReference, this.allowMultipleSelect);
            this.renderer.scrollCompletedCallback = this.keyboardHelper.scrolled.bind(this);
        });
    }

    get perspective() {
        return this._perspective || this.getAttribute("perspective");
    }

    set perspective(newValue) {
        this._perspective = newValue;
    }

    get selection() {
        return this._selection || this.getAttribute("selection");
    }

    set selection(newValue) {
        this._selection = newValue;
    }

    /**
     * @returns {KeyboardHelper}
     */
    get keyboardHelper() {
        return this.getProperty("keyboardHelper", () => {
            return new KeyboardHelper(this);
        });
    }

    set keyboardHelper(value) {
        this.setProperty("keyboardHelper", value);
    }

    /**
     * @returns {Scroll}
     */
    get scroll() {
        return this.getProperty("scroll", () => {
            return new Scroll(this);
        });
    }

    set scroll(value) {
        this.setProperty("scroll", value);
    }

    /**
     * @returns {Focus}
     */
    get focus() {
        return this.getProperty("focus", () => {
            return new Focus(this);
        });
    }

    set focus(value) {
        this.setProperty("focus", value);
    }

    /**
     * @returns {Navigation}
     */
    get navigation() {
        return this.getProperty("navigation", () => {
            return new Navigation(this);
        });
    }

    set navigation(value) {
        this.setProperty("navigation", value);
    }

    getItemDimensions() {
        return this.renderer.dimensions;
    }

    _isGrouped() {
        return this.datasource.definition.hierarchical === true || this.datasource.isGrouped(this.perspective);
    }

    /**
     * Add columns to both grids.
     * @param columns
     */
    addColumns(columns) {
        const fragment = document.createElement("div");

        if (this.allowMultipleSelect === true) {
            const checkboxHeaderColumn = createHeaderCheckboxColumn("columnheader", window.translations.selection.selectAll);
            fragment.appendChild(checkboxHeaderColumn);
        }

        for (let column of columns) {
            if (column.isVisible === true) {
                const headerElement = column.createHeaderElement();
                fragment.appendChild(headerElement);
            }
        }

        this.header.appendChild(fragment);
    }

    appendColumn(fieldName, title) {
        const newColumn = createElement("pragma-grid-column", null, [{ name: "field", value: fieldName }, {
            name: "title",
            value: title
        }, { name: "data-width", value: "100" }]);
        const lastColumn = this.columns[this.columns.length - 1].nextSibling;

        this.insertBefore(newColumn, lastColumn);
        this.flush();
    }

    calculateRunway(numberOfItems) {
        if (this.renderer.dimensions == null) return;

        const top = numberOfItems * this.renderer.dimensions.height;
        this.scrollMarker.style.transform = `translate(${this.renderer.dimensions.width}px, ${top}px)`;
    }

    clear() {
        if (this.header != null && (this.renderer || {}).container != null) {
            this.header.innerHTML = "";
            this.renderer.container.innerHTML = "";
        }
    }

    async click(event) {
        const elements = super.click(event);
        const selectedAllCheckbox = findParentOfType(elements[0], "pragma-checkbox", this.nodeName.toLowerCase());
        if (selectedAllCheckbox != null) {
            return this.toggleSelectAll(selectedAllCheckbox.checked);
        }

        const row = findParentWithClass(elements[0], "grid-row", this.nodeName.toLowerCase());
        if (row == null) return;

        const arrowClicked = elements[0].hasAttribute("aria-expanded");
        if (arrowClicked === true) {
            return await this.toggleExpand(row);
        }

        const checkboxClicked = elements[0].getAttribute("role") === "checkbox";
        const isGroup = row.getAttribute("role") === "rowgroup";
        if (isGroup !== true || checkboxClicked) {
            this.dataStore.toggleSelection(row.__dataIndex, !checkboxClicked);
            this.updateSelectAllCheckbox();
        }
        this.focus.focus(row);
    }

    columnVisibilityChanged() {
        this.render();
    }

    async dblClick(event) {
        const elements = document.elementsFromPoint(event.pageX, event.pageY);

        if (elements.find(item => item.id === "header") != null) return;

        const rowgroups = elements.filter(item => item.getAttribute("role") === "rowgroup");

        if (rowgroups.length > 0) {
            const target = rowgroups[0];
            const index = target.__dataIndex;
            await this.dataStore.toggleExpand(index);
            this.renderer.redrawCurrentPage();
            this.renderer.setScrollMarker();
            this.focus.focus();
        }
        const rows = elements.filter(item => item.getAttribute("role") === "row")

        if (rows.length > 0) {
            this.dispatchCustomEvent("doubleclick", event);
        }
    }

    flush() {
        // 1. Get formatters
        this.columns = Array.from(this.querySelectorAll("pragma-grid-column"));
        let index = -1;
        for (let column of this.columns) {
            index++;
            column.index = index;
            column.code = null;
        }

        this.formatters = Array.from(this.querySelectorAll(":scope > pragma-conditional-formatter")).concat(this.columns);

        // 2. Set up renderers
        const targetRenderer = this.datasource.definition.hierarchical === true || this.datasource.isGrouped(this.perspective) ? GridHierarchicalRenderer : GridFlatListRenderer;
        this.renderer = new targetRenderer(this.container, this.scroller, this.dataStore, this.formatters, this.allowMultipleSelect);

        // 3. Render
        this.render();
    }

    getColumnWidth(fieldName) {
        const column = this.columns.find(item => item.field === fieldName);
        return column != null ? column.dataset.width : 200;
    }

    initTemplate() {
        const instance = document.importNode(window.templates.get("pragma-advanced-grid"), true);
        this.wrapper = instance.querySelector("[role='table']");
        this.scroller = instance.querySelector(".scroll-container");
        this.scrollMarker = instance.querySelector(".scroll-marker");
        this.registerEvent(this.scroller, "scroll", this.scrolled.bind(this));
        this.container = instance.querySelector(".items-container");
        this.appendChild(instance);
    }

    async measureItem() {
        return new Promise((resolve) => {
            const measureFn = () => {
                const item = this.renderer.store.getItem();
                item.classList.add("offscreen");
                this.renderer.container.appendChild(item);
                const rect = item.getBoundingClientRect();
                this.renderer.container.removeChild(item);
                item.classList.remove("offscreen");

                this.renderer.dimensions = {
                    width: rect.width,
                    height: rect.height
                };

                resolve();
            };

            // Adding a threshold of 10px to accommodate styles variations on startup.
            if (this.scroller.offsetHeight < 10) {
                const interval = setInterval(() => {
                    if (this.scroller == null) {
                        return clearInterval(interval);
                    }
                    if (this.scroller.offsetHeight > 0) {
                        clearInterval(interval);
                        measureFn();
                    }

                }, 100)
            } else {
                measureFn();
            }
        })
    }

    moveColumn(fromIndex, toIndex) {
        const column = this.columns[fromIndex];
        const target = this.columns[toIndex];

        if (column == target) return;
        this.removeChild(column);
        this.insertBefore(column, target);
        this.flush();
    }

    overrideColumns(fields, titles) {
        const newColumns = [];

        // 1. Build up column order using old columns if they exist or creating new ones if it does not
        for (let i = 0; i < fields.length; i++) {
            const fieldName = this._isGrouped() ? `model.${fields[i]}` : fields[i];
            const title = titles[i];
            let column = this.columns.find(item => item.field === fieldName);
            if (column == null) {
                column = createElement("pragma-grid-column", null, [{ name: "field", value: fieldName }, {
                    name: "title",
                    value: title
                }, { name: "data-width", value: "200" }]);
            }

            newColumns.push(column);
        }

        // 2. Remove all the old columns
        for (let c of this.columns) {
            this.removeChild(c);
        }

        // 3. Add the new columns in the order defined
        for (let c of newColumns) {
            this.appendChild(c);
        }

        // 4. Redraw
        this.flush();
    }

    removeColumn(fieldName) {
        const column = this.querySelector(`[field='${fieldName}']`);
        if (column != null) {
            this.removeChild(column);
        }
        this.flush();
    }

    async render() {
        if (this.uiState === ComponentUiStates.suspended || this.isRendering === true) return;

        this.isRendering = true;

        this.header = this.querySelector("#header");

        if (this.header == null) return;
        this.clear();

        addGroups(this);
        this.addColumns(this.columns);
        resizeGroups(this);

        const rowTemplate = createRowTemplate(this.container, this.columns, this.allowMultipleSelect);
        this.renderer.store = new ElementStore(rowTemplate);

        await this.measureItem();

        if (this.datasource != null && this.datasource.state === DataSourceStateConstants.none) {
            this.datasource.data({ perspective: this.perspective }).then(async (items) => {
                this.calculateRunway(items.length);

                if (this.scroller.scrollTop == 0) {
                    await this.renderer.renderInitial(items);
                } else {
                    this.renderer.scrollItems(this.scroller.scrollTop, this.scroller.scrollLeft);
                }
            });
        }
        this.isRendering = false;

        this.dispatchEvent(new CustomEvent("ready"));
    }

    async scrolled() {
        this.header.style.transform = `translateX(${-this.scroller.scrollLeft}px)`;
        await this.renderer.scrollItems(this.scroller.scrollTop, this.scroller.scrollLeft);
    }

    selectionChanged() {
        const changedMap = this.dataStore.selectionChanged();
        this.selectedId = this.datasource.selectedId;
        const rows = Array.from(this.querySelectorAll(".items-container > div"));

        for (const keyValue of Object.entries(changedMap)) {
            const row = rows.find(r => r.__dataIndex === Number(keyValue[0]));
            if (row != null) {
                this.renderer.redrawItem(row, keyValue[1]);
            }
        }
    }

    setColumnWidth(fieldName, width) {
        let column = this.columns.find(item => item.field == fieldName);
        column.dataset.width = width;

        this.flush();
    }

    async toggleExpand(target) {
        const index = target.__dataIndex;
        const item = this.dataStore.data[index];
        if (item.isBusy === true) return;
        this.dataStore.toggleBusy(index);
        this.renderer.redrawItem(target, item);
        await this.dataStore.toggleExpand(index);
        this.dataStore.toggleBusy(index);
        this.renderer.redrawCurrentPage();
        this.renderer.setScrollMarker();
        this.focus.index = index;
        this.focus.focus();
    }

    toggleSelectAll(value) {
        if (value !== false) {
            this.dataStore.selectAll();
            this.allSelected = true;
        } else {
            this.dataStore.deselectedAll();
        }
        this.renderer.redrawCurrentPage();
    }

    updateSelectAllCheckbox() {
        const fn = (value) => {
            this.allSelected = value;
            const checkbox = this.querySelector(`[aria-label="${window.translations.selection.selectAll}"]`);
            checkbox.checked = value;
        };
        if (this.allSelected !== true && this.datasource.isAllSelected()) {
            fn(true);
        } else if (this.allSelected === true && this.datasource.isAllSelected() === false) {
            fn(false);
        }
    }

    /**
    * Scrolls to the row index and cell index, scrolling into view if necessary.
    * @param {String} verticalScrollDirection
    * @param {String} horizontalScrollDirection
    * @returns {Promise<void>}
    */
    async scrollAndFocus(verticalScrollDirection, horizontalScrollDirection, index, rowIndex) {
        this.focus.index = index == null ? this.focus.index : index;
        this.focus.rowIndex = rowIndex == null ? this.focus.rowIndex : rowIndex;
        await this.scroll.scroll(verticalScrollDirection, horizontalScrollDirection, this.focus.index, this.focus.rowIndex);
        this.focus.focus();
    }
}

customElements.define("pragma-advanced-grid", PragmaAdvancedGrid);
