import {KeyboardHelperBase} from "../lib/keyboard-helper-base.js";
import {ScrollDirection} from "../lib/scroll-direction.js";

export class KeyboardHelper extends KeyboardHelperBase {

    async ArrowDown() {
        this._target.focus.focusDown();
        if (this._target.navigation.isExpandable(this._target.focus.index) === true)
            this._target.focus.rowIndex = 0;
        await this._target.scrollAndFocus(ScrollDirection.Bottom, ScrollDirection.Left);
    }

    async ArrowLeft() {
        const collapsed = await this._target.navigation.collapse(this._target.focus.index);
        if (collapsed === true) {
            this._target.focus.focus();
        } else {
            if (this._target.navigation.isExpandable(this._target.focus.index) === true) {
                const parentIndex = this._target.navigation.getParentIndex(this._target.focus.index);
                if (parentIndex !== -1) {
                    this._target.focus.index = parentIndex;
                    await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Left);
                }
            } else {
                if (this._target.navigation.isExpandable(this._target.focus.index) === false) {
                    this._target.focus.focusLeft();
                    await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Left);
                }
            }
        }
    }

    async ArrowRight() {
        const expanded = await this._target.navigation.expand(this._target.focus.index);
        if (expanded === true) {
            await this.ArrowDown();
        } else {
            if (this._target.navigation.isExpandable(this._target.focus.index) === false) {
                this._target.focus.focusRight();
            }
            await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Right);
        }
    }

    async ArrowUp() {
        this._target.focus.focusUp();
        if (this._target.navigation.isExpandable(this._target.focus.index) === true)
            this._target.focus.rowIndex = 0;
        await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Left);
    }

    /***
     * Navigate End, last child cell of a row. If the Ctrl key is pressed navigate to
     * the last row, last cell of the parent collapsible row.
     * @param event
     * @returns {Promise<void>}
     * @constructor
     */
    async End(event) {
        if (event.ctrlKey === true) {
            if (this._target.navigation.isExpandable(this._target.focus.index) === false) {
                const parentIndex = this._target.navigation.getParentIndex(this._target.focus.index);
                if (parentIndex !== -1) {
                    const dataItem = this._target.navigation.getDataStoreItemByIndex(parentIndex);
                    const childCount = dataItem.items.length;
                    this._target.focus.index = parentIndex + childCount;
                    this._target.focus.rowIndex = this._target.navigation.rowChildCount;
                    await this._target.scrollAndFocus(ScrollDirection.Bottom, ScrollDirection.Right);
                }
            }
        } else {
            if (this._target.navigation.isExpandable(this._target.focus.index) === false) {
                this._target.focus.rowIndex = this._target.navigation.rowChildCount;
                await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Right);
            } else {
                this._target.focus.index = this._target.navigation.itemCount;
                await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Left);
            }
        }
    }

    /***
     * Navigate home, first child cell of a row. If the Ctrl key is pressed navigate to
     * the first row, first cell of the parent collapsible row.
     * @param event
     * @returns {Promise<void>}
     * @constructor
     */
    async Home(event) {
        if (event.ctrlKey === true) {
            if (this._target.navigation.isExpandable(this._target.focus.index) === false) {
                const parentIndex = this._target.navigation.getParentIndex(this._target.focus.index);
                if (parentIndex !== -1) {
                    this._target.focus.index = parentIndex + 1;
                    this._target.focus.rowIndex = 0;
                    await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Left);
                }
            }
        } else {
            if (this._target.navigation.isExpandable(this._target.focus.index) === false) {
                this._target.focus.rowIndex = 0;
                await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Left);
            }else {
                this._target.focus.index = 0;
                await this._target.scrollAndFocus(ScrollDirection.Top, ScrollDirection.Left);
            }
        }
    }
}