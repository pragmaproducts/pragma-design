import {ViewBase} from "../../../baremetal/lib/view-base.js";
import {template as mainSchema} from "./schema.js";
import {template as siteSchema} from "./siteSchema.js";
import {template as assistSchema} from "./assistant.js";
import {cloneObject} from "../../../baremetal/lib/class-helper.js";
import {DatasetFactory} from "./../../../lib/dataset-factory.js";
import {dataItems} from "./data-items.js";
import {getDetailsFor} from "./data-details.js";
import {getModelsFor} from "./data-models.js";
import {sites} from "./data-sites.js";
import {performTriggersFor, removeObserverFromCache} from "../../../baremetal/lib/binding/observers.js";
import {createDataSetFromDatasource} from "./../../../lib/data-utils.js";

export default class Complete extends ViewBase {

    get model () {
        return this._model;
    }

    set model(newValue) {
        if(newValue == null) return;
        this._model = newValue;
        this.mainSchema.variables.dataModel = this.model;
    }

    connectedCallback() {
        this.title = "Complete";
        this.context = this;
        this.mainSchema = cloneObject(mainSchema);
        this.mainSchema.remoteUpdate = this.remoteUpdate.bind(this);
        
        this.assistSchema = cloneObject(assistSchema);

        this.init();
        
        this.remoteName = "Complete";
        
        this.fetchSchemaHandler = this.fetchSchema.bind(this);
        window.eventEmitter.on("fetch-schema", this.fetchSchemaHandler);
    }
    
    disconnectedCallback() {
        this.mainSchema.remoteUpdate = null;
        
        window.eventEmitter.remove(`${this.remoteName}-model-load`, this.fetchRecordHandler);
        this.fetchRecordHandler = null;

        window.eventEmitter.remove("fetch-schema", this.fetchSchemaHandler);
        this.fetchSchemaHandler = null;
        
        if (this.editDataset != null) {
            this.editDataset.dispose();
            this.editDataset = null;
        }
    }

    init() {
        this.getRemoteData = this.remoteDsCallback.bind(this);

        window.eventEmitter.emit("assistant", {
            viewModel: this,
            schema: this.assistSchema
        });
    }

    async remoteDsCallback(def, payload, parent, inflatedParameters, queryOptions, fetchCount) {
        switch(def.remote) {
            case "list-items": return dataItems;
            case "details": {
                if (queryOptions == null) {
                    return await getDetailsFor(this.model.data, fetchCount);
                }
                else {
                    return [this.updatedModel];
                    delete this.updatedModel;
                }                
            }
            case "models": {
                const result = getModelsFor(this.model.data.make);
                return result;
            }
            case "sites":
                return sites;
        }
    }

    debug() {
        this.mainSchema.variables.ui.isMasterVisible = !this.mainSchema.variables.ui.isMasterVisible;
    }

    schemaLoaded(event) {

        const options = {
            schema: this.mainSchema,
            remoteDsCallback: this.getRemoteData,
            remoteCallback: this.datasetRemoteCallback.bind(this),
            draft: event.detail.draft
        };

        const form = document.querySelector("#main-view pragma-form .form-container");
        this.dsFactory = new DatasetFactory(options);
        this.model = this.dsFactory.createDataSet(0, {}, this.model, this.remoteName,null);


        // Note: If model changes update the assist using the context (this)
        // See assist component for more details
        window.eventEmitter.emit("assistant", {
            viewModel: this
        });

        performTriggersFor(this.model);
        this.dsFactory.finalize();
    }

    performTriggers() {
        performTriggersFor(this.model);
    }

    log() {
        console.log(this.model);
    }

    fetchSchema(args){
        args.callback(siteSchema);
    }

    datasetRemoteCallback(event) {
        const item = dataItems.find((item) => item.id === event.parameters.id[0]);
        event.successCallback(item);
    }
    
    performAction(args) {
        if (args.action == "select-first") {
            this.model.selectedId = 1;
        }
    }
    
    save() {
        window.eventEmitter.emit(`activity_1`, "busy");
        
        setTimeout(() => {
            window.eventEmitter.emit(`activity_1`, "done");
        }, 2000)
    }

    performToolAction(parameters, event) {
        eventEmitter.emit("show-message", {message: `button with id: "${event.detail}" was clicked`});
    }

    async selectionChanged() {
        const grid = this._element.querySelector("#completeGrid");
        const editDataset = await createDataSetFromDatasource(grid.datasource, this.editDataset);
        editDataset.code = "JHR";

        this.updatedModel = editDataset.raw();
        
        editDataset.update();
    }
    
    remoteUpdate(args) {
        args.successCallback({isValid: () => true});
    }
}