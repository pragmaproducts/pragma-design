/**
 * This function tries to create a function from a evaulation.
 * This function is then used each time we want to inflate an object
 */
export function createInflatorFunction(element, extra) {
    const bindings = [];
    const conditions = [];
    const defaults = [];
    const html = element.innerHTML;

    const attributeBindings = [];

    parseElement(
        element,
        "element", 
        (element) => bindings.push(element),
        (element) => defaults.push(element),
        (element) => attributeBindings.push(element),
        (element) => conditions.push(element)
    );

    let expressions = ["Promise.resolve().then(() => {"];
    for (let binding of bindings) {
        const path = `item.${binding.binding}`;
        const expression = `${binding.path}.innerText = ${path} != null ? ${path} : "";`;
        expressions.push(expression);
    }

    for (let attributeBinding of attributeBindings) {
        const expression = `${attributeBinding.path}.setAttribute("${attributeBinding.name}", item.${attributeBinding.binding});`;
        expressions.push(expression);
    }

    if (extra != null) {
        expressions = expressions.concat(extra);
    }
    
    for (let condition of conditions) {
        const path = `item.${condition.path}`;
        expressions.push(`if((item.${condition.condition}) == false) {
            ${condition.path}.setAttribute("aria-hidden", true)
        }`);
        
        defaults.push(`${condition.path}.removeAttribute("aria-hidden");`);
    }
    
    expressions.push("});")

    const result = {
        inflateFn: new Function('element', 'item', expressions.join("")),
        defaultFn: new Function('element', `Promise.resolve().then(() => {${defaults.join("")}})`)
    };

    return result;
}

function parseElement(element, path, expCallback, defaultCallback, attributeExpCallback, conditionalCallback) {
    const excludedAttributes = ["use"];
    if (excludedAttributes.indexOf(element.nodeName.toLowerCase()) !== -1) return;
    
    if (element.attributes != null) {
        const condition = element.getAttribute("condition");
        if (condition != null) {
            conditionalCallback({
                element: element,
                path: path,
                condition: condition
            })
        }
        else {
            for (const attribute of element.attributes) {
                if (attribute.value.startsWith("#")) {
                    attributeExpCallback({
                        element: element,
                        path: path,
                        binding: attribute.value.slice(1),
                        name: attribute.name
                    });

                    defaultCallback(`${path}.setAttribute("${attribute.name}", '${attribute.value}');`);
                }
            }
        }
    }

    if (element.children.length == 0) {
        if ((element.innerText || "").startsWith("#")) {
            expCallback({
                element: element,
                path: path,
                binding: element.innerText.slice(1)
            });

            defaultCallback(`${path}.innerHTML = '${element.innerText}';`);
        }
    }

    const children = Array.from(element.children);

    for (let i = 0; i < children.length; i++) {
        parseElement(children[i], `${path}.children[${i}]`, expCallback, defaultCallback, attributeExpCallback, conditionalCallback);
    }
}

const inflationUtils =  {
    createInflatorFunction
}

export {inflationUtils}