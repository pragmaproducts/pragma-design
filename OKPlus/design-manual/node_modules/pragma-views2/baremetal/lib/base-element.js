import { addEventsFeatures, removeEventsFeatures } from "./mixin-events.js";
import {addPropertyFeatures} from "./mixin-properties.js";
import {getValueOnPath} from "./objectpath-helper.js";
import {findParentOfInstance} from "./../../lib/dom-helper.js";
import {addIntentionHelper, removeIntentionHelper} from "./mixin-intentions.js";

export class BaseElement extends HTMLElement {
    get visible() {
        return this._visible;
    }

    set visible(newValue) {
        this._visible = newValue;
        if (newValue != null) {
            this.setVisible(newValue);
        }
    }

    constructor(){
        super();
        addEventsFeatures(this);
        addIntentionHelper(this);
        addPropertyFeatures(this);
    }

    connectedCallback() {
        addEventsFeatures(this);
        addIntentionHelper(this);
        this.setRefProperty();
    }

    disconnectedCallback() {
        removeEventsFeatures(this);
        removeIntentionHelper(this);
    }

    attributeChangedCallback(name, oldValue, newValue) {
        const fName = `${name}Changed`;
        if (this[fName] != undefined) {
            this[fName](newValue, oldValue);
        }
    }

    labelElements(queries, paths, attributes) {
        const processCollection = [];
        for (let i = 0; i < queries.length; i++) {
            processCollection.push({
                element: this.querySelector(queries[i]),
                path: paths[i],
                attribute: attributes[i]
            });
        }

        for (let process of processCollection) {
            const translation = getValueOnPath(window.translations, process.path);
            if (process.attribute.toLowerCase() == "innertext") {
                process.element.innerText = translation;
            }
            else {
                process.element.setAttribute(process.attribute, translation);
            }
        }
    }

    /**
     * If you want nulls to be pushed up in the two way coms, set th allowNulls to true
     * @param name
     * @param value
     * @param allowNulls
     */
    notifyPropertyChanged(name, value, allowNulls = false) {
        if (this.__behaviors == undefined) return;
        if (value == undefined && allowNulls != true) return;

        const behaviours = this.__behaviors.filter(item => item._attrName == name.toLowerCase());
        for (let behaviour of behaviours) {
            behaviour.notifyPropertyChanged(name, value);
        }
    }

    onMessage(message) {
        if (message.action == "setAttribute") {
            this.setAttribute(message.attribute, message.value);
        }
    }

    /**
     * Sets a property reference to this instance on the parent BaseElement and triggers the property changed event
     */
    setRefProperty() {
        if (this.hasAttribute("ref") === true) {
            const parent = findParentOfInstance(this, BaseElement);
            if (parent != null) {
                const ref = this.getAttribute("ref");
                parent[ref] = this;
                
                const fName = `${ref}Changed`;
                if (parent[fName] != null) {
                    parent[fName](this);
                }
            }
        }
    }

    setVisible(isVisible) {
        if (this.isBusy === true) {
            return requestAnimationFrame(()=> this.setVisible(isVisible));
        }
        if (isVisible === false) {
            this.setAttribute("aria-hidden", true);
        } else {
            this.removeAttribute("aria-hidden");
        }
    }
}