
export async function findModelOnPathStack(bindingContext, stack) {
    let model = bindingContext;

    for (let item of stack) {
        if (model[item] == undefined) {
            return {
                model: model,
                isFinal: false,
                remainder: stack.slice(stack.indexOf(model)).join(".")
            };
        }

        model = model[item];
    }

    return {
        model: model,
        isFinal: true
    };
}

export function ensureBehavioursExists(element) {
    if (element.__behaviors == undefined) {
        element.__behaviors = [];
    }
}

export async function addBehaviour(element, behaviour) {
    if (element == undefined || element.__behaviors == undefined) return;
    if (element.__behaviors.indexOf(behaviour) == -1) {
        element.__behaviors.push(behaviour);
    }
}

export async function removeBehaviour(element, behaviour) {
    if (element == undefined || element.__behaviors == undefined) return;
    const index = element.__behaviors.indexOf(behaviour);
    if (index != -1) {
        element.__behaviors.splice(index, 1);
    }
}

export async function createBehavioursFromString(behaviourString, element) {
    ensureBehavioursExists(element);

    const behaviourExpressions = behaviourString.split(",");
    behaviourExpressions.forEach(expression => {
        const expressionParts = expression.trim().split("(");
        const key = expressionParts[0];
        const property = expressionParts.length > 1 ? expressionParts[1].split(")")[0] : null;
        createBehaviourFromMap(key, property, element);
    });
}

export function createElementBehaviours(element, behavioursMapping) {
    if (behavioursMapping != undefined) {
        if (window.behavioursMap == undefined) {
            window.behavioursMap = new Map();

            behavioursMapping.forEach(behaviour => {
                window.behavioursMap.set(behaviour.key, behaviour.behaviour);
            });
        }
    }

    const behaviours = element.getAttribute("behaviours");
    if (behaviours != undefined) {
        createBehavioursFromString(behaviours, element);
    }
}

async function createBehaviourFromMap(key, properties, element) {
    if (window.behavioursMap.has(key)) {
        const prototype = window.behavioursMap.get(key);

        if (key === "child-context") {
            const instance = element.__behaviors.find(item => item.constructor.name == prototype.name);
            if (instance != undefined) {
                return;
            }
        }

        const behaviour = new prototype();
        element.__behaviors.push(behaviour);

        behaviour.connectedCallback(element, properties);
    }
}

export async function releaseElement(element) {
    if (element.__behaviors != undefined) {
        for (let behavior of element.__behaviors) {
            behavior.disconnectedCallback();
        }
        element.__behaviors = null;
    }

    releaseElements(element.children);
}

export async function releaseElements(elements) {
    if (elements == undefined) return;
    const elAr = Array.from(elements);
    for (let element of elAr) {
        releaseElement(element);
    }
}