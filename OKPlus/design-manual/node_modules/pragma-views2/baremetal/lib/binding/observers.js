/**
 * addExpressionTriggers: used for evaluating expressions and executing callback if expressions pass
 */

import { getPropertiesFromExpression } from "../actions/expression-parser.js";
import { ExecutionCompiler } from "../actions/code-compiler.js";

window.suppressedObservers = [];
window.observers = new Map();
window.expressions = new Map();
if (window.compiler == undefined) {
    window.compiler = new ExecutionCompiler();
}

let globalIndex = 0;

function getObserver(obj) {
    const symbol = Reflect.get(obj, "__globalId");
    return window.observers.get(symbol);
}

function setObserver(obj, observer) {
    const symbol = Reflect.get(obj, "__globalId");

    if (symbol != undefined) {
        window.observers.set(symbol, observer);
    }
}

function hasObserver(obj) {
    if (obj == undefined || typeof obj != "object") return false;
    const symbol = Reflect.get(obj, "__globalId");
    return window.observers.has(symbol);
}

function deleteObserver(obj) {
    const symbol = Reflect.get(obj, "__globalId");
    window.observers.delete(symbol);
}

export function suppressObserver(id) {
    window.suppressedObservers.push(id);
}

export function unSuppressObserver(id) {
    const index = window.suppressedObservers.indexOf(id);
    if (index != -1) {
        window.suppressedObservers.splice(index, 1);
    }
}

export function observe(obj, globalId = null) {
    // 1. Only observe actual objects else send the value back as is
    if (obj == undefined || typeof obj != "object") return obj;

    // 2. Once a object has been made a proxy, it has a symbol,
    // if it is already a proxy send it back as is
    if (Reflect.get(obj, "__globalId") != undefined) {
        return obj;
    }

    // 3. The object is not a proxy so create one and send it back
    const result = createProxy(obj, globalId);
    let observer = getObserver(result);
    if (observer == undefined) {
        observer = new Map();
        setObserver(result, observer);
    }

    return result;
}

export function createFunctionForExpression(expression, requester) {
    if (window.expressions.has(expression)) {
        const result = window.expressions.get(expression);
        result.requesters.add(requester);
        return result.fn;
    }

    const isExpression = expression.indexOf("${") != -1;
    const fn = window.compiler.add(expression, isExpression);

    const exp = {
        fn: fn,
        requesters: new Set()
    };

    exp.requesters.add(requester);
    window.expressions.set(expression, exp);
    return fn;
}

export async function removeFunctionForExpression(expression, requester) {
    if (window.expressions.has(expression)) {
        const exp = window.expressions.get(expression);
        if (exp.requesters.has(requester)) {
            exp.requesters.delete(requester);
        }
        if (exp.requesters.size == 0) {
            window.expressions.delete(expression);
            exp.fn = null;
        }
    }
}

export function getObjOnPath(obj, stack) {
    if (stack.length == 1) {
        return obj;
    }

    let result = obj;

    for (let i = 0; i < stack.length - 1; i++) {
        const field = stack[i];
        if (result[field] == undefined) {
            const obj = observe({});
            result[field] = obj;
        } else if (hasObserver(result[field]) == false) {
            const observer = observe(result[field]);
            result[field] = observer;
        }

        result = result[field];
    }

    return result;
}

/**
 * Cleanup of observer collection when bindings are no longer required
 * @param proxies
 * @returns {Promise<void>}
 */
export async function removeObserversFromCache(proxies) {
    if (proxies == undefined) return;
    for (let i = 0; i < proxies.length; i++) {
        removeObserverFromCache(proxies[i]);
    }
}

/**
 * Cleanup of a single observer when binding is no longer required
 * @param proxy
 * @returns {Promise<void>}
 */
export async function removeObserverFromCache(proxy) {
    if (proxy == undefined) return;

    if (hasObserver(proxy)) {
        deleteObserver(proxy);

        const keys = Reflect.ownKeys(proxy);
        for (let key of keys) {
            removeObserverFromCache(proxy[key]);
        }
    }
}

/**
 * Add trigger callbacks onto the proxy to call when a property changes
 * @param observer
 * @param field
 * @param trigger
 */
function addTriggerToObserverForField(observer, field, trigger) {
    if (observer == undefined) return;
    
    let callbacks = observer.get(field);
    if (callbacks == undefined) {
        callbacks = new Set();
        observer.set(field, callbacks);
    }

    if (callbacks.has(trigger) == false) {
        callbacks.add(trigger);
    }
}

/**
 * Execute callback defined by trigger when a given property on a path changes value
 * @param proxy: sandbox item
 * @param prop: property path
 * @param trigger: callback to execute
 * @returns {*}
 */
export function addObserverTrigger(proxy, prop, trigger) {
    let stack = prop.split(".");
    
    if (stack.length >= 2) {
        const fld = stack[0];
        let obj = proxy[fld];
        if (obj == undefined || obj.__globalId == undefined) {
            obj = observe(obj || {});
            proxy[fld] = obj;
        }
        
        const observer = getObserver(proxy);
        addTriggerToObserverForField(observer, fld, trigger);

        stack = stack.slice(1, stack.length).join(".");
        return addObserverTrigger(obj, stack, trigger);
    }
    
    const field = stack[0];
    const observer = getObserver(proxy);
    addTriggerToObserverForField(observer, field, trigger);
}

/**
 * Remove a trigger that was defined
 * @param proxy
 * @param prop
 * @param trigger
 */
export function removeObserverTrigger(proxy, prop, trigger) {
    const stack = prop.split(".");
    const field = stack[stack.length - 1];
    const obj = getObjOnPath(proxy, stack);

    const observer = getObserver(obj);
    if (observer == undefined) return;

    let callbacks = observer.get(field);
    if (callbacks == undefined) return;

    if (callbacks.has(trigger)) {
        callbacks.delete(trigger);
    }
}

/**
 * Use this when you want to monitor all field changes on a given expression. This is not the same as a event,
 * these will always fire if one of the properties in the expression changes.
 * @param proxy
 * @param expression
 * @param fn
 */
export function addTriggers(proxy, expression, fn) {
    const properties = getPropertiesFromExpression(expression);
    for (let property of properties) {
        addObserverTrigger(proxy, property, fn);
    }
}

/**
 * add a trigger for when a value changes.
 * If the expression passes fn will be called.
 * If the expression does not pass and fnReverse is defined, that is called.
 * This is used in scenarios where conditional validation is done but needs to be reversed if the condition was true but now false.
 * @param proxy: what is the base object that is used in the with(sandbox) statement
 * @param expression: what is the js expression to evaluate
 * @param fn: call this function if the expression passes
 * @param fnReverse: call this function if the expression fails. most often used for reversing validations
 */
export function addExpressionTriggers(proxy, expression, fn, fnReverse) {
    const expressionFn = createFunctionForExpression(expression, proxy);
    const callback = () => {
        if (expressionFn(proxy) == true) {
            fn();
        }
        else if (fnReverse != undefined) {
            fnReverse();
        }
    };

    addTriggers(proxy, expression, callback);
}

/**
 * Remove all triggers defined the the expression, clean up when using addExpressionTriggers
 * @param proxy
 * @param expression
 * @param fn
 */
export function removeTriggers(proxy, expression, fn) {
    if (proxy == undefined || expression == undefined || fn == undefined) return;
    const properties = getPropertiesFromExpression(expression);
    for (let property of properties) {
        removeObserverTrigger(proxy, property, fn);
    }
}

/**
 * Package an object in a proxy and send that back
 * @param proxy
 * @returns {any}
 */
export function proxyToObject(proxy) {
    return JSON.parse(JSON.stringify(proxy));
}

export function performTriggersFor(obj) {
    const observer = getObserver(obj);
    if (observer != undefined) {
        const keys = observer.keys();
        for (let key of keys) {
            const callbacks = observer.get(key);
            for (let callback of callbacks) {
                callback(obj[key]);
            }
        }
    }
}

async function triggerCallbacks(proxy, prop, newValue, oldValue) {
    if (prop == "__globalId") return;
    
    if (window.suppressedObservers.indexOf(proxy.__globalId) != -1) return;
    
    const observer = getObserver(proxy);
    if (observer == undefined) return;

    const callbacks = observer.get(prop);
    if (callbacks == undefined) {
        if (hasObserver(proxy[prop])) {
            const keys = Reflect.ownKeys(proxy[prop]);
            for (let key of keys) {
                const target = Reflect.get(proxy, prop);
                if (target != proxy) {
                    triggerCallbacks(proxy[prop], key, newValue, oldValue);
                }
            }
        }
    } else {
        for (let callback of callbacks) {
            if (newValue == undefined && oldValue == undefined) {
                continue;
            }

            callback(newValue, oldValue);
        }
    }
}

function createProxy(obj, globalId) {
    const result = new Proxy(obj, {
        get,
        set
    });

    Reflect.set(result, "__globalId", globalId != undefined ? globalId : globalIndex++);
    return result;
}

function get(target, key, receiver) {
    let value = Reflect.get(target, key, receiver);
    
    if (window.observers != null && target.__converters != null) {
        const converter = target.__converters.get(key);
        if (converter != null) {
            value = converter.convert(value, target);
        }
    }
    
    return value;
}

let remapping = false;

function set(target, key, value, receiver) {
    if (window.converters != null && target.__converters != null) {
        const converter = target.__converters.get(key);
        if (converter != null) {
            value = converter.convertBack(value);
        }
    }
    
    if (value === "null") {
        value = null;
    }

    const oldValue = Reflect.get(target, key, receiver);

    if (hasObserver(oldValue)) {
        value = observe(value || {}, oldValue.__globalId);
    }
    
    const result = Reflect.set(target, key, value, receiver);
    
    if (remapping == true) {
        return result;
    }
    
    if (key.indexOf("__") != -1) {
        return result;
    }
    
    if (result == true) {
        if (oldValue != undefined) {
            try {
                remapping = true;
                remapGlobalIdRecursive(receiver, key, value, oldValue);
            }
            finally {
                remapping = false;
            }
        }
        
        const fnName = `${key}Changed`;
        if (target[fnName] != undefined && typeof target[fnName] === "function") {
            target[fnName].call(receiver, value, oldValue);
        }

        triggerCallbacks(receiver, key, value, oldValue);
    }
    
    return result;
}

function remapGlobalIdRecursive(parent, field, newValue, oldValue) {
    if ( newValue == undefined || newValue == oldValue || typeof newValue != "object") return;
    
    let globalId = typeof oldValue != "object" ? null : Reflect.get(oldValue, "__globalId");
    if (globalId != undefined) {
        if (newValue.__globalId == undefined) {
            newValue = observe(newValue, globalId);
            parent[field] = newValue;
        }
        //TODO GM Important: Find out from Chuck why we do this. I am setting a object to another object and it replaces the global id
        // else {
        //     //Reflect.set(newValue, "__globalId", globalId);
        // }
    }
    
    const keys = Object.keys(oldValue);
    for (let key of keys) {
        if (oldValue[key] != undefined && typeof oldValue[key] == "object") {
            if (oldValue[key].__globalId != undefined && newValue[key] == undefined) {
                newValue[key] = observe({});
            }
            
            remapGlobalIdRecursive(newValue, key, newValue[key], oldValue[key]);
        }
    }
}

class Observers {
    get hasCallbacks() {
        return this._callbacks.length > 0;
    }

    constructor(model, propName) {
        this._model = model;
        this._propName = propName;
        this._callbacks = [];
    }

    dispose() {
        this._reversePropertyTrap();
        this._callbacks = null;
        this._model = null;
    }

    registerCallback(callback) {
        if (callback == undefined) return;

        if (this._callbacks.indexOf(callback) == -1) {
            this._callbacks.push(callback);
        }
    }

    unregisterCallback(callback) {
        if (callback == undefined) return;

        const index = this._callbacks.indexOf(callback);
        if (index != -1) {
            this._callbacks.splice(index, 1);
        }
    }

    _setPropertyTrap() {}

    _reversePropertyTrap() {}

    async _callCallbacks(newValue, oldValue) {
        for (let callback of this._callbacks) {
            callback(newValue, oldValue);
        }
    }
}

export class ArrayObserver extends Observers {
    get arrayToWatch() {
        return this._arrayToWatch;
    }
    
    set arrayToWatch(value) {
        this._arrayToWatch = value;
        if (value != null) {
            this._setPropertyTrap();
        } 
    }

    constructor(model, propName) {
        super(model, propName);
        this._removeCallbacks = [];
        this.arrayToWatch = this._model[this._propName];
    }

    dispose() {
        super.dispose();
        if (this.arrayToWatch != undefined) {
            removeObserversFromCache(this.arrayToWatch);
        }
        this._removeCallbacks = null;
        this.arrayToWatch = null;
    }

    [Symbol.iterator]() {
        this.__index = -1;
        return {
            next: args => {
                this.__index++;

                if (this.__index < this.arrayToWatch.length) {
                    return {
                        value: this.arrayToWatch[this.__index],
                        done: false
                    };
                } else {
                    this.__index = -1;
                    return {
                        done: true
                    };
                }
            }
        };
    }

    _setPropertyTrap() {
        this.arrayToWatch.pop = this.pop.bind(this);
        this.arrayToWatch.push = this.push.bind(this);
        this.arrayToWatch.splice = this.splice.bind(this);
    }

    _reversePropertyTrap() {
        if (this.arrayToWatch == undefined) return;
        this.arrayToWatch.pop = Array.prototype.pop;
        this.arrayToWatch.push = Array.prototype.push;
        this.arrayToWatch.splice = Array.prototype.splice;
    }

    registerAddCallback(callback) {
        this.registerCallback(callback);
    }

    unregisterAddCallback(callback) {
        this.unregisterCallback(callback);
    }

    registerRemovedCallback(callback) {
        if (callback == undefined) return;

        if (this._removeCallbacks.indexOf(callback) == -1) {
            this._removeCallbacks.push(callback);
        }
    }

    unregisterRemovedCallback(callback) {
        if (callback == undefined) return;

        const index = this._removeCallbacks.indexOf(callback);
        if (index != -1) {
            this._removeCallbacks.splice(index, 1);
        }
    }

    pop(...args) {
        const result = Array.prototype.pop.call(this.arrayToWatch, ...args);
        this.itemsRemoved(result);
        return result;
    }

    push(...args) {
        const itemsToAdd = [];

        for (let i = 0; i < args.length; i++) {
            const proxy = observe(args[i]);
            Array.prototype.push.call(this.arrayToWatch, proxy);
            itemsToAdd.push(proxy);
        }
        this.itemsAdded(itemsToAdd);

        return this.arrayToWatch.length;
    }

    splice(...args) {
        const removeProperties = args.slice(0, 2);
        const addProperties = args.slice(2, args.length);

        const result = Array.prototype.splice.call(this.arrayToWatch, removeProperties[0], removeProperties[1]);
        this.itemsRemoved(result);

        for (let obj of addProperties) {
            this.push(obj);
        }

        return result;
    }

    itemsAdded(items) {
        this._callCallbacks(items);
    }

    async itemsRemoved(items) {
        removeObserversFromCache(items);

        for (let callback of this._removeCallbacks) {
            callback(items);
        }
    }
}