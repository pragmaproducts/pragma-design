
export async function parseElements(elements, callerObj, bindingContext, origionalContext) {
    return new Promise(resolve => {
        const promises = [];
        const itterator = Array.from(elements);
        for (let element of itterator) {
            promises.push(parseElement(element, callerObj, bindingContext, origionalContext));
        }
        Promise.all(promises).then(() => resolve());
    }).catch(error => console.error(error));
}

const ignoreElementChildren = ["PRAGMA-ICON-BUTTON"];

export async function parseElement(element, callerObj, bindingContext, origionalContext) {
  const skipElements = ["use"] 
    return new Promise(resolve => {
        const promises = [];
        
        if (element.attributes != undefined) {
            if (element.attributes.length > 0) {
                if (skipElements.indexOf(element.nodeName.toLowerCase()) === -1) {
                    promises.push(parseAttributes(element.attributes, callerObj, bindingContext, origionalContext));    
                } 
            }
        }

        if (element.innerText != undefined && element.innerText.trim().length > 0) {
            promises.push(parseInnerText(element, callerObj, bindingContext, origionalContext));
        }

        const canProcessChildren = ignoreElementChildren.indexOf(element.nodeName) == -1; 
        
        if (element.children.length > 0 && canProcessChildren == true) {
            promises.push(parseElements(element.children, callerObj, bindingContext, origionalContext));
        }

        Promise.all(promises).then(() => resolve());
    }).catch(error => console.error(error));
}

const allowedAttr = ["repeat", "behaviours"];

export async function parseAttributes(attributes, callerObj, bindingContext, origionalContext) {
    return new Promise(resolve => {
        const promises = [];
        const collection = Array.from(attributes).filter(item => item.name.indexOf(".") > -1 || allowedAttr.indexOf(item.name) != -1 || item.nodeValue.indexOf("#") != -1);
        for (let attribute of collection) {
            promises.push(parseAttribute(attribute, callerObj, bindingContext, origionalContext));
        }
        Promise.all(promises).then(() => resolve());
    }).catch(error => console.error(error));
}

export async function parseAttribute(attribute, callerObj, bindingContext, origionalContext) {
    return new Promise(resolve => {
        if (allowedAttr.indexOf(attribute.name) != -1) {
            performCallbackForAttribute(callerObj, attribute, attribute.name, attribute.value, bindingContext, origionalContext);
            resolve();
        }

        if (attribute.nodeValue.indexOf("#") != -1) {
            performCallbackForAttribute(callerObj, attribute, "bind", attribute.name, bindingContext, origionalContext);
            resolve();
        }
        else {
            const index = attribute.name.indexOf(".");
            if (index != -1) {
                const bin = attribute.name.split(".");
                performCallbackForAttribute(callerObj, attribute, bin[1], bin[0], bindingContext, origionalContext);
                resolve();
            }
        }
    }).catch(error => console.error(error));
}

function performCallbackForAttribute(callerObj, attribute, fn, prop, bindingContext, origionalContext) {
    if (callerObj[fn] != undefined) {
        callerObj[fn](prop, attribute, bindingContext, origionalContext);
    }
}

export async function parseInnerText(element, callerObj, bindingContext, origionalContext) {
    return new Promise(async resolve => {
        if (element.children.length > 0 || element.innerText == undefined) return resolve();
        if ((element.innerText.indexOf("${") == -1) && (element.innerText.indexOf("#") == -1)) return resolve();

        const attr = {
            ownerElement: element,
            name: "innerhtml",
            nodeValue: element.innerText.trim()
        };

        performCallbackForAttribute(callerObj, attr, "bind", "innerhtml", bindingContext, origionalContext);

        resolve();
    }).catch(error => console.error(error));
}