const tokenType = {
    stringLiteral: "string",
    number: "number",
    operator: "operator",
    expression: "expression",
    object: "object",
    property: "property",
    group: "group"
};

class Token {
    constructor(value, type) {
        this.value = value;
        this.type = type || tokenType.expression;
    }
}

class Navigator {
    constructor(src) {
        this.src = src;
        this.index = 0;
    }

    get nextChar() {
        const nextIndex = this.index + 1;
        if (nextIndex > this.src.length - 1) {
            return "eof";
        }

        return this.src[nextIndex];
    }

    get prevChar() {
        const prevIndex = this.index - 1;
        if (prevIndex < 0) {
            return "bof";
        }

        return this.src[prevIndex];
    }

    get currentChar() {
        return this.src[this.index] || "eof";
    }

    getNextWord() {
        if (this.index > this.src.length - 1) {
            return "eof";
        }

        const word = this.step([]);
        return word;
    }

    step(word) {
        const char = this.currentChar;
        if (char == "eof") return char;

        word.push(char);
        this.moveUp(1);

        if (char == " ") {
            return word;
        } else if (isBreaker(char) == true) {
            if (isOperator(this.currentChar) == true || this.currentChar == "{" || this.currentChar == "&" || this.currentChar == "|") {
                this.step(word);
            }
        } else {
            if (isBreaker(this.currentChar) == false) {
                this.step(word);
            }
        }

        return word;
    }

    moveUp(count) {
        this.index += count;
    }
}

class Ast {
    constructor() {
        this.rootToken = new Token("root-token", tokenType.expression);
        this.currentToken = this.rootToken;

        this.setupParentStack();
    }

    dispose() {
        this.navigator = null;
        this.rootToken = null;
        this.currentToken = null;
        this.parentStack = null;
    }

    parseExpression(src) {
        this.navigator = new Navigator(src);

        if (src.indexOf("${") != -1) {
            this.rootToken.type = tokenType.stringLiteral;
        }

        this.processWords(this.rootToken);
    }

    processWords(parentToken) {
        let word = this.navigator.getNextWord();

        if (word == "eof") {
            return;
        }

        word = word.join("");

        if (parentToken.children == undefined) {
            parentToken.children = [];
        }

        if (parentToken.type == tokenType.stringLiteral) {
            this.addStringChild(parentToken, word);
        } else {
            this.addChild(parentToken, word);
        }

        this.processWords(this.currentParentToken);
    }

    setParentTokenWithValue(value, parentToken) {
        let token = parentToken;
        while (token != undefined && token.value != value) {
            token = this.parentStack.pop();
        }
        this.setAsCurrentParent(token);
    }

    setParentToLastGroup() {
        let token = this.currentParentToken;
        while (token.type != tokenType.group) {
            if (this.parentStack.length == 0) {
                break;
            }

            token = this.parentStack.pop();
        }
        this.setAsCurrentParent(token);
    }

    addChild(parentToken, word) {
        if (word == "}") {
            return this.setParentTokenWithValue("${", parentToken);
        }

        if (word == ")") {
            this.parentStack.pop();
            const parent = this.parentStack.pop();

            this.setAsCurrentParent(parent);
            return;
        }

        if (word == "(") {
            const childToken = new Token(word, tokenType.group);
            parentToken.children.push(childToken);
            this.setAsCurrentParent(childToken);
            return;
        }

        if (mustExclude(word) == false) {
            const childToken = new Token(word, tokenType.object);
            parentToken.children.push(childToken);
            this.postProcessToken(childToken);
        }
    }

    addStringChild(parentToken, word) {
        if (word == "${") {
            let childToken = new Token(word, tokenType.stringLiteral);
            parentToken.children.push(childToken);

            childToken = new Token("", tokenType.expression);
            parentToken.children.push(childToken);
            this.setAsCurrentParent(childToken);
            return;
        }

        const childToken = new Token(word, tokenType.stringLiteral);
        parentToken.children.push(childToken);
    }

    setupParentStack() {
        this.parentStack = [];
        this.setAsCurrentParent(this.rootToken);
    }

    setAsCurrentParent(token) {
        this.currentParentToken = token;
        this.parentStack.push(token);
    }

    postProcessToken(token) {
        token.type = tokenType.object;

        if (token.value == " ") {
            token.type = tokenType.stringLiteral;
        } else if (isOperator(token.value)) {
            token.type = tokenType.operator;
        } else if (isNaN(token.value) == false) {
            token.type = tokenType.number;
        } else if (isString(token.value)) {
            token.type = tokenType.stringLiteral;
        } else {
            const nextChar = this.navigator.nextChar;
            if (token.type == tokenType.object && isBreaker(nextChar)) {
                token.type = tokenType.property;
                this.setParentToLastGroup();
            }
        }

        if (token.type == tokenType.object) {
            this.setAsCurrentParent(token);
        }
    }
}

export function parseExpression(src) {
    const ast = new Ast();
    ast.parseExpression(src);
    const result = ast.rootToken;
    ast.dispose();
    return result;
}

export function getPropertiesFromExpression(src) {
    const ast = parseExpression(src);
    return extractProperties([], ast);
}

function extractProperties(arr, token) {
    if (token.children != undefined) {
        for (let child of token.children) {
            if (isBreaker(child.value) == false) {
                if (child.type == tokenType.property) {
                    arr.push(child.value);
                } else if (child.type == tokenType.object) {
                    arr.push(extractProperty(child));
                } else {
                    extractProperties(arr, child);
                }
            }
        }
    }

    return arr;
}

function extractProperty(token) {
    let t = token;
    let result = "";
    while (t.type != tokenType.property) {
        result += t.value + ".";
        t = t.children[0];
    }
    result += t.value;

    return result;
}

const breakers = [" ", "*", "!", "=", "+", "-", "%", "{", "}", "(", ")", "$", ".", "eof", "?", ":", "&", "|", "<", ">"];
const operators = ["*", "-", "+", "/", "=", "!=", "!==", "==", "===", "&&", "||"];
const stringTerminators = ["'", '"', "`"];
const exclude = ["."];

function isBreaker(char) {
    return breakers.indexOf(char) != -1;
}

function isOperator(char) {
    return operators.indexOf(char) != -1;
}

function isStringTerminator(char) {
    return stringTerminators.indexOf(char) != -1;
}

function isString(word) {
    return word.indexOf("'") != -1 || word.indexOf('"') != -1;
}

function mustExclude(char) {
    return exclude.indexOf(char) != -1;
}