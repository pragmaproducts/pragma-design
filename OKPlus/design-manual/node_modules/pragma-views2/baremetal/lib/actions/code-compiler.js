
export class ExecutionCompiler {
    constructor() {
        this.codeMap = new Map();
        this.proxyMap = new WeakMap();
    }

    dispose() {
        this.codeMap.clear();
        this.codeMap = null;

        const map = Array.from(this.proxyMap);
        for (let i = 0; i < map.length; i++) {
            this.proxyMap.delete(map[i]);
        }
        this.proxyMap = null;
    }

    add(src, isExpression) {
        let fn = this.codeMap.get(src);
        if (fn == undefined) {
            fn = createExecutionProxy(src, this.proxyMap, isExpression);
            this.codeMap.set(src, fn);
        }
        return fn;
    }

    remove(src) {
        if (this.codeMap.has(src)) {
            this.codeMap.delete(src);
        }
    }
}

export function createExecutionProxy(src, proxyMap, isExpression) {
    if (isExpression == true) {
        const parts = splitExpString(src);

        const result = [];
        for (let part of parts) {
            const type = typeOfExpression(part);

            if (type == expTypes.property) {
                result.push(refactorPropExp(part));
            }
            else {
                result.push(part);
            }
        }

        src = "`" + result.join("") + "`";
        src = `with (sandbox) {return ${src}}`;
    }
    else {
        if (src.indexOf("performAction") != -1) {
            src = `sandbox.${src}`;
        }
        else {
            src = `with (sandbox) {return ${src}}`;
        }    
    }

    const fn = new Function('sandbox', 'args', src);

    return function (sandbox, args) {
        let proxy = proxyMap.get(sandbox);

        if (proxy == undefined) {
            proxy = new Proxy(sandbox, {
                has: (target, key) => true,
                get: (target, key) => key === Symbol.unscopables ? undefined : target[key]
            });

            proxyMap.set(sandbox, proxy);
        }

        return fn(proxy, args);
    };
}

function splitExpString(expression) {
    if (expression.length == 0) return null;

    let exp = expression;
    const result = [];

    const startIndex = exp.indexOf("${");
    if (startIndex == -1) {
        return [expression];
    }

    exp = Array.from(exp);
    if (startIndex > 0) {
        result.push(exp.splice(0, startIndex).join(""));
    }

    const endIndex = exp.indexOf("}");
    result.push(exp.splice(0, endIndex + 1).join(""));

    const newExpression = exp.join("");
    let sub = null;

    if (newExpression !== expression) {
        sub = splitExpString(newExpression);
    }

    if (sub != null) {
        return [...result, ...sub];
    }

    return result;
}

function refactorPropExp(exp) {
    const part = exp.slice(2, exp.length - 1);
    return ["${", `${part} == null ? "" : ${part}`, "}"].join("");
}

const expTypes = {
    none: 0,
    property: 1,
    condition: 2
}

function typeOfExpression(exp) {
    const index = exp.indexOf("${");
    if (index == -1) {
        return expTypes.none;
    }

    if (exp.indexOf("?") != -1 && exp.indexOf(":") != -1) {
        return expTypes.condition;
    }

    return expTypes.property;
}