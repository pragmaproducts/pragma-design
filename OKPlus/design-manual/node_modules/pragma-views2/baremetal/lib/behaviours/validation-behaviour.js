import {BehaviourBase} from "./behaviour-base.js";
import {ensureBehavioursExists} from "./../binding/binding-helpers.js";

export function AddValidation(scope, path, validations, tag) {
    let child = scope.querySelector(`[id="${path}"]`);
    if (child == undefined) return;

    child = child.input;

    ensureBehavioursExists(child);
    backupElement(child);
    
    if (Array.isArray(validations)) {
        for (let validation of validations) {
            createValidationBehaviorForRule(child, path, validation, tag);
        }
    }
    else {
        createValidationBehaviorForRule(child, path, validations, tag);
    }
}

export function ReverseValidation(scope, path, validations, tag) {
    let child = scope.querySelector(`[id="${path}"]`);
    if (child == undefined) return;

    const backup = child.input.__validationBackup;
    if (backup == undefined) return;
    
    const keys = Object.keys(backup);
    for (let key of keys) {
        if (backup[key] != null) {
            child.input.setAttribute(key, backup[key]);
        }
        else {
            child.input.removeAttribute(key);
        }
    }
    
    child.input.__validationBackup = null;
    
    if (Array.isArray(validations)) {
        for (let validation of validations) {
            destroyValidationBehaviorForRule(child.input, path, validation, tag);
        }
    }
    else {
        destroyValidationBehaviorForRule(child.input, path, validations, tag);
    }
}

function destroyValidationBehaviorForRule(element, path, validation, tag) {
    if (element.__behaviors == undefined) return;
    const behaviors = element.__behaviors.filter(item => item.tag == tag);
    for (let behavior of behaviors) {
        behavior.disconnectedCallback();
    }
}

/**
 * Backup the validation attributes so that we can return to this state in conditional validation revert operations
 * @param element
 */
function backupElement(element) {
    const backup = {
        required: element.hasAttribute("required") || null,
        readonly: element.hasAttribute("readonly") || null,
        pattern: element.getAttribute("pattern") || null,
        min: element.getAttribute("min") || null,
        max: element.getAttribute("max") || null,
        maxlength: element.getAttribute("maxlength") || null
    }
    
    element.__validationBackup = backup;
}

function createValidationBehaviorForRule(element, path, validation, tag) {
    let behavior = element.__behaviors.find(item => item.tag == tag && item.validation == validation);
    if (behavior == undefined) {
        behavior = new ValidationBehaviour();
        behavior.tag = tag;
        behavior.validation = validation;
        element.__behaviors.push(behavior);
        behavior.connectedCallback(element, validation);
    }
    else {
        behavior.applyRule(behavior.value);
    }
    
    return behavior;
}

export class ValidationBehaviour extends BehaviourBase {
    get enabled() {
        return this._enabled;
    }
    
    set enabled(newValue) {
        this._enabled = newValue;
        
        if (newValue == true) {
            this._element.addEventListener("change", this._valueChangedHandler);
            this.applyRule(this.value);
        }
        else {
            this.revertRule();
            this._element.removeEventListener("change", this._valueChangedHandler);
        }
    } 
    
    connectedCallback(element, args) {
        super.connectedCallback(element);
        this.rule = args;
        this.setRule(args);

        if (this._element.hasValidation != true) {
            this._valueChangedHandler = this._valueChanged.bind(this);
            this._element.hasValidation = true;
            this.enabled = true;
        }
    }

    setRule(expression) {
        if (this._attributeName != undefined) {
            this._element.removeAttribute(this._attributeName);
        }

        const ruleParts = expression.split("=");
        this._attributeName = ruleParts[0].trim();

        this.applyRule(ruleParts.length > 1 ? ruleParts[1].trim() : null);
    }

    disconnectedCallback(element) {
        this._element.removeEventListener("change", this._valueChangedHandler);
        super.disconnectedCallback();
    }

    _valueChanged(event) {
        if (window.eventEmitter == undefined) {
            return;
        }

        let isValid = true;
        let message = "";

        if (this._element.validity != undefined) {
            isValid = this._element.validity.valid;
            message = this._element.validationMessage;
        }

        window.eventEmitter.emit("input-validation", {
            element: this._element,
            isValid: isValid,
            message: message
        });
    }

    applyRule(value) {
        if (this[this._attributeName] != undefined) {
            this.value = value;
            this[this._attributeName](value);
        }
    }
    
    revertRule() {
        this.removeAttribute(this._attributeName);
    }

    required(value) {
        this.setConditionalAttribute("required", value);
    }

    readonly(value) {
        this.setConditionalAttribute("readonly", value);
    }

    setConditionalAttribute(attribute, value) {
        if (value == null || boolean.parse(value) == true) {
            this._element.setAttribute(attribute, attribute);
        } else {
            this._element.removeAttribute(attribute);
        }
    }
    
    maxlength(value) {
        this._element.setAttribute("maxlength", value);
    }
    
    minlength(value) {
        this._element.setAttribute("pattern", `.{${value},}`);
    }
    
    pattern(value) {
        this._element.setAttribute("pattern", value);
    }

    max(value) {
        this._element.setAttribute("max", value);
    }

    min(value) {
        this._element.setAttribute("min", value);
    }
}