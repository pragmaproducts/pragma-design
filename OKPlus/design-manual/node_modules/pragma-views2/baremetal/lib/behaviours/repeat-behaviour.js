import { BehaviourBase } from "./behaviour-base.js";
import { parseElements } from "./../binding/dom-parsing.js";
import { releaseElement, releaseElements } from "../binding/binding-helpers.js";
import { addObserverTrigger, removeObserversFromCache, ArrayObserver, observe } from "../binding/observers.js";
import { PropertyBehaviour } from "./property-behaviour.js";
import { postProcessPropertyChange } from "./behaviour-postprocess.js";
import { getValueOnPath } from "../objectpath-helper.js";
import { DataSourceBase } from "./../../../lib/datasource-base.js";

export class RepeatBehaviour extends BehaviourBase {
    get datasource() {
        return this._datasource;
    }
    
    set datasource(newValue) {
        if (this._datasource != null) {
            this._datasource.uiStateManager.unregisterComponent(this);
        }
        
        this._datasource = newValue;
        
        if (this._datasource != null) {
            this._datasource.uiStateManager.registerComponent(this);
            this.dataSourceChanged(newValue);
        }
    }
    
    static create(attr, bindingContext) {
        const result = new RepeatBehaviour();
        result._context = bindingContext;
        result._property = attr.nodeValue;
        result._parentElement = attr.ownerElement.parentElement;
        result.connectedCallback(attr.ownerElement);
        attr.ownerElement.__behaviors.push(result);
    }

    connectedCallback(element) {
        this._lastId = -1;
        this.dataSourceChangedHandler = this.dataSourceChanged.bind(this);
        this.collectionChangedHandler = this.collectionChanged.bind(this);
        this.itemsAddedHandler = this._itemsAdded.bind(this);
        this.itemsRemovedHandler = this._itemsRemoved.bind(this);

        super.connectedCallback(element);
        addObserverTrigger(this._context, this._property, this.collectionChangedHandler);

        const datasource = getValueOnPath(this._context, this._property);
        if (datasource != undefined && datasource instanceof DataSourceBase) {

            if (datasource._data != undefined) {
                this._itemsAdded(datasource._data);
            }
        }                
    }

    disconnectedCallback() {
        super.disconnectedCallback();

        if (this._parentElement != undefined) {
            this._removeAllChildren();
        }
        
        delete this._context;
        
        this._property = null;
        this._parentElement = null;
        this.itemsAddedHandler = null;
        this.itemsRemovedHandler = null;
        this.dataSourceChangedHandler = null;
        this.collectionChangedHandler = null;
    }

    collectionChanged(newValue, oldValue) {
        if (this.suspendChangeEvent == true) return;
        
        if (oldValue != undefined && newValue instanceof DataSourceBase) {
            this._removeAllChildren();
        }

        if (newValue instanceof DataSourceBase) {
            this.datasource = newValue;
            return;
        }

        this._removeAllChildren();

        if (typeof oldValue == ArrayObserver) {
            oldValue.unregisterAddCallback(this.itemsAddedHandler);
            oldValue.unregisterRemovedCallback(this.itemsRemovedHandler);
            removeObserversFromCache(oldValue);
        }

        this.suspendChangeEvent = true;
        let observer;

        if (this._context[this._property] instanceof ArrayObserver) {
            observer = this._context[this._property];
        }
        else
        {
            for (let i = 0; i < newValue.length; i++) {
                newValue[i] = observe(newValue[i]);
            }

            observer = this._context[this._property] = new ArrayObserver(this._context, this._property);
        }

        observer.registerAddCallback(this.itemsAddedHandler);
        observer.registerRemovedCallback(this.itemsRemovedHandler);

        this._itemsAdded(newValue);
        this.suspendChangeEvent = false;
    }

    async _itemsRemoved(items) {
        const buffer = [];
        Array.isArray(items) ? items.forEach(item => this._getBoundItem(item.__boundId__, buffer)) : this._getBoundItem(items.__boundId__, buffer);

        for (let element of buffer) {
            // JHR: release elements causes the schema to be made null, we should prevent that.
            releaseElement(element);
            this._parentElement.removeChild(element);
        }
    }

    _getBoundItem(id, buffer) {
        const element = this._parentElement.querySelector(`[data-bound-id="${id}"]`);
        if (element != undefined) {
            buffer.push(element);
        }
    }

    async _itemsAdded(items) {
        if (Array.isArray(items)) {
           await this._addBatch(0, 100, items);
        }
        else {
            const fragment = document.createDocumentFragment();
            await this._createItemFromTemplate(items, fragment);
            this._parentElement.appendChild(fragment);
        }
    }

    async _addBatch(start, size, items) {
        const fragment = document.createDocumentFragment();
        const end = start + size;

        for (let i = start; i <= end; i++) {
            if (i > items.length - 1) {
                this._parentElement.appendChild(fragment);
                postProcessPropertyChange(this._parentElement, "repeat", null);
                return -1;
            }

            const item = items[i];
            await this._createItemFromTemplate(item, fragment);
        }

        requestAnimationFrame(() => {
            this._parentElement.appendChild(fragment);
            this._addBatch(end + 1, size, items);
        });
    }

    async _createItemFromTemplate(item, fragment) {
        return new Promise(async resolve => {
            this._lastId += 1;
            item.__boundId__ = this._lastId;

            const instance = document.importNode(this._element, true);

            await parseElements(instance.content.children, this, item, this._context);

            Array.from(instance.content.children).forEach(child => {
                child.dataset.boundId = item.__boundId__;
                fragment.appendChild(child);
            });

            resolve();
        });
    }

    async delegate(event, attr, bindingContext, origionalContext) {
        const context = origionalContext;
        const expression = attr.value;
        if (attr.value.indexOf("(") == -1) {
            context.registerEvent(attr.ownerElement, event, context[attr.value].bind(context));
        }
        else {
            const fn = window.compiler.add(expression, false);
            context.registerEvent(attr.ownerElement, event, (e) => {fn(context, e)});
        }
    }

    async bind(property, attr, bindingContext, origionalContext) {
        return new Promise(async resolve => {
            PropertyBehaviour.create(attr, bindingContext, property);
            resolve();
        }).catch(error => console.error(error));
    }

    async repeat(property, attr, bindingContext, origionalContext) {
        return new Promise(async resolve => {
            const context = attr.nodeValue.indexOf("model.") == -1 && attr.nodeValue.indexOf("context.") == -1 ? bindingContext : origionalContext;
            
            RepeatBehaviour.create(attr, context);
            resolve();
        }).catch(error => console.error(error));
    }

    _removeAllChildren() {
        const children = Array.from(this._parentElement.children).filter(element => element.nodeName != "TEMPLATE");
        releaseElements(children);

        for (let child of children) {
            this._parentElement.removeChild(child);
        }
    }

    async dataSourceChanged(datasource) {
        if (this.isBusy === true) return;
        
        this.isBusy = true;
        this._removeAllChildren();

        if (datasource._data != undefined) {
          await  this._itemsAdded(datasource._data);
        }
        this.isBusy = false;
    }

    stateChanged(args) {
        if (args.state === "none") {
            this.dataSourceChanged(this.datasource);
        }
    }
}