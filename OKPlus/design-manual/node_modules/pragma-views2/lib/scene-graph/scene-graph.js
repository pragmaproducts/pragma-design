import {BackBufferHelper} from "./../back-buffer-helper.js";

export class SceneGraph {
    constructor(parentId, separator) {
        this.parentId = parentId;
        this.separator = separator || " ";
        this.isActive = false;
        this.nodes = [];
        return this;
    }
    
    dispose() {
        for (let node of this.nodes) {
            node.dispose();
        }
        
        this.parentId = null;
        this.separator = null;
        this.isActive = null;
        this.nodes = null;
        
        if (this.backBufferHelper != null) {
            this.backBufferHelper.dispose();
            this.backBufferHelper = null;
        }
    }

    _setIds() {
        for (let i = 0; i < this.nodes.length; i++) {
            this.nodes[i].id = i + 1;
        }
    }
    
    appendNode(node, index) {
        node.id = this.nodes.length + 1;
        (index != null) ? this.nodes.splice(index, 0, node) : this.nodes.push(node);
        this._setIds();
        return node;
    }

    // noinspection JSUnusedGlobalSymbols
    calculateNodePositions(offset = 10, x = 0, y) {
        for (let i = 0; i < this.nodes.length; i++) {
            const currentNode = this.nodes[i];
            const index = i > 0 ? i-1 : i;
            x = currentNode.id === 1 ? x + offset : this.calculateX(x, this.nodes[index], offset);
            currentNode.x = x;
            currentNode.y = this.calculateY(y) || 0;
        }
        return x;
    }
    
    calculateX(initialX, node, offset = 0) {
        return initialX + (node.iconWidth || 0) + node.textWidth + node.xOffset + offset;
    }
    
    calculateY(initialY, offset = 0) {
        return initialY + offset;
    }

    // noinspection JSUnusedGlobalSymbols
    measureAllText(defaultWidth) {
        this.backBufferHelper = this.backBufferHelper || new BackBufferHelper();
        for (const node of this.nodes) {
            node.textWidth = this.backBufferHelper.measureText(node.value.toString().length === 0 ? defaultWidth : node.value.toString());
        }
    }

    toString() {
        const result = [];
        const nodes = this.nodes.filter(node => node.isAction === false);
        
        for (let node of nodes) {
            result.push(node.toString());
        }

        return result.join(this.separator).trim();
    }
}