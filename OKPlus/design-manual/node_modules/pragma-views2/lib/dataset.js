import {Validator} from "./validation-rules.js";
import {DataSourceBase} from "./datasource-base.js";
import {addTriggers, removeObserversFromCache} from "./../baremetal/lib/binding/observers.js";
import {ignore} from "./../baremetal/lib/class-helper.js";
import {DataSetConstants} from "./dataset-constants.js";
import {ActionTypeConstants} from "./datasource-constants.js";
import {UiStateManager} from "./ui-state-manager.js";
import {ComponentUiStates} from "./component-ui-states.js";
import {performTriggersFor} from "./../baremetal/lib/binding/observers.js";
import {createDatasourceFromDefinition} from "./datasource-utils.js";
import {SchemaHelper} from "./schema-helper.js";
import {addPropertyFeatures} from "./../baremetal/lib/mixin-properties.js";

/**
 * todo: clean up the observation objects.
 * unobserver the object
 */
export class DataSet {
    get schemaHelper() {
        return this.getProperty("schemaHelper", () => new SchemaHelper(this["__schema"]));
    }
    
    set schemaHelper(newValue) {
        this.setProperty("schemaHelper", newValue);
    }
    
    constructor(definition, schema, remote, remoteCallback, dataSourceRef) {
        addPropertyFeatures(this);
        this.name = definition ? definition.name : null;
        this["__definition"] = Object.create(definition);
        this["__schema"] = schema;
        this.remote = remote;
        this.remoteCallback = remoteCallback;
        this.activityState = DataSetConstants.none;
        this.dataSourceRef = dataSourceRef;
        this.uiStateManager = new UiStateManager(this);
    }

    dispose() {
        removeObserversFromCache(this);
        this.schemaHelper = null;
        
        if (this.__inflate != undefined){
            delete this.__inflate;
        } 
        const keys = Object.keys(this);

        for (let key of keys) {
            if (this[key] == null || this[key] == null) {
                continue;
            }

            if (this[key].dispose != null && this[key].__disposed !== true) {
                this[key].dispose();
            }
            else if (Array.isArray(this[key])) {
                for (let child of this[key]) {
                    if (child.dispose != null) {
                        child.dispose();
                    }
                }
            }

            delete this[key];
        }

        this.__proto__ = null;
    }

    async _processSave(actionName, model) {
        const actionOptions = this.getActionOptions(actionName);

        //await this.validate();
        return this._triggerCallback(actionName, model, actionOptions);
    }

    _triggerCallback(actionName, model, actionOptions) {
        return new Promise((resolve) => {
            this.activityState = DataSetConstants.busy;

            this.remoteCallback(
                {
                    remote: this.remote,
                    type: actionName,
                    model: model,
                    action: (actionOptions || {action: "update"}).action,
                    parameters: (actionOptions || {}).parameters,
                    successCallback: (data) => {
                        this.activityState = DataSetConstants.done;
                        resolve(data);
                    },
                    errorCallback: (data) => {
                        this.activityState = DataSetConstants.error;
                        resolve(data);
                    }
                });
        });
    }

    _verifyAllParametersSet(parameters){
        const keys = Object.keys(parameters);
        for (const key of keys){
            if (parameters[key] == undefined) return false; 
        } 
        return true;
    }

    applyValues(item, mapping, setInitialValues = false) {
        const obj = mapping != null ? mapping : item;
        const keys = Object.keys(obj);
        for (let key of keys) {
            const sourceField = mapping != null ? mapping[key] : key;
            const value = item[sourceField];
            
            this[key] = value;

            if (setInitialValues === true) {
                this._setInitialValue(key, value);
            }
        }
    }

    _setInitialValue(key, value) {
        const field = this.__definition.fields.find(field => field.name === key);
        if (field != null) {
            field.initialValue = value;
        }
    }

    clear() {
        const keys = Object.keys(this);

        for (let key of keys) {
            if (ignore.indexOf(key) == -1) {
                if ((this[key] || {}).clear != undefined) {
                    if (typeof this[key].clear == "function") {
                        this[key].clear();
                    }
                }
                else {
                    this[key] = null;
                }
            }
        }

        const fields = this.__definition.fields;
        for (let field of fields) {
            delete field.initialValue;
        }
    }

    async create() {
        const result = await this._processSave("create", this.raw());
        if ((result || {}).isValid() === false) return false;
        
        const parameters = [result.data.id];
        await window.dataSourceManager.performAction(ActionTypeConstants.itemsAdded,this.dataSourceRef || this.remote, parameters);
        
        return true;
    }

    defaultFromDefinition() {
        const result = {};

        const fields = this["__definition"].fields;
        for (let field of fields) {
            if (field.collection == true) {
                result[field.name] = [];
            }
            else {
                result[field.name] = field.default == undefined ? null : field.default;
            }
        }

        return result;
    }

    doDrillDown(fieldName) {
        this.sendPreviewMessage(fieldName, "drilldown-from-resource");
    }

    doEdit() {
        window.eventEmitter.emit("do-edit", {
            model: this,
            callback: (editedItem) => this.applyValues(editedItem)
        })
    }

    doLookup(fieldName, filterValue, callback) {
        const field = this["__definition"].fields.find(item => item.name === fieldName);
        const lookupId = field.lookup;
        const lookup = this["__schema"].lookups.find(item => item.id === lookupId);
        const perspective = this["__schema"].perspectives.find(item => item.id === lookup.perspective);
        const previewId = field.preview;
        const preview = previewId != null ? this["__schema"].previews.find(item => item.id === previewId) : previewId;

        window.eventEmitter.emit("do-lookup", {
            definition: lookup,
            perspective: perspective,
            preview: preview,
            model: this,
            filter: filterValue,
            filterField: lookup.mapping[fieldName],
            sourceSchema: this["__schema"],
            successCallback: (selectedItem) => {
                this.applyValues(selectedItem, lookup.mapping);
                callback(true);
            },
            cancelCallback: () => {
                callback(false);
            }
        });
    }

    doPeek(fieldName) {
        this.sendPreviewMessage(fieldName, "perform-view");
    }

    getActionOptions(actionName) {
        const actions = this["__primaryActions"];
       
        if (actions != undefined && actions[actionName] != undefined) {
            let result = {};
            result.parameters = this.schemaHelper.inflateParameters(this, actions[actionName].parameters);
            result.action = actions[actionName].action;
            return result;
        }
    }
    
    getDirtyArray(items) {
        const result = [];

        for (let item of items) {
            if (item instanceof DataSet) {
                result.push(item.getDirtyModel())
            }
        }

        return result.length > 0 ? result : null;
    }

    getDirtyField(field, isNewObject) {
        const modelValue = this[field.name];
        const initialValue = field.initialValue != undefined ? field.initialValue : null;

        if (modelValue instanceof DataSet) {
            return modelValue.getDirtyModel()
        }

        if (Array.isArray(modelValue)) {
            return this.getDirtyArray(modelValue);
        }

        //TODO GM: Temporary
        if (modelValue instanceof DataSourceBase) {
            return null;
        }

        if (isNewObject == true) {
            if ((modelValue || "").length == 0) {
                return null;
            }

            return {
                oldValue: null,
                newValue: modelValue
            }
        }

        if (modelValue != initialValue) {
            return {
                oldValue: initialValue,
                newValue: modelValue
            }
        }
    }

    getDirtyModel() {
        this.activityState = DataSetConstants.gettingDirtyState;
        const result = {};
        const isNewObject = this["id"] === -1;

        for (let field of this.__definition.fields) {
            const dirty = this.getDirtyField(field, isNewObject);

            if (dirty != null) {
                result[field.name] = dirty;
            }
        }

        this.activityState = DataSetConstants.none;
        
        return Object.keys(result).length > 0 ? result : null;
    }

    /**
     * Gets the dirty model and flattens the properties
     */
    getFlatDirtyModel() {
        const changes = this.getDirtyModel();
        let model = {};

        if (changes != null){
            const keys = Object.keys(changes);
            for (const key of keys) {
                let change = changes[key];
                if (change != null && !(change.oldValue === null && change.newValue === "") && key != "id") {
                    model[key] = change.newValue;
                }
            }
        }

        return model;
    }

    listenFor(property, callback) {
        // JHR: if this is a path ?
        if (callback) {
            addTriggers(this, property, () => callback(this, property));
        }
        else {
            const propertyCallback = this[`${property}Changed`];
            if (propertyCallback) {
                addTriggers(this, property, propertyCallback);
            }
        }
    }

    componentStateChanged(componentsState) {
        if(componentsState === ComponentUiStates.active) {
            this.load();
        }
    }

    load(parentDataset) {
        if((parentDataset || {}).drafted === true && this.__loadedFromDraft !== true) {
            this.__loadedFromDraft = true;
            return;
        }
        if (this["__delay"] === true && this.uiStateManager.getState() === ComponentUiStates.suspended) return;

        const actionOptions = this.getActionOptions("load");
        /**
         * Check for any undefined parameters to prevent execute
         * Need to do this to prevent loading without required route parameters
         * When the selected id changes to blank for example
         */

        if (actionOptions == null || actionOptions.parameters == null || this._verifyAllParametersSet(actionOptions.parameters) === false) return;

        this.remoteCallback(
            {
                remote: this.remote,
                type: "load",
                parameters: actionOptions.parameters,
                action: actionOptions.action,
                successCallback: (data) => this.setInitialValues(data)
            });
    }

    raw() {
        const result = {};
        for (let field of this.__definition.fields) {
            //TODO GM: Temporary till we deal with dataSource dirty state
            if (this[field.name] !== undefined && this[field.name] instanceof DataSourceBase === false) {
                result[field.name] = this[field.name];    
            } 
        }
        return result;
    }

    resetToDefault() {
        for (let field of this.__definition.fields) {
            const fld = this[field.name];

            if (fld instanceof DataSourceBase) {
                fld.clear();
            }
            else if (field instanceof DataSet) {
                fld.resetToDefault();
            }
            else {
                this[field.name] = field.initialValue != null ? field.initialValue : undefined;
            }
        }
    }

    sendPreviewMessage(fieldName, messageKey) {
        if (fieldName == undefined) {
            return;
        }

        const field = this["__definition"].fields.find(item => item.name == fieldName);
        const previewId = field.preview;
        const preview = this["__schema"].previews.find(item => item.id == previewId);
        const datsetField = preview["dataset-field"];
        const idValue = this[datsetField];

        window.eventEmitter.emit(messageKey, {
            resourceId: idValue,
            remote: preview["remote"]
        });
    }

    setInitialValues(model = {}, draft) {
        //this.clear();

        draft = draft || model;

        this.__isLoading = true;

        const fields = this.__definition.fields;
        const collectionsToLoad = [];
        const dataSetsToLoad = [];

        for (let field of fields) {
            if (field.collection === true) {
                if (this[field.name] == null) {
                    const dsId = field.datasource;
                    const dsSchema = this.__schema.datasources.find(item => item.id === dsId);
                    this[field.name] = this.datasetFactory.createDatasource(dsSchema);
                }

                collectionsToLoad.push({ instance: this[field.name], data: draft[field.name]});
            }
            else if (field.dataset != null) {
                dataSetsToLoad.push(field);
            }
            else {                
                let fieldValue = model[field.name];
                if (fieldValue == null) {
                    fieldValue = this.__defaults.has(field.name) ? this.__defaults.get(field.name) : undefined;
                }

                this[field.name] = draft[field.name] != null ? draft[field.name] : fieldValue;
                
                this.activityState = DataSetConstants.gettingDirtyState;
                field.initialValue = fieldValue;
                this.activityState = DataSetConstants.none;
            }
        }

        for (let collection of collectionsToLoad) {
            if (collection.instance != null) {
                if(collection.data != null) {
                    collection.instance.loadDraft(collection.data);
                }
                else if (collection.instance.definition["delay-fetch"] !== true) {
                    collection.instance.load();
                }
            }
        }

        for (let field of dataSetsToLoad) {
            if (this[field.name] != null) {
                if (draft[field.name] == null) {
                    this[field.name].resetToDefault();
                }
                else {
                    this[field.name].setInitialValues(model[field.name], draft[field.name]);
                }
            }
        }

        this.__isLoading = false;

        performTriggersFor(this);
    }
    
    async update() {
        const changes = this.getFlatDirtyModel();
        if (Object.keys(changes).length > 0) {
            changes.version = this.version;
            const result = await this._processSave(ActionTypeConstants.update, changes);
            if ((result || {}).isValid() === false) return false;
            
            const parameters = [this["id"]];
            await window.dataSourceManager.performAction(ActionTypeConstants.itemsUpdated, this.dataSourceRef || this.remote, parameters);
            
            return true;
        }
    }

    validate() {
        return Validator.validateDataset(this);
    }
}
