import {DataSourceBase} from "./datasource-base.js";
import {itemsToHierarchyItems} from "./hierarchical-item.js";
import {ComponentUiStates} from "./component-ui-states.js";
import {DataSourceStateConstants} from "./datasource-constants.js";
import {DatasourceEventTypes} from "./datasource-event-types.js";

export class RemoteDatasource extends DataSourceBase {
    constructor(options) {
        super(options);
        this.remoteCallback = options.remoteCallback;
        window.dataSourceManager.add(this).then((result) => this._key = result);
        this.dataFetchCountHandler = this.dataFetchCount.bind(this);
    }

    dispose() {
        window.dataSourceManager.remove(this._key);
        this.inflatedParameters = null;
        this.remoteCallback = null;
        this.isLoading = false;
        super.dispose();
    }

    componentStateChanged(componentsState) {
        // Prevent loading is used by lookup to prevent loading when component becomes active. The lookup triggers the load
        if(this.definition.preventLoading == null && this.definition.remote != null && componentsState === ComponentUiStates.active) {
            this.load();
        }
    }

    _verifyAllParametersSet(parameters){
        if(parameters == null) return;
        for (const key of Object.keys(parameters)){
            if (parameters[key] == undefined) return false;
        }
        return true;
    }
    
    /**
     *
     * @param ids - Ids of items added
     */
    async itemsAdded(ids) {
        const items = await this.loadByIds(ids);
        await super.itemsAdded(items);
    }

    /**
     *
     * @param ids - Ids of items deleted
     */
    async itemsDeleted(ids) {
        let map = {};
        
        for (const item of this._data){
            map[item.id] = item;
        } 
        
        let items = [];

        for (const id of ids) {
            if (map[id] != null) {
                items.push(map[id]);
            } 
        }
        
        await super.itemsDeleted(items);
    }

    /**
     *
     * @param ids - Ids of items updated
     */
    async itemsUpdated(ids) {
        const items = await this.loadByIds(ids);
        await super.itemsUpdated(items);
    }

    async load(model, parentItem, queryOptions) {
        if(this.isLoading === true) return;

        this.isLoading = true;
        const state = this.uiStateManager.getState();
        if (this._validateBeforeLoad(state) === false) {
            this.isLoading = false;
            return;
        }
       
        
        if (parentItem == null) {
            await this._loadNormalItems(model, queryOptions, state);
        }
        else {
            await this._loadParentedItems(model, parentItem);
        }
        this.uiStateManager.notify(DatasourceEventTypes.dataCollectionEnded);
        this.isLoading = false;
    }
    
    _validateBeforeLoad(state) {
        // This is true of not all the UI components using this is active yet.
        if(state === ComponentUiStates.suspended) {
            return false;
        }
        
        if (this.definition["use-default-parameter-values"] !== true && this.definition["requires-parameter-values"] === true) {
            return false;
        }

        this.inflatedParameters = this.schemaHelper.inflateParameters(null, this.definition.parameters);
        if(this._verifyAllParametersSet(this.inflatedParameters) === false) {
            return false;
        }
    }
    
    async _loadNormalItems(model, queryOptions, state) {
        // Check if the components are not state empty. Empty means they have not been connected to the DOM once.
        // We also don't want to wait for the UI to be ready before we start fetching data so we continue the chain even if its are not ready
        this.componentsReady = state !== ComponentUiStates.empty;
        if(this.componentsReady === true) {
            this.uiStateManager.notify(DatasourceEventTypes.dataCollectionStarted);
        }
        this.state = DataSourceStateConstants.busy;
        let items = await this.remoteCallback(this.definition, model, null, this.inflatedParameters , queryOptions, this.dataFetchCountHandler);
        await super.load(items);
    }

    async loadByIds(ids) {
        const queryOptions = [{
            field: "id",
            value: Array.isArray(ids) ? ids : Array.from(ids)
        }];
        return this.remoteCallback(this.definition,null, null, this.inflatedParameters, queryOptions)
    }
    
    async _loadParentedItems(model, parentItem, queryOptions) {
        let items = await this.remoteCallback(this.definition, model, parentItem, this.inflatedParameters , queryOptions, this.dataFetchCountHandler);
        items = itemsToHierarchyItems(items, parentItem.depth, parentItem.model.__path);
        parentItem.items = items;
    }

    dataFetchCount(count) {
        if(this.uiStateManager.getState() === ComponentUiStates.empty) {
            return true
        }

        else if(this.componentsReady === false) {
            this.componentsReady = true;
            this.uiStateManager.notify(DatasourceEventTypes.dataCollectionStarted);
        }

        const result = this.uiStateManager.notify(DatasourceEventTypes.fetchingData, count);

        if (result != null) {
            return result[0];
        }
    }
}