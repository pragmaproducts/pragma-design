import {SchemaHelper} from "./schema-helper.js";
import {itemsToHierarchyItems, HierarchicalItem} from "./hierarchical-item.js";
import {DataSourceStateConstants} from "./datasource-constants.js";
import {UiStateManager} from "./ui-state-manager.js";
import {DatasourceEventTypes} from "./datasource-event-types.js";

export class DataSourceBase {

    constructor(options) {
        this.definition = options.definition;
        this.schema = options.schema;
        this.schemaHelper = new SchemaHelper(this.schema);
        this._selectedItemsMap = new Map();
        this.uiStateManager = new UiStateManager(this);
        this.idField = this.definition.idField || "id"; //TODO JN: Implement idFIeld change for perspective and other related objects (group worker....)
        this.selectedId = [];
    }

    dispose() {
        window.groupWorker.disposeCache(this.initialDataCacheId);

        if (this.definition.perspective != null) {
            if (this.definition.perspective.cache != null) {
                window.groupWorker.disposeCache(this.definition.cache);
            }
        }

        this.uiStateManager.dispose();
        this.uiStateManager = null;

        this._state = null;
        this.definition = null;
        delete this.schema;
        this.schemaHelper.dispose();
        this.schemaHelper = null;
        this.rootItemsLoadedCallbacks = null;
        this._selectedItemsMap = null;
    }

    get state() {
        return this._state;
    }

    set state(newValue) {
        if (newValue != null && this._state != newValue) {
            this._state = newValue;
            this.uiStateManager.notify(DatasourceEventTypes.stateChanged, {state: newValue})
        }
    }

    get selectedId() {
        return this._selectedId;
    }

    set selectedId(newValue) {
        if (newValue == null || this.selectedItemsMap == null) return;
        this._selectedId = newValue;

        if (newValue != null || this.state !== DataSourceStateConstants.busy) {
            this._updateSelectedItems();
        }

        this.selectionChanged();
    }

    get schema() {
        return this._schema;
    }

    set schema(newValue) {
        this._schema = newValue;
        if (this.schemaHelper != null) {
            this.schemaHelper.schema = newValue;    
        } 
    }

    selectionChanged() {
        this._selectedId = Array.from(this.selectedItemsMap.keys());
        this.selectedItems = Array.from(this.selectedItemsMap.values());
        this.uiStateManager.notify(DatasourceEventTypes.selectionChanged, {selectedItems: this.selectedItemsMap});
    }

    get selectedItemsMap() {
        return this._selectedItemsMap;
    }

    set selectedItemsMap(newValue) {
        if (newValue === null) return;
        this._selectedItemsMap = newValue;

    }

    get selectedItems() {
        return this._selectedItems;
    }

    set selectedItems(newValue) {
        this._selectedItems = newValue;
    }


    get initialDataCacheId() {
        return `${this.definition.id}_initial_items`;
    }

    async _createPerspectives(items) {
        return new Promise(resolve => {
            let perspectives = [];

            for (let id of this.definition.perspective.perspectives) {
                const perspective = this.schema.perspectives.find(item => item.id == id);
                perspectives.push(perspective);
            }

            const eventName = `records_${this.definition.perspective.cache}`;
            const fn = () => {
                window.eventEmitter.remove(eventName, fn);
                resolve();
            };

            window.eventEmitter.on(eventName, fn);

            window.groupWorker.createCache(this.definition.perspective.cache, items, perspectives);
        });
    }

    _updateSelectedItems() {
        this._selectedItemsMap.clear();
        let result = {};

        if (this.definition.hierarchical) {
            this._createHierarchicalResult(result, this._data);
        } else {
            for (const item of this._data || []) {
                const key = item[this.idField];
                result[key] = item;
            }
        }

        for (const id of this.selectedId) {
            if (result[id] != null) {
                this._selectedItemsMap.set(id, result[id]);
            }
        }
    }

    _createHierarchicalResult(result, items) {

        for (const item of items || []) {
            const key = item.model[this.idField];
            result[key] = item.model;

            if (item.items != null && item.items.length > 0) {
                this._createHierarchicalResult(result, item.items);
            }
        }
    }

    async addPerspectiveData(items) {
        return new Promise(resolve => {
            const eventName = `${this.definition.perspective.cache}_add`;
            const fn = (data) => {
                window.eventEmitter.remove(eventName, fn);
                resolve(data);
            };

            window.eventEmitter.on(eventName, fn);
            window.groupWorker.addRecords(this.definition.perspective.cache, items);
        })
    }


    clear() {
        if (this._data == null) {
            return;
        }

        while (this._data.length > 0) {
            const item = this._data.pop();
            if (item.dispose != null) {
                item.dispose();
            }
        }

        this.selectedId = null;
    }

    /**
     * Get the data required
     * @returns {Promise<void>}
     */
    async data(options) {
        if (options != null && options.perspective != null) {
            return this.getPerspectiveData(options.perspective);
        }
        return this._data;
    }

    findById(id) {
        for (const item of this._data) {
            if (item[this.idField] === id) {
                return item;
            }
        }
    }

    async getPerspectiveData(pid) {
        return new Promise(resolve => {
            const eventName = `${this.definition.perspective.cache}_${pid}`;
            const fn = (data) => {
                window.eventEmitter.remove(eventName, fn);

                let result = data;

                const p = this.schema.perspectives.find(item => item.id == pid);

                if (result.items != null && p.data.grouping != null) {
                    result = itemsToHierarchyItems(result.items);
                } else {
                    result = result.items;
                }

                resolve(result);
            };

            window.eventEmitter.on(eventName, fn);
            window.groupWorker.getGroupPerspective(this.definition.perspective.cache, pid);
        })
    }

    /**
     * Items added event handler
     * @param items - array of items added
     */
    async itemsAdded(items) {
        if(items == null) return;
        this.hasItems = true;
        for (const item of items) {
            this._data.push(item);
        }
        let perspectives;
        if (this.definition.perspective != null) {
            // Add item to all perspectives
            perspectives = await this.addPerspectiveData(items);
            for (const perspective of perspectives) {
                for (const item of perspective.items) {
                    if (item.newItemPath != null) {
                        item.newItemPath = itemsToHierarchyItems(item.newItemPath.items);
                    }
                }
            }
        }

        this.uiStateManager.notify(DatasourceEventTypes.itemsAdded, {items, perspectives});
    }

    /**
     * Items deleted event handler
     * @param items - array of items deleted
     */
    async itemsDeleted(items) {
        for (const item of items) {
            const index = this._data.indexOf(item);
            if (index !== -1) {
                this._data.splice(index, 1);
            }
        }

        let perspectives;
        if (this.definition.perspective != null) {
            perspectives = await this.removePerspectivesData(items);
            for (const perspective of perspectives) {
                for (const item of perspective.items) {
                    if (item.oldItemPath != null) {
                        item.oldItemPath = itemsToHierarchyItems(item.oldItemPath.items);
                    }
                }
            }
        }

        this.uiStateManager.notify(DatasourceEventTypes.itemsDeleted, {items, perspectives});

        // Select the first item in list after delete
        const firstItem = this._data[0];
        if (firstItem != null) {
            this.selectedId = [firstItem.id];
        }

        this.hasItems = this._data.length > 0;
    }

    /**
     * Items updated event handler
     * @param items - array of items updated
     */
    async itemsUpdated(items) {
        for (const item of items) {
            let existingItem = this.findById(item.id);
            if (existingItem == null) continue;
            const keys = Object.keys(item);
            for (const key of keys) {
                if (existingItem[key] !== item[key])
                    existingItem[key] = item[key];
            }
        }
        let perspectives;
        if (this.definition.perspective != null) {
            perspectives = await this.updatePerspectiveData(items);
            for (const perspective of perspectives) {
                for (const item of perspective.items) {
                    if (item.newItemPath) {
                        item.oldItemPath = itemsToHierarchyItems(item.oldItemPath.items);
                        item.newItemPath = itemsToHierarchyItems(item.newItemPath.items);
                    }
                }
            }
        }

        this.uiStateManager.notify(DatasourceEventTypes.itemsUpdated, {items, perspectives});
    }

    /**
     * Filters initial data based on filter string, triggers stateChangedCallbacks on return of filter results
     * @param filter
     * @returns {Promise<void>}
     */
    async filter(filter) {
        this.state = DataSourceStateConstants.busy;
        this.selectedId = [];

        let items = await this.getFilterRecords(filter);

        this._setData(items);

        if (this.definition.perspective != null) {
            await this._createPerspectives(items);
        }

        this.hasItems = (this._data || []).length > 0;

        this.state = DataSourceStateConstants.none;
    }

    /**
     * Emits filterRecords message to group worker and returns results
     * @param filter
     * @returns {Promise<*>}
     */
    async getFilterRecords(filter) {
        return new Promise(resolve => {
            const eventName = `filtered_records_${this.initialDataCacheId}`;

            const fn = (data) => {
                window.eventEmitter.remove(eventName, fn);
                resolve(data);
            };

            window.eventEmitter.on(eventName, fn);
            window.groupWorker.filterRecords(this.initialDataCacheId, filter);
        });
    }

    async load(items) {
        this.state = DataSourceStateConstants.busy;

        this.clear();

        window.groupWorker.createCache(this.initialDataCacheId, items);

        this._setData(items);

        if (this.definition.perspective != null) {
            await this._createPerspectives(items);
        }

        this.hasItems = (items || []).length > 0;

        this.state = DataSourceStateConstants.none;
        if (this.selectedId != null && this.selectedId.length == 0 && items.length > 0) {
            this.selectedItemsMap.set(items[0][this.idField], items[0]);
            this.selectionChanged();
        }

        return this;
    }

    async loadDraft(items) {
        this.state = DataSourceStateConstants.busy;

        window.groupWorker.createCache(this.initialDataCacheId, items);

        this._data = items;

        if (this.definition.perspective != null) {
            await this._createPerspectives(items);
        }

        this.hasItems = (items || []).length > 0;

        this.state = DataSourceStateConstants.none;
        if (this.selectedId != null && this.selectedId.length == 0 && items.length > 0) {
            const model = items[0] instanceof HierarchicalItem ? items[0].model : items[0];
            this.selectedItemsMap.set(model[this.idField], model);
            this.selectionChanged();
        }
    }

    /**
     * Sets local data property based on provided data items
     * @param items
     * @private
     */
    _setData(items) {
        if (this.definition.hierarchical === true) {
            this._data = itemsToHierarchyItems(items);
        } else {
            this._data = items;
        }
    }

    async removePerspectivesData(items) {
        return new Promise(resolve => {
            const eventName = `${this.definition.perspective.cache}_remove`;
            const fn = (data) => {
                window.eventEmitter.remove(eventName, fn);
                resolve(data);
            };

            window.eventEmitter.on(eventName, fn);
            window.groupWorker.removeRecords(this.definition.perspective.cache, items);
        })
    }

    removeRootItemsLoadedCallback(fn) {
        const index = this.rootItemsLoadedCallbacks.indexOf(fn);
        if (index !== -1) {
            this.rootItemsLoadedCallbacks.slice(index, 1);
        }
    }

    async updatePerspectiveData(items) {
        return new Promise(resolve => {
            const eventName = `${this.definition.perspective.cache}_update`;
            const fn = (data) => {
                window.eventEmitter.remove(eventName, fn);
                resolve(data);
            };

            window.eventEmitter.on(eventName, fn);
            window.groupWorker.updateRecords(this.definition.perspective.cache, items);
        })
    }

    addSelection(ids) {
        const currentIds = this.selectedId || [];
        // Using object map to increase performance
        let currentIdMap = {};
        for (const id of currentIds) {
            currentIdMap[id] = id;
        }

        for (const id of ids) {
            if (currentIdMap[id] == null) {
                currentIds.push(id);
            }
        }

        this.selectedId = currentIds;
    }

    removeSelection(ids) {
        let currentIds = this.selectedId || [];
        // Using object map to increase performance
        let currentIdMap = {};
        for (const id of currentIds) {
            currentIdMap[id] = id;
        }

        for (const id of ids) {
            if (currentIdMap[id] != null) {
                delete currentIdMap[id];
            }
        }

        currentIds = [];
        for (const id of Object.values(currentIdMap)) {
            currentIds.push(id)
        }

        this.selectedId = currentIds;
    }

    isAllSelected() {
        return this.count() === this.selectedItemsMap.size;
    }

    count() {
        if (this.definition.hierarchical === true) {
            return this._countRecursively(this._data[0]);
        }
        return this._data.length;
    }

    _countRecursively(item) {
        let count = 0;
        if (item.hasChildren === true) {
            for (const child of item.items) {
                count += this._countRecursively(child);
            }
        } else {
            count += 1;
        }
        return count;
    }

    selectAll() {
        const ids = [];
        if (this.definition.hierarchical === true) {
            this._selectRecursively(this._data[0], ids);
        } else {
            for (const item of this._data) {
                ids.push(item[this.idField]);
            }
        }

        this.selectedId = ids;
    }

    _selectRecursively(item, array) {
        if (item.hasChildren === true) {
            for (const child of item.items) {
                this._selectRecursively(child, array);
            }
        } else {
            const id = item instanceof HierarchicalItem ? item.model[this.idField] : item[this.idField];
            array.push(id);
        }
    }

    isGrouped(perspectiveId) {
        perspectiveId = typeof perspectiveId == "string" ? Number(perspectiveId) : perspectiveId;
        const perspective = (this.schema.perspectives || []).find(p => p.id === perspectiveId);
        if (perspective == null) {
            return false;
        }
        return (perspective.data.grouping || []).length > 0;
    }

    /**
     * Use this function to locate HierarchicalItem inside datasource by supplying a path
     * @param path - e.g. "0.1.2"
     * @returns {HierarchicalItem}
     */
    findByPath(path) {
        if(this.definition.hierarchical !== true) return;

        const indexes = path.split(".").map(_=> Number(_));
        return this._findByIndexRecursive(indexes, this._data);
    }

    /**
     * Recursive funtion to find HierarchicalItem by its path
     * @param indexes - {array} Integer array of indexes representing item locations in the hierarchy
     * @param items - {array} Items to process
     * @returns - HierarchicalItem
     * @private
     */
    _findByIndexRecursive(indexes, items) {
        const item = items[indexes.shift()];
        if(indexes.length > 0) {
            return this._findByIndexRecursive(indexes, item.items);
        }
        return item;
    }


    /**
     * Performa  a crud update for the given row as defined by __dataIndex and field name
     * @param rowId
     * @param fieldName
     */
    updateRecord(rowId, fieldName, value) {
        console.log(`Todo: update record: ${rowId} set field: ${fieldName} to "${value}"`);
        return true;
    }
}