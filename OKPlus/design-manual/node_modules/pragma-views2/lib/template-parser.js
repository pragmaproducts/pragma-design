import {
    populateTemplate,
    tabsheetHtml,
    tabSheetButtonHtml,
    tabSheetPageHtml,
    groupHtml,
    htmlTemplateHtml,
    inputHtml,
    readOnlyHtml,
    textareaHtml,
    cardHtmlTemplate,
    buttonHtml,
    actionButtonHtml,
    iconButtonHtml,
    dynamicHtml,
    checkboxHtml,
    selectHtmlForDefinedOptions,
    listTemplate,
    treeTemplate,
    masterDetailHtml,
    selectRepeatOption,
    selectOption,
    radioRepeatOptions,
    radioGroup,
    visualizationTemplate,
    radioOption,
    panelBarHtml,
    validationsMap,
    splitViewHtml,
    gridTemplate,
    gridColumnTemplate,
    formatterTemplate,
    overflowToolbarTemplate,
    dateTimeHtml,
    dateHtml,
    svgSymbol,
    treeListTemplate
} from "./template-parser-contstants.js";

import { getValueOnPath } from "../baremetal/lib/objectpath-helper.js";
import { capitialize } from "./string-helpers.js";
import { validateRules } from "./ui-rules-validator.js";

export class TemplateParser {
    /**
     * The model that you bind to may by hidden by some object layers.
     * This allows simple field definition on the template but complex binding paths.
     * @param propertyPrefix
     */
    constructor() {
        this.parseTabSheetHandler = this.parseTabSheet.bind(this);
        this.parseGroupsHandler = this.parseGroups.bind(this);
        this.parseGroupHandler = this.parseGroup.bind(this);
        this.parsePanelBarHandler = this.parsePanelBar.bind(this);
        this.parseSplitViewHandler = this.parseSplitView.bind(this);
        this.parseInputHandler = this.parseInput.bind(this);
        this.parseDateHandler = this.parseDate.bind(this);
        this.parseDateTimeHandler = this.parseDateTime.bind(this);
        this.parseTextAreaHandler = this.parseTextArea.bind(this);
        this.parseButtonHandler = this.parseButton.bind(this);
        this.parseIconButtonHandler = this.parseIconButton.bind(this);
        this.parseElementsHandler = this.parseElements.bind(this);
        this.parseCheckboxHandler = this.parseCheckbox.bind(this);
        this.parseSelectHandler = this.parseSelect.bind(this);
        this.parseCardHandler = this.parseCard.bind(this);
        this.parseRadioHandler = this.parseRadio.bind(this);
        this.parseTemplateHandler = this.parseTemplate.bind(this);
        this.parseMasterDetailHandler = this.parseMasterDetail.bind(this);
        this.parseListHandler = this.parseList.bind(this);
        this.parseTreeHandler = this.parseTree.bind(this);
        this.parseReadonlyHandler = this.parseReadonly.bind(this);
        this.parseVisualizationHandler = this.parseVisualization.bind(this);
        this.parseHtmlTemplateHandler = this.parseHtmlTemplateHandler.bind(this);
        this.parseActionButtonHandler = this.parseActionButton.bind(this);
        this.parseGridHandler = this.parseGrid.bind(this);
        this.parseOverflowToolbarHandler = this.parseOverflowToolbar.bind(this);
        this.parseSvgSymbolHandler = this.parseSvgSymbol.bind(this);
        this.parseTreeListHandler = this.parseTreelist.bind(this);
        this.parseIconHandler = this.parseIcon.bind(this);

        this.parseMap = new Map();
        this.parseMap.set("tabsheet", this.parseTabSheetHandler);
        this.parseMap.set("groups", this.parseGroupsHandler);
        this.parseMap.set("group", this.parseGroupHandler);
        this.parseMap.set("panel-bar", this.parsePanelBarHandler);
        this.parseMap.set("split-view", this.parseSplitViewHandler);
        this.parseMap.set("input", this.parseInputHandler);
        this.parseMap.set("date", this.parseDateHandler);
        this.parseMap.set("dateTime", this.parseDateTimeHandler);
        this.parseMap.set("memo", this.parseTextAreaHandler);
        this.parseMap.set("button", this.parseButtonHandler);
        this.parseMap.set("icon-button", this.parseIconButtonHandler);
        this.parseMap.set("elements", this.parseElementsHandler);
        this.parseMap.set("checkbox", this.parseCheckboxHandler);
        this.parseMap.set("select", this.parseSelectHandler);
        this.parseMap.set("card", this.parseCardHandler);
        this.parseMap.set("radio", this.parseRadioHandler);
        this.parseMap.set("template", this.parseTemplateHandler);
        this.parseMap.set("master-detail", this.parseMasterDetailHandler);
        this.parseMap.set("tree", this.parseTreeHandler);
        this.parseMap.set("readonly", this.parseReadonlyHandler);
        this.parseMap.set("visualization", this.parseVisualizationHandler);
        this.parseMap.set("html-template", this.parseHtmlTemplateHandler);
        this.parseMap.set("action-button", this.parseActionButtonHandler);
        this.parseMap.set("grid", this.parseGridHandler);
        this.parseMap.set("tree", this.parseTreeHandler);
        this.parseMap.set("list", this.parseListHandler);
        this.parseMap.set("overflow-toolbar", this.parseOverflowToolbarHandler);
        this.parseMap.set("svg-symbol", this.parseSvgSymbolHandler);
        this.parseMap.set("treelist", this.parseTreeListHandler);
        this.parseMap.set("icon", this.parseIconHandler);
    }

    /**
     * @destructor
     */
    dispose() {
        this.variables = null;
        this.datasets = null;
        this.lookups = null;
        this.datasources = null;

        this.parseMap.clear();
        this.parseMap = null;

        this.parseTabSheetHandler = null;
        this.parseGroupsHandler = null;
        this.parseGroupHandler = null;
        this.parseSplitViewHandler = null;
        this.parsePanelBarHandler = null;
        this.parseInputHandler = null;
        this.parseTextAreaHandler = null;
        this.parseButtonHandler = null;
        this.parseIconButtonHandler = null;
        this.parseElementsHandler = null;
        this.parseCheckboxHandler = null;
        this.parseSelectHandler = null;
        this.parseCardHandler = null;
        this.parseRadioHandler = null;
        this.parseTemplateHandler = null;
        this.parseGridHandler = null;
        this.parseTreeHandler = null;
        this.parseListHandler = null;
        this.parseHtmlTemplateHandler = null;
        this.parseOverflowToolbarHandler = null;
        this.parseSvgSymbolHandler = null;
        this.parseTreeListHandler = null;
        this.parseIconHandler = null

        this.lookups = null;
        this.datasets = null;
        this.datasources = null;
        this.templates = null;
        this.perspectives = null;
        this.previews = null;
        this.actions = null;
        this.visualizations = null;
        this.contextMenuElements = null;
    }

    /**
     * Process the json template
     * @param schema: template structure to process
     * @returns {string} html result
     */
    parse(schema) {
        return new Promise(resolve => {
            this.initializeResources(schema);

            const result = this.parseObject(schema.body);

            schema.visualizations = this.visualizations;
            schema.contextMenuElements = this.contextMenuElements;

            if (this.datasets != null) {
                for (const dataset of this.datasets) {
                    this.markLookupFields(dataset);
                }
            }

            resolve(result);
        });
    }

    markLookupFields(dataset) {
        for (const field of dataset.fields) {
            if (field.lookup != null) {
                const lookup = this.lookups.find(x => x.id === field.lookup);
                if (lookup == null) continue;
                const lookupFields = Object.keys(lookup.mapping);
                const fieldsToUpdate = dataset.fields.filter(x => lookupFields.indexOf(x.name) !== -1);
                for (const fieldToUpdate of fieldsToUpdate) {
                    fieldToUpdate.lookupId = lookup.id;
                }
            }
        }
    }

    initializeResources(json) {
        this.lookups = json.lookups;
        this.datasets = json.datasets;
        this.datasources = json.datasources;
        this.templates = json.templates;
        this.perspectives = json.perspectives;
        this.previews = json.previews;
        this.variables = json.variables;
        this.actions = json.actions;
        this.uiRules = json.uiRules;

        this.datasetMap = new Map();
        this.indexDatasets("model", 0);

        this.visualizations = {};
        this.contextMenuElements = {}
    }

    indexDatasets(name, id) {
        if (this.datasets == undefined) {
            return;
        }

        const dataset = this.datasets.find(item => item.id == id);

        if (dataset == undefined) {
            return;
        }

        this.datasetMap.set(name, dataset);

        for (let field of dataset.fields) {
            if (field.dataset != undefined) {
                this.indexDatasets(`${name}.${field.name}`, field.dataset);
            }
        }
    }

    replaceVariableMarker(text) {
        if (text.indexOf("@") == -1) {
            return text;
        }

        return text.split("@").join("schema.variables.");
    }

    getVariableValue(path) {
        if (path[0] != "@") return path;
        if (this.variables == undefined) return undefined;
        path = path.split("@").join("");
        return getValueOnPath(this.variables, path);
    }

    /**
     * This function allows you to bind to a schema variable.
     * This assumes a pragma-form consumption path of schema.variables.variablename
     * @param varContent
     * @returns {*}
     */
    varToBiding(varContent) {
        if (varContent[0] == "@") {
            return `schema.variables.${varContent.slice(1)}`;
        }

        return varContent;
    }

    /**
     * This function allows you to bind to a schema variable as a content binding using ${schema.variables.variablename}
     * @param varContent
     * @returns {*}
     */
    varToContentBinding(varContent) {
        if (varContent == undefined) {
            return varContent;
        }

        if (varContent[0] == "@") {
            return '${' + `schema.variables.${varContent.slice(1)}}`;
        }

        return varContent;
    }

    /**
     * search fieldmap for a comparison key as defined by field
     * @param field
     * @returns {*}
     */
    getField(field, context) {
        if (context != undefined) {
            return this.varToBiding(`${context}.${field}`);
        }

        return this.varToBiding(field);
    }

    /**
     * Get the datasource witht he following id
     * @param id
     * @returns {null}
     */
    getDatasource(id) {
        if (isNaN(id)) {
            return id;
        }

        if (this.datasources == undefined || id == undefined) {
            return null;
        }

        const ds = this.datasources.find(ds => ds.id.toString() == id.toString());

        if (ds.field != undefined) {
            return ds.field;
        }

        return ds;
    }

    /**
     * Get a particular template by id
     * @param id
     * @returns {*}
     */
    getTemplate(id) {
        if (this.templates == undefined) {
            return null;
        }

        return this.templates.find(template => template.id.toString() == id.toString());
    }


    /**
     * Parse unknown object for particulars and navigate from here to more appropriate generators
     * @param obj: object to parse
     */
    parseObject(obj) {
        if (obj == null) return false;

        const properties = Object.keys(obj);
        const result = [];
        for (let property of properties) {
            const propertyObject = obj[property];

            if (this.isKnownType(property)) {
                result.push(this.parseKnown(property, propertyObject));
            }
            else {
                result.push(this.parseObject(propertyObject));
            }
        }

        return result.join("");
    }

    /**
     * Evaluate if this property is a known key for specific parsing
     * @param property
     * @returns {boolean}
     */
    isKnownType(property) {
        return this.parseMap.has(property);
    }

    /**
     * Get the parser for a particular property and process the given object with that parser
     * @param property: key for the parser to extract
     * @param obj: object that needs to be parsed
     * @returns {string} html result
     */
    parseKnown(property, obj) {
        return this.parseMap.get(property)(obj);
    }

    /**
     * Parse the object as a tabsheet and generage pragma-pager custom element html markup for it.
     * @param tabsheet: Tabsheet object, should be array of tabs
     * @return {string}
     */
    parseTabSheet(tabsheet) {
        const classes = this.processClasses(tabsheet);
        const attributes = this.processAttributes(tabsheet);

        const tabSheetButtonsHTML = this.parseTabSheetButtons(tabsheet.elements);
        const tabSheetPagesHTML = this.parseTabSheetPages(tabsheet.elements);

        const result = populateTemplate(tabsheetHtml, {
            "__classes__": classes,
            "__attributes__": attributes,
            "__tabSheetButtons__": tabSheetButtonsHTML,
            "__tabSheetPages__": tabSheetPagesHTML
        });

        return result;
    }

    /**
     * Parse array of objects as pager-button custom elements.
     * @param tabSheetButtons: array of objects to parse
     * @return {string}
     */
    parseTabSheetButtons(tabSheetButtons) {
        const result = [];

        for (const tabSheetButton of tabSheetButtons) {
            result.push(populateTemplate(tabSheetButtonHtml, {
                "__id__": tabSheetButton.id,
                "__title__": this.getVariableValue(tabSheetButton.title)
            }))
        }

        return result.join("");
    }

    /**
     * Parse array of objects as block elements (div) with class tabsheet-page.
     * The object should have the following properties
     * 1. id: unique identifier for the tab
     * 2. title: title to display at the top of the group
     * 3. groups: array of groups
     * @param tabSheetPages: array of objects to parse
     * @return {string}
     */
    parseTabSheetPages(tabSheetPages) {
        const result = [];

        for (let tabSheetPage of tabSheetPages) {
            const template = this.getTemplate(tabSheetPage.template);
            const content = this.parseElements(template.elements);

            result.push(populateTemplate(tabSheetPageHtml, {
                "__id__": tabSheetPage.id,
                "__title__": this.getVariableValue(tabSheetPage.title),
                "__content__": this.replaceVariableMarker(content)
            }))
        }

        return result.join("");
    }

    /**
     * Remove all relative path markup from string
     * @param path
     * @returns {string}
     */
    cleanRelative(path) {
        return path.split("../").join("");
    }

    /**
     * Parse a object as a group.
     * The object is expected to be an array of groups.
     * Each group must have the following fields:
     * 1. title: string to display as title of the group
     * 2. items: array fields that must be rendered. see parseElements
     * @param obj: object to parse
     */
    parseGroups(groups) {
        const result = [];
        for (let group of groups) {
            result.push(this.parseGroup(group));
        }
        return result.join("");
    }

    /**
     * Parse a single group and it's content
     * @param element
     * @returns {*}
     */
    parseGroup(element) {
        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);
        const fieldsHtml = this.parseElements(element.elements);
        const actionsHtml = this.parseElements(element.actions);
        return populateTemplate(groupHtml, {
            "__title__": this.getVariableValue(element.title),
            "__actions__": actionsHtml,
            "__content__": fieldsHtml,
            "__attributes__": attributes,
            "__classes__": classes
        });
    }

    /**
     * Parse a panel bar and it's content
     * @param element
     * @returns {*}
     */
    parsePanelBar(element) {
        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);
        const fieldsHtml = this.parseElements(element.elements);
        const actionsHtml = this.parseElements(element.actions);
        return populateTemplate(panelBarHtml, {
            "__title__": this.getVariableValue(element.title),
            "__content__": fieldsHtml,
            "__actions__": actionsHtml,
            "__attributes__": attributes,
            "__classes__": classes
        });
    }

    /**
     * Parse a panel bar and it's content
     * @param element
     * @returns {*}
     */
    parseSplitView(element) {
        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);
        const leftHtml = this.parseElements(element.left);
        const rightHtml = this.parseElements(element.right);
        return populateTemplate(splitViewHtml, {
            "__left__": leftHtml,
            "__right__": rightHtml,
            "__attributes__": attributes,
            "__classes__": classes,
            "__id__": element.id || ""
        });
    }

    /**
     * Parse a object as a input type
     * The object must contain the following fields:
     * 1. element: used to determine how to process the input type
     * @param obj
     */
    parseElements(elements, context) {
        if (!elements) {
            return "";
        }

        const result = [];

        for (let element of elements) {
            if (element.uiRule != null) {
                const uiRule = this.uiRules.find(_ => _.id === element.uiRule);
                if (uiRule != null && validateRules(uiRule.rules) === false) continue;
            }

            if (element.contextMenu != null) {
                this.validateAndSaveId(element, this.contextMenuElements);
            }

            result.push(this.parseElement(element, context));
        }

        return result.join("");
    }

    // Todo (JN): Validations to be added to the checkbox element 
    /**
     * Parse checkbox
     * @param element
     * @returns {*}
     */
    parseCheckbox(element, context) {
        const title = this.getVariableValue(element.title);
        const field = this.getField(element.field, context);
        const description = element.description || "";
        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);

        return populateTemplate(checkboxHtml, {
            "__field__": field,
            "__title__": title,
            "__description__": description,
            "__classes__": classes,
            "__attributes__": attributes
        });

    }

    /**
     * Parse a individual element and generate the direct it to the appropriate generateor
     * The object being parsed must have the following fields:
     * 1. element
     * @param element: object to parse
     */
    parseElement(element, context) {
        const elementType = element.element;
        if (this.isKnownType(elementType)) {
            return this.parseMap.get(elementType)(element, context);
        }
        else {
            return this.parseUnknown(element, context);
        }
    }

    /**
     * Parse element on a dynamic level interpreting custom elements
     * @param element
     */
    parseUnknown(element) {
        if (element.extends != null && this[`parse${capitialize(element.extends)}`]) {
            return this[`parse${capitialize(element.extends)}`](element);
        }
        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);
        const content = this.varToContentBinding(element.content) || this.parseElements(element.elements);


        return populateTemplate(dynamicHtml, {
            "__tagname__": element.element,
            "__classes__": classes,
            "__attributes__": attributes,
            "__content__": this.replaceVariableMarker(content),
        });
    }

    /**
     * Parse attributes defined in template to be part of the html
     * @param obj
     * @return {string}
     */
    processAttributes(obj) {
        const attributes = [];

        if (obj.attributes) {
            const attrKeys = Object.keys(obj.attributes);
            for (let attrKey of attrKeys) {
                const attrValue = obj.attributes[attrKey];
                const value = attrKey.indexOf(".bind") != -1 ? this.varToBiding(attrValue) : this.varToContentBinding(obj.attributes[attrKey]);
                attributes.push(`${attrKey}="${value}"`);
            }
        }

        return attributes.join(" ");
    }

    /**
     * Process style classes
     * @param obj
     * @return {*}
     */
    processClasses(obj) {
        if (obj.styles) {
            if (Array.isArray(obj.styles)) {
                return `class="${obj.styles.join(" ")}"`;
            }

            return `class="${obj.styles}"`;
        }

        return "";
    }

    /**
     * Parse the object as a input composite
     * Properties that should be supplied are:
     * 1. title
     * 2. field
     * 3. type
     *
     * Additional properties you can define are:
     * 1. attributes: object literal
     * 2. classes: array of string
     * 3. descriptor
     *
     * Items that are lookup items must have the attribute "data-lookup" defined
     * @param input
     */
    parseInput(input, context) {
        let field = this.getField(input.field, context);
        const title = this.getVariableValue(input.title);
        const validationBehaviours = this._getValidationBehavioursByField(field);

        const required = input.required || false;
        const classes = this.processClasses(input);
        const attributes = this.processAttributes(input);
        const descriptor = this.getDescriptor(input);
        const lookup = this.getLookup(input, context);
        const peek = this.getPeek(input, context);
        let tableBinding = "";

        if (lookup.length > 0) {
            const path = this.getTablePath(input, context);
            tableBinding = `model.bind="${path}"`
        }

        let result = populateTemplate(inputHtml, {
            "__peek__": peek || "",
            "__model__": tableBinding,
            "__lookup__": lookup,
            "__field__": field,
            "__title__": title,
            "__description__": descriptor,
            "__classes__": classes,
            "__attributes__": attributes,
            "__required__": required,
            "__behaviours__": validationBehaviours
        });

        return result;
    }

    parseDateTime(dateTime, context) {
        let field = this.getField(dateTime.field, context);
        const title = this.getVariableValue(dateTime.title);
        const validationBehaviours = this._getValidationBehavioursByField(field);

        const required = dateTime.required || false;
        const classes = this.processClasses(dateTime);
        const attributes = this.processAttributes(dateTime);
        const descriptor = this.getDescriptor(dateTime);
        let tableBinding = "";

        if (lookup.length > 0) {
            const path = this.getTablePath(dateTime, context);
            tableBinding = `model.bind="${path}"`
        }


        let result = populateTemplate(dateTimeHtml, {
            "__peek__": peek || "",
            "__model__": tableBinding,
            "__lookup__": lookup,
            "__field__": field,
            "__title__": title,
            "__description__": descriptor,
            "__classes__": classes,
            "__attributes__": attributes,
            "__required__": required,
            "__behaviours__": validationBehaviours
        });

        return result;
    }

    parseDate(date, context) {
        let field = this.getField(date.field, context);
        const title = this.getVariableValue(date.title);
        const validationBehaviours = this._getValidationBehavioursByField(field);

        const required = date.required || false;
        const classes = this.processClasses(date);
        const attributes = this.processAttributes(date);
        const descriptor = this.getDescriptor(date);
        let tableBinding = "";

        if (lookup.length > 0) {
            const path = this.getTablePath(date, context);
            tableBinding = `model.bind="${path}"`
        }


        let result = populateTemplate(dateHtml, {
            "__peek__": peek || "",
            "__model__": tableBinding,
            "__lookup__": lookup,
            "__field__": field,
            "__title__": title,
            "__description__": descriptor,
            "__classes__": classes,
            "__attributes__": attributes,
            "__required__": required,
            "__behaviours__": validationBehaviours
        });

        return result;
    }

    getValidationBehaviours(validation) {
        if (validation == undefined) {
            return "";
        }

        const result = [];

        const keys = Object.keys(validation);
        keys.forEach(key => {
            if (key != "null") {
                let str = validationsMap.get(key);
                const value = validation[key].value;

                if (value != undefined) {
                    str = str.split("__value__").join(value)
                }
                result.push(str);
            }
        })

        return result.join(",");
    }

    /**
     * Returns the validation behaviours for the field from the dataset
     * @param field: dataset field
     * @returns {string}: validation behaviours
     * @private
     */
    _getValidationBehavioursByField(field) {
        const pathParts = field.split(".");
        const modelKey = pathParts[0];
        const fieldName = pathParts[1];

        let validationBehaviours = "";

        const ds = this.datasetMap.get(modelKey);
        if (ds != null) {
            const fieldDef = ds.fields.find(item => item.name === fieldName);
            validationBehaviours = this.getValidationBehaviours(fieldDef.validations);
            if (validationBehaviours.length > 0) {
                return `behaviours="${validationBehaviours}"`;
            }
        }
    }

    getLookup(field, context) {
        const path = context == undefined ? field.field : `${context}.${field.field}`;
        const items = path.split(".");
        const fld = items.splice(items.length - 1, 1);

        const modelKey = items.join(".");
        if (modelKey.length == "") {
            return "";
        }

        const model = this.datasetMap.get(modelKey);
        if (model == undefined) {
            return "";
        }

        const lookupField = model.fields.find(item => item.name == fld);
        if (lookupField == undefined) {
            return "";
        }

        if (lookupField.lookup == undefined) {
            return "";
        }

        return `lookup="${lookupField.name}"`;
    }

    getPeek(field, context) {
        const path = context == undefined ? field.field : `${context}.${field.field}`;
        const items = path.split(".");
        const fld = items.splice(items.length - 1, 1);

        const modelKey = items.join(".");
        if (modelKey.length == "") {
            return "";
        }

        const model = this.datasetMap.get(modelKey);
        if (model == undefined) {
            return "";
        }

        const peekField = model.fields.find(item => item.name == fld);
        if (peekField == undefined) {
            return "";
        }

        if (peekField.preview == undefined) {
            return "";
        }

        const preview = this.previews.find(item => item.id == peekField.preview);
        if (preview == undefined) {
            return "";
        }

        if (preview["dataset-field"] == undefined) {
            return "";
        }

        return `peek="${peekField.name}"`;
    }

    getTablePath(field, context) {
        const path = context == undefined ? field.field : `${context}.${field.field}`;
        const items = path.split(".");
        items.splice(items.length - 1, 1);

        const modelKey = items.join(".");
        return modelKey;
    }

    parseReadonly(element, context) {
        const title = this.getVariableValue(element.title);
        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);
        const field = this.getField(element.field, context);

        let result = populateTemplate(readOnlyHtml, {
            "__field__": `${field}_readonly`,
            "__content__": "${" + field + "}",
            "__title__": title,
            "__classes__": classes,
            "__attributes__": attributes
        });

        return result;
    }

    /**
     * Parse a given schema element and determine if the descriptor should use binding or string constant values
     * @param element: element to process
     * @returns : string value for descriptor
     */
    getDescriptor(element) {
        const description = element.description || "";
        let descriptor = element.descriptor || "";

        // Nothing set return descriptor empty context
        if (description.length === 0) {
            return "descriptor=''";
        }

        // description set so return binding expression
        if (description.length > 0) {
            return `descriptor.bind="${description}"`;
        }

        // descriptor used so send back descriptor text with out binding
        return `descriptor="${descriptor}"`;
    }

    /**
     * Parse the object as a textarea composite
     * Properties that should be supplied are:
     * 1. title
     * 2. field
     *
     * Additional properties you can define are:
     * 1. attributes: object literal
     * 2. classes: array of string
     * 3. descriptor
     *
     * @param textarea
     */
    parseTextArea(memo, context) {
        const title = this.getVariableValue(memo.title);
        const field = this.getField(memo.field, context);
        const description = memo.descriptor || "";
        const required = memo.required || false;
        const classes = this.processClasses(memo);
        const attributes = this.processAttributes(memo);

        const validationBehaviours = this._getValidationBehavioursByField(field);

        let descriptor = memo.descriptor || "";

        if (description.length > 0) {
            descriptor = `descriptor.bind="${description}"`
        }
        else {
            descriptor = `descriptor="${descriptor}"`
        }

        return populateTemplate(textareaHtml, {
            "__field__": field,
            "__title__": title,
            "__description__": descriptor,
            "__classes__": classes,
            "__attributes__": attributes,
            "__required__": required,
            "__behaviours__": validationBehaviours
        });
    }

    /**
     * Parse object as button
     * Properties that should be provided:
     * 1. title
     * 2. action
     * @param button
     * @return {*}
     */
    parseButton(button) {
        const title = this.getVariableValue(button.title);
        const attributes = this.processAttributes(button);
        const classes = this.processClasses(button);

        let action;
        if (button.process != undefined) {
            action = `performProcess(${button.process})`;
        }
        else {
            action = `performAction(${button.action}, ${button.closeDialog || false}, args)`;
        }

        return populateTemplate(buttonHtml, {
            "__title__": title,
            "__action__": action,
            "__classes__": classes,
            "__attributes__": attributes
        });
    }

    parseActionButton(button) {
        const title = this.getVariableValue(button.title);
        const attributes = this.processAttributes(button);
        const classes = this.processClasses(button);
        let actionId = "";

        let action;
        if (button.process != undefined) {
            action = `performProcess(${button.process})`;
        }
        else {
            action = `performAction(${button.action}, ${button.closeDialog || false}, args)`;
        }

        const act = (this.actions || []).find((item) => item.id == button.action);
        if (act != null && act.parameters != null) {
            actionId = act.parameters["activity-id"];
        }

        return populateTemplate(actionButtonHtml, {
            "__title__": title,
            "__action__": action,
            "__classes__": classes,
            "__attributes__": attributes,
            "__activityId__": `activity-id="${actionId}"`
        });
    }

    /**
     * Parse object as icon-button
     * Properties that should be provided:
     * 1. icon
     * 2. action
     * 3. label
     * @param iconButton
     * @return {*}
     */
    parseIconButton(iconButton) {
        const icon = this.varToContentBinding(iconButton.icon);
        const label = this.varToContentBinding(iconButton.label);
        const attributes = this.processAttributes(iconButton);
        const classes = this.processClasses(iconButton);

        let action;
        if (iconButton.process != undefined) {
            action = `performProcess(${iconButton.process})`;
        }
        else {
            action = `performAction(${iconButton.action}, ${iconButton.closeDialog || false}, args)`;
        }

        return populateTemplate(iconButtonHtml, {
            "__icon__": icon,
            "__label__": label,
            "__action__": action,
            "__classes__": classes,
            "__attributes__": attributes
        });
    }


    // Todo (JN): Validations to be added to the select element 
    /**
     * Parse select options and fill in as per datasource definitions
     * @param select
     */
    parseSelect(select) {
        const title = this.getVariableValue(select.title);
        const datasource = select.datasource;
        const field = this.varToBiding(select.field);
        const classes = this.processClasses(select);
        const attributes = this.processAttributes(select);
        const required = select.required || false;
        const descriptor = this.getDescriptor(select);
        let content = "";

        const ds = this.getDatasource(datasource);

        if (ds == null || ds == undefined) {
            console.error(`select "${title}"'s datasource does not exist in schema`);
            return "";
        }

        if (typeof ds == "string" || ds.field != undefined) {
            const repeatField = ds.field || ds;

            content = populateTemplate(selectRepeatOption, {
                "__datasource__": repeatField,
                "__content__": "${title}"
            })
        }
        else {
            if (!Array.isArray(ds.resource)) {
                console.error(`resouce was expected to be an array for ${title}`);
                return "";
            }

            for (let resource of ds.resource) {
                const id = resource.id;
                const title = this.varToContentBinding(resource.title);

                content = content + populateTemplate(selectOption, {
                    "__option-id__": id,
                    "__content__": title
                })
            }
        }

        let result = populateTemplate(selectHtmlForDefinedOptions, {
            "__field__": field,
            "__title__": this.getVariableValue(title),
            "__classes__": classes,
            "__attributes__": attributes,
            "__required__": required == true ? required : "",
            "__description__": descriptor,
            "__content__": content,
            "__datasource__": datasource
        });

        return result;
    }

    /**
     * Parse card schema
     * @param card
     * @returns {*}
     */
    parseCard(card) {
        const content = this.parseElements(card.elements);
        return populateTemplate(cardHtmlTemplate, {
            "__content__": content
        })
    }

    // Todo (JN): Validations to be added to the radio button 
    /**
     * Parse radio schema and datasource options
     * @param radio
     * @returns {string}
     */
    parseRadio(radio) {
        const datasource = radio.datasource;
        const field = this.varToBiding(radio.field);
        const classes = this.processClasses(radio);
        const attributes = this.processAttributes(radio);
        let content = "";


        const ds = this.getDatasource(datasource);

        if (ds == null || ds == undefined) {
            console.error(`radio's datasource does not exist in schema`);
            return "";
        }

        if (ds.field != undefined) {
            content = populateTemplate(radioRepeatOptions, {
                "__datasource__": ds.field,
                "__content__": "${title}",
                "__groupname__": ds.id,
                "__field__": field
            })
        }
        else {
            if (!Array.isArray(ds.resource)) {
                console.error(`radio's resouce was expected to be an array`);
                return "";
            }

            for (let resource of ds.resource) {
                const id = resource.id;
                const title = this.varToContentBinding(resource.title);

                content = content + populateTemplate(radioOption, {
                    "__option-id__": id,
                    "__content__": this.replaceVariableMarker(title),
                    "__groupname__": ds.id,
                    "__field__": field
                })
            }
        }

        const group = populateTemplate(radioGroup, {
            "__content__": content,
            "__classes__": classes,
            "__attributes__": attributes
        });

        return group;
    }

    /**
     * Parse template
     * @param tmpl
     * @returns {*}
     */
    parseTemplate(tmpl) {
        const id = tmpl.template;
        const condition = this.conditionToVarBinding(tmpl.condition);
        const template = this.getTemplate(id);
        const context = tmpl.context;
        const classes = this.processClasses(tmpl);

        if (template == null) {
            console.error(`template with id ${id} was not found`);
            return ""
        }

        const content = this.parseElements(template.elements, context);

        let startTag = `<div if.bind="__condition__" data-template="${id}" ${classes}>`;
        const endTag = "</div>";

        if (condition.length == 0) {
            startTag = startTag.replace('if.bind="__condition__"', "");
        }
        else {
            startTag = startTag.replace('__condition__', condition);
        }

        return `${startTag}${content}${endTag}`;
    }

    conditionToVarBinding(condition) {
        if (condition == undefined) {
            return "";
        }

        const parts = condition.split(" ");
        parts[0] = this.varToBiding(parts[0]);
        return parts.join(" ");
    }

    parseMasterDetail(md) {
        const master = md.master;
        const detail = md.detail;

        const masterContent = this.parseElements(master);
        const detailContent = this.parseElements(detail);

        const classes = this.processClasses(md);
        const attributes = this.processAttributes(md);

        const result = populateTemplate(masterDetailHtml, {
            "__classes__": classes,
            "__attributes__": attributes,
            "__master__": masterContent,
            "__detail__": detailContent
        });

        return result;
    }

    parseVisualization(element) {
        const datasourceId = element.datasource;
        const datasource = this.getDatasource(datasourceId);
        const perspective = element.perspective;
        const view = element.view;
        const template = this.perspectives.find(item => item.id == perspective).views.find(item => item.id == view).template;

        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);

        const templateBinding = template == undefined ? "" : `template.bind="template(${template})"`;

        const result = populateTemplate(visualizationTemplate, {
            "__classes__": classes,
            "__attributes__": attributes,
            "__datasource__": datasource,
            "__perspective__": perspective,
            "__view__": view,
            "__template__": templateBinding
        });

        return result;
    }

    parseHtmlTemplateHandler(element) {
        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);
        const fieldsHtml = this.parseElements(element.elements);

        return populateTemplate(htmlTemplateHtml, {
            "__content__": fieldsHtml,
            "__attributes__": attributes,
            "__classes__": classes
        });
    }

    parseColumns(columns) {
        let elements = [];
        for (const column of columns) {
            const classes = this.processClasses(column);
            const attributes = this.processAttributes(column);
            const formatters = this.parseFormatters(column.formatters || []);
            const content = this.parseElements(column.elements);
            const result = populateTemplate(gridColumnTemplate, {
                "__field__": column.field == null ? "" : `field="${column.field}"`,
                "__title__": this.getVariableValue(column.title),
                "__width__": column.width || 200,
                "__attributes__": attributes,
                "__classes__": classes,
                "__formatters__": formatters,
                "__content__": content
            });
            elements.push(result);
        }
        return elements.join("");
    }

    parseColumnGroups(columnGroups) {
        if (columnGroups == null) return "";

        let elements = ["<header-groups>"];
        for (const column of columnGroups) {
            const title = column.title == null ? "" : `title="${this.getVariableValue(column.title)}"`;
            elements.push(`<group ${title} count="${column.count}"></group>`);
        }

        elements.push("</header-groups>");
        return elements.join("");
    }

    parseFormatters(formatters) {
        let elements = [];
        for (const formatter of formatters) {
            const classes = this.processClasses(formatter);
            const attributes = this.processAttributes(formatter);

            const properties = this.parseFormatterProperties(formatter.properties || {});
            const result = populateTemplate(formatterTemplate, {
                "__condition__": formatter.condition || "",
                "__attributes__": attributes,
                "__classes__": classes,
                "__style-property__": properties[0],
                "__value__": properties[1]
            });
            elements.push(result)
        }
        return elements;
    }

    parseFormatterProperties(properties) {
        const styles = [];
        const values = [];
        for (const key of Object.keys(properties)) {
            styles.push(key)
            values.push(properties[key])
        }
        return [styles.join(","), values.join(",")];
    }

    parseGrid(element) {
        if (this.validateAndSaveId(element, this.visualizations) === false) return;

        const datasourceId = element.datasource;
        const datasource = this.getDatasource(datasourceId);

        const columnGroups = this.parseColumnGroups(element["column-groups"]);
        const columns = this.parseColumns(element.columns);

        const formatters = this.parseFormatters(element.formatters || []);

        const classes = this.processClasses(element);
        this.setStateTrackingAttribute(element);
        const attributes = this.processAttributes(element);

        const content = element.elements != null ? this.parseElements(element.elements) : "";

        const result = populateTemplate(gridTemplate, {
            "__datasource__": this.replaceVariableMarker(datasource),
            "__classes__": classes,
            "__attributes__": attributes,
            "__formatters__": formatters.join(""),
            "__columngroups__": columnGroups,
            "__columns__": columns,
            "__selection__": element.selection || "",
            "__perspective__": this.parsePerspective(element.perspective),
            "__id__": element.id,
            "__selected-id__": element.selectedId,
            "__content__": content
        });

        return this.parseExtends(element, result, "pragma-advanced-grid");
    }

    parseExtends(element, template, originalName) {
        if (element.extends != null) {
            return template.replace(originalName, element.element);
        }
        return template;
    }

    setStateTrackingAttribute(element) {
        element.attributes = element.attributes || {};
        element.attributes["data-state-tracking"] = true;
    }

    parsePerspective(perspective) {
        if (perspective != null) {
            return `perspective=${perspective}`;
        }
        return "";
    }

    parseList(element) {
        if (this.validateAndSaveId(element, this.visualizations) === false) return;

        const datasourceId = element.datasource;
        const datasource = this.getDatasource(datasourceId);

        const templates = this.parseTemplates(element.templates);

        const formatters = this.parseFormatters(element.formatters || []);

        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);

        const result = populateTemplate(listTemplate, {
            "__datasource__": this.replaceVariableMarker(datasource),
            "__classes__": classes,
            "__attributes__": attributes,
            "__formatters__": formatters.join(""),
            "__templates__": templates,
            "__selection__": element.selection || "",
            "__typeRef__": element.typeRef || "",
            "__titleRef__": element.titleRef || "",
            "__expandRef__": element.expandRef || "",
            "__perspective__": this.parsePerspective(element.perspective),
            "__selected-id__": element.selectedId,
            "__id__": element.id
        });

        return this.parseExtends(element, result, "pragma-advanced-list");
    }

    parseTree(element) {
        if (this.validateAndSaveId(element, this.visualizations) === false) return;

        const datasourceId = element.datasource;
        const datasource = this.getDatasource(datasourceId);

        const templates = this.parseTemplates(element.templates);

        const formatters = this.parseFormatters(element.formatters || []);

        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);

        const result = populateTemplate(treeTemplate, {
            "__datasource__": this.replaceVariableMarker(datasource),
            "__classes__": classes,
            "__attributes__": attributes,
            "__formatters__": formatters.join(""),
            "__templates__": templates,
            "__selection__": element.selection || "",
            "__typeRef__": element.typeRef || "",
            "__titleRef__": element.titleRef || "",
            "__expandRef__": element.expandRef || "",
            "__perspective__": this.parsePerspective(element.perspective),
            "__selected-id__": element.selectedId,
            "__id__": element.id
        });

        return this.parseExtends(element, result, "pragma-advanced-tree");
    }

    parseTreelist(element) {
        if (this.validateAndSaveId(element, this.visualizations) === false) return;
        const datasourceId = element.datasource;
        const datasource = this.getDatasource(datasourceId);
        const columns = this.parseColumns(element.columns);
        const columnGroups = this.parseColumnGroups(element["column-groups"]);
        const formatters = this.parseFormatters(element.formatters || []);
        const classes = this.processClasses(element);
        const attributes = this.processAttributes(element);
        const content = element.elements != null ? this.parseElements(element.elements) : "";

        const result = populateTemplate(treeListTemplate, {
            "__datasource__": this.replaceVariableMarker(datasource),
            "__classes__": classes,
            "__attributes__": attributes,
            "__formatters__": formatters.join(""),
            "__columngroups__": columnGroups,
            "__columns__": columns,
            "__id__": element.id,
            "__content__": content
        });

        return this.parseExtends(element, result, "pr-advanced-treelist");
    }

    parseOverflowToolbar(toolbar) {
        const action = toolbar.action == null ? "" : `selected.delegate="performAction(${toolbar.action}, null, args)"`;
        const options = toolbar.options;
        const count = toolbar.buttonCount || null;

        const contentArray = [];
        for (let option of options) {
            const title = this.getVariableValue(option.title);
            const action = option.action;
            const attributes = this.processAttributes(option);
            contentArray.push(`<item id="${option.id}" icon-name="${option["icon-name"]}" title="${title}" action="${action == null ? -1 : action}" ${attributes == null ? "" : attributes}></item>`)
        }
        const content = contentArray.join("");

        return populateTemplate(overflowToolbarTemplate, {
            "__action__": action,
            "__content__": content,
            "__count__": count == null ? "" : `button-count="${count}"`
        });
    }

    parseTemplates(conditionalTemplates) {
        if (conditionalTemplates == null) return "";
        let elements = [];
        for (const id of conditionalTemplates) {
            const template = this.getTemplate(id);
            const content = this.parseHtmlTemplateHandler(template);
            elements.push(content);
        }
        return elements.join("");
    }

    parseSvgSymbol(svg) {
        return populateTemplate(svgSymbol, {
            "__name__": svg.name
        })
    }

    parseIcon(icon) {
        const classes = this.processClasses(icon);
        const attributes = this.processAttributes(icon);
        const result = populateTemplate(`<pragma-icon icon="__icon__" __classes__ __attributes__></pragma-icon>`, {
            "__icon__": icon.icon,
            "__attributes__": attributes,
            "__classes__": classes
        });
        return result;
    }

    /**
     * Used to store the ids in array
     * @param element - Schema element to be validated
     * @param array - Array to store value in
     * @returns {boolean}
     */
    validateAndSaveId(element, store) {
        if (element.id == null) {
            console.error(`The ${element.element} requires a id property to function correctly`, element);
            return false;
        }
        store[element["id"]] = element;
        return true;
    }
}
