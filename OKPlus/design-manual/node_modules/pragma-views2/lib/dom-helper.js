import {isMobile} from './device-helper.js';

/**
 * Find a element where dragging is started and ensure that it matches the given query
 * @param event
 * @param selectQuery
 * @returns {*}
 */
export function getEventTarget(event, selectQuery) {
    let x = 0;
    let y = 0;

    if (isMobile()) {
        x = event.touches[0].clientX;
        y = event.touches[0].clientY;
    } else {
        x = event.clientX;
        y = event.clientY;
    }

    const topElement = document.elementFromPoint(x, y);

    if (selectQuery && !topElement.matches(selectQuery)) {
        return null;
    }

    return topElement;
}

/**
 * Given a element check if it is on top of a li element and if it is pass back that li
 * @param element
 * @returns {*}
 */
export function findParentLi(element) {
    return findParentOfType(element, "LI");
}

/**
 * Get a li that you want to drag given a query to determine if the target touch point is valid
 * @param event
 * @param event
 * @returns {*}
 */
export function getValidLi(event, selectQuery) {
    const topElement = getEventTarget(event, selectQuery);
    return findParentLi(topElement);
}

/**
 * Create a highlight rect that is the same size as the given element
 * @param element
 */
export function createHighlightFor(dimentions) {
    const highlight = document.createElement("DIV");
    highlight.classList.add('highlight');
    setStyleDimentions(highlight, dimentions);

    return highlight;
}

/**
 * Update a style with the top, left, right and bottom properties of a bounding rect
 * @param element
 * @param dimentions
 */
export function setStyleDimentions(element, dimentions) {
    element.style.setProperty("--left", dimentions.left);
    element.style.setProperty("--top", dimentions.top);
    element.style.setProperty("--width", dimentions.width);
    element.style.setProperty("--height", dimentions.height);
}

/**
 * Find a element that has a particular classname in it's class attribute.
 * @param element
 * @param className
 * @param stopAtNodeName - Optional nodeName of parent element to stop searching
 * @returns {null|undefined|*|null|*}
 */
export function findParentWithClass(element, className, stopAtNodeName) {
    if (!element) {
        return null;
    }

    if (stopAtNodeName != null && element.nodeName.toLowerCase() === stopAtNodeName) return;

    if (element.classList.contains(className)) {
        return element;
    }

    return findParentWithClass(element.parentElement, className, stopAtNodeName);
}

/**
 * Find parent that is of a particular type
 * @param element {HTMLElement} element to start search on
 * @param nodeName {string} element tagname to search for
 * @param stopAtNodeName - Optional nodeName of parent element to stop searching
 * @returns {null|undefined|*|null|*}
 */
export function findParentOfType(element, nodeName, stopAtNodeName) {
   
    if (element == null) {
        return null;
    }

    if (stopAtNodeName != null && element.nodeName.toLowerCase() === stopAtNodeName) return;

    if (element.nodeName.toLowerCase() === nodeName.toLowerCase()) {
        return element;
    }

    return findParentOfType(element.parentElement, nodeName, stopAtNodeName);
}

/**
 * Find parent that is an instance of a particular type
 * @param element
 * @param instanceName
 * @returns element
 */
export function findParentOfInstance(element, instanceName) {
    if (element == null) return null;

    if (element.parentElement != null && element.parentElement instanceof instanceName) {
        return element.parentElement;
    }

    return findParentOfInstance(element.parentElement, instanceName);
}

/**
 *
 * @param tag: element tag
 * @param classes: array of string
 * @param attributes: {name: "attributename", value: "attributevalue"}
 */
export function createElement(tag, classes, attributes, content, role, styles) {
    const el = document.createElement(tag);

    if (classes != null && classes != null) {
        for (let cls of classes) {
            el.classList.add(cls);
        }
    }

    if (attributes != null && attributes != null) {
        for (let attr of attributes) {
            el.setAttribute(attr.name, attr.value);
        }
    }

    if (content != null && content != null) {
        el.innerText = content;
    }

    if (role != null && role != null) {
        el.setAttribute("role", role)
    }

    if (styles != null) {
        for (let style of styles) {
            el.style[style.name] = style.value;
        }
    }

    return el;
}

export function createFullPageLayer() {
    let layer = document.querySelector("#dialog-layer");
    if (layer != undefined) {
        return layer;
    }

    layer = document.createElement("div");
    layer.id = "dialog-layer";

    const main = document.querySelector("[role='main'] > .main");
    main.appendChild(layer);
    return layer;
}

export function disposeFullPageLayer() {
    const layer = document.querySelector("#dialog-layer");

    if (layer != undefined) {
        while (layer.firstChild) {
            layer.children.remove(layer.firstChild);
        }

        layer.parentElement.removeChild(layer);
    }
}

/**
 * Add class to element if does not exist or removes class from element if it exists
 * @param element
 * @param className
 */
export function toggleClass(element, className) {
    if (element.classList.contains(className) === true) {
        element.classList.remove(className);
    } else {
        element.classList.add(className);
    }
}

/**
 * This function returns the left,top and width of element. It performs better than getBoundingClientRect, but will not return the correct values when CSS scaling is applied.
 * @param target
 * @returns {{top: number, left: number, width: number}}
 */
export function getElementBounds(target) {
    let left = 0;
    let top = 0;
    const width = target.offsetWidth;
    const height = target.offsetHeight;

    while (target) {
        left += (target.offsetLeft - target.scrollLeft + target.clientLeft);
        top += (target.offsetTop - target.scrollTop + target.clientTop);
        target = target.offsetParent;
    }
    return {left, top, width, height};
}

export function createSvg(id, width = 24, height = 24) {
    const xmlns = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(xmlns, "svg");
    svg.setAttributeNS(null, "viewBox", `0 0 ${width} ${height}`);
    svg.setAttributeNS(null, "aria-hidden", "#__isBusy != true || false");
    const use = document.createElementNS(xmlns, "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", `#${id}`);
    svg.appendChild(use);
    return svg;
}

/**
 * Returns exact position of event.
 * @param event - event object
 * @returns {{x: number, y: number}}
 */
export function getEventPosition(event) {
    let point = {x: 0, y: 0};

    if (event == null) {
        event = window.event;
    }

    if (event.pageX || event.pageY) {
        point.x = event.pageX;
        point.y = event.pageY;
    } else if (event.clientX || event.clientY) {
        point.x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        point.y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }

    return point;
}

/**
 * Returns the elements position with respect of the windows bounds from a specific point
 * @param element
 * @param point - {{x: number, y: number}}
 * @returns {{x: number, y: number}}
 */
export function getElementPositionFromPoint(element, point) {
    const x = ((window.innerWidth - point.x) < element.offsetWidth) ? window.innerWidth - element.offsetWidth : point.x;
    const y = ((window.innerHeight - point.y) < element.offsetHeight) ? window.innerHeight - element.offsetHeight : point.y;

    return {x: x, y: y};
}

/**
 * Set the rectangle position and dimentions based on a given rect.
 * @param element
 * @param rect
 */
export function setElementAbsolute(element, rect) {
    element.style.position = "absolute";
    element.style.top = 0;
    element.style.left = 0;
    element.style.width = `${rect.width}px`;
    element.style.height = `${rect.height}px`;
    element.style.transform = `translate(${rect.left}px, ${rect.top}px)`;
}

/**
 * Get the index of a given element.
 * @param element
 * @returns {number}
 */
export function getElementIndex(element) {
    const children = Array.from(element.parentElement.children);
    return children.indexOf(element);
}

/**
 * Clear all child elements.
 * @param {Element} element thats child elements will be cleared.
 */
export function clearChildElements(element) {
    while(element.firstElementChild != null) {
        element.removeChild(element.firstElementChild);
    }
}

function createDocumentFragment() {
    return document.createDocumentFragment();
}

const domHelper = {
    findParentWithClass,
    createElement,
    createDocumentFragment
}

export {domHelper}