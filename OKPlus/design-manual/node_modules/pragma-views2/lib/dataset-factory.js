import {DataSet} from './dataset.js';
import {SchemaHelper} from "./schema-helper.js";
import {observe, addTriggers} from "../baremetal/lib/binding/observers.js";
import {getValueOnPath} from "../baremetal/lib/objectpath-helper.js";
import {DataSourceBase} from "./datasource-base.js";
import {createDatasourceFromDefinition} from "./datasource-utils.js";


export class DatasetFactory {

    constructor(options) {
        this.schema = options.schema;
        this.callback = options.callback;
        this.remoteDsCallback = options.remoteDsCallback;
        this.remoteCallback = options.remoteCallback;
        this.fetchRecordCallback = options.fetchRecordCallback;
        this.schemaHelper = new SchemaHelper(this.schema);
        this.getLookupRecordsHandler = this.getLookupRecords.bind(this);
        window.eventEmitter.on("datasource-records:get", this.getLookupRecordsHandler);
        this.draft = options.draft;
    }

    dispose() {
        window.eventEmitter.remove("datasource-records:get", this.getLookupRecordsHandler);
        this.schema = null;
        this.callback = null;
        this.remoteDsCallback = null;
        this.remoteCallback = null;
        this.getLookupRecordsHandler = null;
        this.fetchRecordCallback = null;

        if (this.schemaHelper != null && this.schemaHelper.dispose != null) {
            this.schemaHelper.dispose();
        }
        this.schemaHelper = null;
    }

    /**
     * Given the dataset id create the dataset model shell
     * @param datasetId
     * @param initialValues
     * @param referenceDataSet
     * @param remote
     * @returns {DataSet}
     */
    createDataSet(datasetId, initialValues, referenceDataSet, remote, dataSourceRef) {
        const definition = this.schema.datasets.find(item => item.id === datasetId);
        const result = this.createDataSetFromDefinition(definition, referenceDataSet, remote, dataSourceRef);
        result.datasetFactory = this;

        if (this.callback) {
            this.callback(result);
        }

        if (initialValues != null) {
            result.setInitialValues(initialValues, this.draft);
        }
        
        return result;
    }

    /**
     * Given the schema dataset definition, create a dataset that represent that structure
     * @param definition
     * @param referenceDataSet
     * @param remote
     */
    createDataSetFromDefinition(definition, referenceDataSet, remote, dataSourceRef) {
        const globalId = referenceDataSet != null ? referenceDataSet.__globalId : null;
        const result = observe(new DataSet(definition, this.schema, remote, this.remoteCallback, dataSourceRef), globalId);
        result.name = definition.name;
        result.isLoading = true;
        result.__defaults = new Map();


        for (let field of definition.fields) {
            const trigger = field["listen-for"];

            if (field.collection === true) {
                const schemaDs = this.schema.datasources.find(item => item.id === field.datasource);

                result[field.name] = createDatasourceFromDefinition(this.schema, schemaDs, this.remoteDsCallback);

                const schemaHelper = new SchemaHelper(this.schema, null);
                if (schemaDs.resource != null) {


                    for (let i = 0; i < result[field.name] - 1; i++) {
                        schemaHelper.setAssociatedValueFor(result[field.name]);
                    }

                    schemaHelper.dispose();
                }

                if (trigger != null) {
                    result.listenFor(trigger, (model) => {
                        if (model.__isLoading === true) return;

                        const value = getValueOnPath(model, trigger);

                        if (value == null) {
                            return;
                        }

                        if (Array.isArray(value) && value.length === 0) {
                            return;
                        }

                        const target = model[field.name];
                        if (target instanceof DataSourceBase && this.draft == null) {
                            target.load({
                                model: model,
                                trigger: trigger
                            });
                        }
                    });
                }
            } else if (field.dataset != null) {
                const childReferenceDs = referenceDataSet == null ? null : referenceDataSet[field.name];
                result[field.name] = this.createDataSet(field.dataset, {}, childReferenceDs, remote);
                result[field.name].__delay = field.delay;
                if (trigger != null) {
                    result.listenFor(trigger, async (model) => {
                        if (model[trigger] != null && (Array.isArray(model[trigger]) && model[trigger].length > 0) && this.draft == null) {
                            result[field.name].load(result);
                        }
                    })
                }
            } else {
                result[field.name] = null;
            }

            if (field.default != null) {
                const value = typeof field.default === "string" && field.default.indexOf("@") !== -1
                    ? this.schemaHelper.getAssociatedValue(null, field.default) : field.default;
                if (field.lookupId != null && field.silentLookup === true) {
                    if (field.requires != null) {
                        for (let requireField of field.requires) {
                            let context;
                            if (requireField.indexOf("@") !== -1) {
                                requireField = requireField.split("@").join("variables.");
                                context = this.schema;
                            } else {
                                context = result;
                            }

                            const trigger = () => {
                                //removeObserverTrigger(context,requireField, trigger);
                                this.populateLookupDefaults(result, field, value);
                            };


                            addTriggers(context, requireField, trigger)
                        }
                    } else {
                        this.populateLookupDefaults(result, field, value);
                    }


                } else {
                    result[field.name] = value;
                }
                result.__defaults.set(field.name, value);
            }

            if (field.converter != null) {
                if (result.__converters == null) {
                    result.__converters = new Map();
                }

                if (window.converters.has(field.converter)) {
                    const type = window.converters.get(field.converter);
                    result.__converters.set(field.name, new type());
                }
            }
        }

        if (definition.primaryActions != null) {
            result.__primaryActions = definition.primaryActions;
        }

        result.drafted = false;
        result.isLoading = false;
        return result;
    }

    async populateLookupDefaults(dataset, field, value) {
        if (value == null) return;
        const lookupDefinition = this.schema.lookups.find(x => x.id === field.lookupId);
        const dataSource = this.createLookupDatasource({
            datasource: lookupDefinition.datasource,
        });

        let queryOptions = [{
            field: lookupDefinition.mapping[field.name],
            value: value,
            operator: "EQ"
        }];

        await dataSource.load(null, null, queryOptions);
        const data = await dataSource.data();
        if (data[0] != null) {
            dataset.applyValues(data[0], lookupDefinition.mapping, true);
        }
    }

    /**
     * Event fired when lookup data is requested.
     * @param definition
     * @returns {Promise<void>}
     */
    async getLookupRecords(definition) {
        if (definition.identifier !== `${this.schema.type}${this.schema.resource}`) {
            return;
        }
        window.eventEmitter.emit("datasource-records:return", this.createLookupDatasource(definition));
    }

    createLookupDatasource(definition) {
        const ds = this.schema.datasources.find(item => item.id === definition.datasource);

        if (ds == null) {
            return;
        }

        ds.isLookup = true;
        ds.preventLoading = true;

        return createDatasourceFromDefinition(this.schema, ds, this.remoteDsCallback);
    }

    createDatasource(definition){
        return createDatasourceFromDefinition(this.schema, definition, this.remoteDsCallback);
    }

    finalize() {
        this.draft = null;
    }
}