import {isMobile} from "../device-helper.js";
import {addPropertyFeatures} from "../../baremetal/lib/mixin-properties.js";

export class HotSpotsApi {
    /**
     * hotSpots get hotSpots
     * @returns {Mop}
     */
    get hotSpots() {
        return this.getProperty("hotSpots", () => new Map([
            ['left', {left: '0px',top: '0px',height: '100%',width: '40px'}],
            ['right',{right: '0px', top: '0px', height: '100%', width: '40px'}]
        ]) );
    }
    /**
     * Set the hotSpot to monitor.
     * @param newValue {Map} : newValue is a map of hotSpots.
     */
    set hotSpots(newValue) {
        this.setProperty("hotSpots", newValue);
    }

    /**
     * constructor sets class properties when the class is instantiated
     */
    constructor() {
        this.isMobile = isMobile();
        this.speed = this.isMobile === true ? 25 : 40;
        this.hotSpotElements = [];
        addPropertyFeatures(this);
    }

    /**
     * dispose clears class properties
     */
    dispose() {
        this.speed = null;
        for (const hotSpot of this.hotSpotElements) {
            this.hotSpotEvents(hotSpot.element.removeEventListener,[hotSpot.event],[hotSpot.scrollhandler])
        }
        this.hotSpotElements = null;
        this.eventInterval = null;
    }

    /**
     * hotSpotEvents registers and unregisters events on the hotSpot.
     * @param fn {function} : either an addEventLister function or removeEventListener functions
     * @param events {Array} : an array of event name strings eg ["mouseover","mouseout"]
     * @param callbacks {Array} : an array of callback functions.
     */
    hotSpotEvents(fn, events, callbacks) {
        for (let i = 0; i < events.length; i++ ) {
            const event = events[i];
            const callback = callbacks[i];
            fn(event, callback);
        }
    }

    /**
     * addHotSpots adds hotSpots to the element.
     * @param element {HTMLElement}
     */
    addHotSpots(element){
        for (const hotSpotKey of this.hotSpots.keys()) {
            const hotSpot = document.createElement("div" );
            hotSpot.classList.add(`hotspot-${hotSpotKey}`);
            hotSpot.setAttribute("data-direction",`${hotSpotKey}`);
            element.appendChild(hotSpot);
        }
    }

    /**
     * performElementScroll performs the scroll on the element
     * @param event {Object} : event object
     * @param element {HTMLElement} : html element to be scrolled
     * @param direction {string} : receives string value of the direction in which to scroll
     * @param hasEnded {boolean} : receives boolean as flag to stop Scrolling
     */
    performElementScroll(event, element, direction, hasEnded) {
        if (direction == null) return;

        if (event.type === 'mouseout') {
            hasEnded = true
        }

        clearInterval(this.eventInterval);
        if (hasEnded === false) {
            this.eventInterval = setInterval(() => {
                this[`_scroll${direction}`](element);
            }, 50);
        }
        else {
            clearInterval(this.eventInterval);
        }
    }

    /**scroll
     * left direction to scroll element
     * @param element {HTMLElement}: the element to be scrolled;
     * @private
     */
    _scrollleft(element) {
        if (element.scroller == null) return;
        requestAnimationFrame(() => element.scroller.scrollLeft -= this.speed);
    }

    /**
     * right direction to scroll element
     * @param element {HTMLElement}: the element to be scrolled;
     * @private
     */
    _scrollright(element) {
        if (element.scroller == null) return;
        requestAnimationFrame(() => element.scroller.scrollLeft += this.speed);
    }

    /**
     * top direction to scroll element
     * @param element {HTMLElement}: the element to be scrolled;
     * @private
     */
    _scrolltop(element) {
        if (element.scroller == null) return;
        requestAnimationFrame(() => element.scroller.scrollTop -= this.speed);
    }

    /**
     * bottom direction to scroll element
     * @param element {HTMLElement}: the element to be scrolled;
     * @private
     */
    _scrollbottom(element){
        if (element.scroller == null) return;
        requestAnimationFrame(() => element.scroller.scrollTop += this.speed);
    }
}