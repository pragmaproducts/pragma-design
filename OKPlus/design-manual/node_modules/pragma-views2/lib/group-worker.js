export const aggregates = {
    sum: "sum",
    min: "min",
    max: "max",
    ave: "ave",
    count: "count"
};

export class GroupWorker {
    constructor() {
        this.workerMessageHandler = this.workerMessage.bind(this);

        this.worker = new Worker('group-worker.js');
        this.worker.addEventListener('message', this.workerMessageHandler);
    }

    /**
     * Append existing cache with more data and recalculate perspectives
     * @param id
     * @param data
     */
    appendCache(id, data) {
        this.worker.postMessage({
            msg: "appendCache",
            id: id,
            data: data
        });
    }

    /**
     * add a data cache for processing to the work manager web worker
     * @param id: cache id used for unique identification of cache
     * @param data: what array of data do you want to cache for further processing on perspectives
     * @param perspectives
     */
    createCache(id, data, perspectives) {
        this.worker.postMessage({
            msg: "createCache",
            id: id,
            data: data,
            perspectives: perspectives
        });
    }

    /**
     * Given the cache id, create a perspective grouping and aggregation
     * @param id: cache id to get data for processing
     * @param perspectiveId: as what must the perspective be cached on.
     * @param fieldsToGroup: string array of field names to group by during cache processing
     * @param aggegateOptions: aggregation to be used
     * @param sortOptions
     * @param data
     */
    createGroupPerspective(id, perspectiveId, fieldsToGroup, aggegateOptions, sortOptions, data) {
        this.worker.postMessage({
            msg: "createGroupPerspective",
            id: id,
            perspectiveId: perspectiveId,
            fieldsToGroup: fieldsToGroup,
            aggegateOptions: aggegateOptions,
            sortOptions: sortOptions,
            data: data
        })
    }

    createGroupPerspectiveResponse(args) {
        window.eventEmitter.emit(`${args.id}_${args.perspectiveId}`, args.data);
    }

    /**
     * remove the cache and all it's perspectives
     * @param id
     */
    disposeCache(id) {
        this.worker.postMessage({
            msg: "disposeCache",
            id: id
        })
    }

    /**
     * remove perspective from cache
     * @param id: cacheId
     * @param perspectiveId
     */
    disposeGroupPerspective(id, perspectiveId) {
        this.worker.postMessage({
            msg: "disposeGroupPerspective",
            id: id,
            perspectiveId: perspectiveId
        })
    }

    getAllRecordsInBranch(branch) {
        if (branch.lowestGroup) {
            return branch.items;
        }

        let result = [];
        for (let item of branch.items) {
            result = result.concat(this.getAllRecordsInBranch(item));
        }

        return result;
    }

    getGroupPerspective(id, perspectiveId) {
        this.worker.postMessage({
            msg: "getGroupPerspective",
            id: id,
            perspectiveId: perspectiveId
        })
    }


    removeRecords(id, items) {
        this.worker.postMessage({
            msg: "removeRecords",
            id: id,
            items: items
        })
    }

    getGroupPerspectiveResponse(args) {
        window.eventEmitter.emit(`${args.id}_${args.perspectiveId}`, args.data);
    }

    removeRecordsResponse(args) {
        window.eventEmitter.emit(`${args.id}_remove`, args.data);
    }

    getRecordsFor(id, perspectiveId, filters) {
        this.worker.postMessage({
            msg: "getRecordsFor",
            id: id,
            perspectiveId: perspectiveId,
            filters: filters
        })
    }

    getRecordsForResponse(args) {
        window.eventEmitter.emit(`records_${args.id}`, args.data);
    }

    addRecords(id, items) {
        this.worker.postMessage({
            msg: "addRecords",
            id: id,
            items: items
        })
    }

    addRecordsResponse(args) {
        window.eventEmitter.emit(`${args.id}_add`, args.data);
    }


    updateRecords(id, items) {
        this.worker.postMessage({
            msg: "updateRecords",
            id: id,
            items: items
        })
    }

    updateRecordsResponse(args) {
        window.eventEmitter.emit(`${args.id}_update`, args.data);
    }
    

    workerMessage(args) {
        if (this[args.data.msg]) {
            this[args.data.msg].call(this, args.data);
        }
    }

    filterRecords(id, filterString) {
        this.worker.postMessage({
            msg: "filterRecords",
            id: id,
            filterString: filterString
        })
    }

    filterRecordsResponse(args) {
        window.eventEmitter.emit(`filtered_records_${args.id}`, args.data);
    }
}