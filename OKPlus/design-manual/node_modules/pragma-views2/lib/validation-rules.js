import {ValidationDom} from './validation-dom.js';

export class Rules {
    static max(model, field, value) {
        const result = {
            isValid: true,
            message: ""
        };

        const fieldValue = model[field] == null || model[field] == undefined ? 0 : model[field];
        if (fieldValue > value) {
            result.isValid = false;
            result.message = `The value of ${field} must be less or equal to ${value}`;
        }

        return result;
    }

    static maxLength(model, field, length) {
        const result = {
            isValid: true,
            message: ""
        };

        const fieldValue = model[field] == null || model[field] == undefined ? "" : String(model[field]);
        if (fieldValue.trim().length > length) {
            result.isValid = false;
            result.message = `The length of ${field} may not exceed ${length}`;
        }

        return result;
    }

    static min(model, field, value) {
        const result = {
            isValid: true,
            message: ""
        };

        const fieldValue = model[field] == null || model[field] == undefined ? 0 : model[field];
        if (fieldValue < value) {
            result.isValid = false;
            result.message = `The value of ${field} must be greater or equal to ${value}`;
        }

        return result;
    }

    static minLength(model, field, length) {
        const result = {
            isValid: true,
            message: ""
        };

        const fieldValue = model[field] == null || model[field] == undefined ? "" : String(model[field]);
        if (fieldValue.trim().length < length) {
            result.isValid = false;
            result.message = `The length of ${field} may not be less than ${length}`;
        }

        return result;
    }

    static pattern(model, field, value) {
        const result = {
            isValid: true,
            message: ""
        };

        const re = new RegExp(value);
        const matches = re.test(model[field]);

        if (!matches) {
            result.isValid = false;
            result.message = "Value does not match expected pattern";
        }

        return result;
    }

    static required(model, field) {
        const result = {
            isValid: true,
            message: ""
        };

        const fieldValue = model[field] == null || model[field] == undefined ? "" : String(model[field]);
        if (fieldValue.trim().length == 0) {
            result.isValid = false;
            result.message = `${field} is required`;
        }

        return result;
    }
}

export class Validator {
    static __validateCollectionField(collection) {
        return new Promise((resolve, reject) => {
            const promises = [];
            let errors = [];

            for (let ds of collection) {
                const promise = Validator.validateDataset(ds).catch(fieldErrors => {
                    errors = errors.concat(fieldErrors)
                });
                promises.push(promise);
            }

            Promise.all(promises).then(_ => {
                if (errors.length == 0) {
                    resolve();
                }
                else {
                    reject(errors);
                }
            })
        });
    }

    static __validateNormalField(dataset, fieldName, fieldDefinition) {
        return new Promise((resolve, reject) => {
            const errors = [];
            const keys = Object.keys(fieldDefinition.validations);

            for (let key of keys) {
                const result = Validator.performRuleValidation(dataset, fieldName, key, fieldDefinition.validations[key].value);
                if (result.isValid == false) {
                    result.element = ValidationDom.getUIElement(fieldName, dataset);
                    result.rule = {};
                    result.rule[key] = fieldDefinition.validations[key].value;
                    errors.push(result);
                }
            }

            if (errors.length == 0) {
                resolve();
            }
            else {
                reject(errors);
            }
        });
    }

    /**
     * Given the dataset, field, rule and rule value is the field valid on the given object
     * @param dataset
     * @param field
     * @param rule
     * @param ruleValue
     * @returns { isValid: true/false; message: "error" }
     *
     */
    static performRuleValidation(dataset, field, rule, ruleValue) {
        switch (rule) {
            case "required":
                return Rules.required(dataset, field);
            case "maxLength":
                return Rules.maxLength(dataset, field, ruleValue);
            case "minLength":
                return Rules.minLength(dataset, field, ruleValue);
            case "pattern":
                return Rules.pattern(dataset, field, ruleValue);
            case "minimum":
                return Rules.min(dataset, field, ruleValue);
            case "maximum":
                return Rules.max(dataset, field, ruleValue);
            default:
                return {
                    isValid: true
                }
        }
    }

    /**
     * Perform validation on a dataset
     * @param dataset
     * @returns {Promise}: check catch for any errors on the validation
     */
    static validateDataset(dataset) {
        return new Promise((resolve, reject) => {
            let errors = [];
            let promises = [];

            const fields = dataset["__definition"].fields;
            for (let field of fields) {
                const promise = Validator.validateField(dataset, field.name).catch(fieldErrors => {
                    errors = errors.concat(fieldErrors);
                });

                promises.push(promise);
            }

            Promise.all(promises)
                .then(_ => {
                    if (errors.length == 0) {
                        resolve();
                    }
                    else {
                        reject(errors);
                    }
                })
        });
    }

    /**
     * Validate a field and make sure that it is valid
     * @param dataset
     * @param fieldName
     * @returns {Promise}: check catch for any errors on the validation
     */
    static validateField(dataset, fieldName) {
        return new Promise((resolve, reject) => {
            const fieldDefinition = dataset["__definition"].fields.find(f => f.name == fieldName);

            if ((fieldDefinition.validations == undefined) && (fieldDefinition.items == undefined) && (fieldDefinition.dataset == undefined)) {
                return resolve();
            }

            let errors = [];
            const promises = [];

            if (fieldDefinition.items != undefined) {
                // TODO GM: Temporary. Must investigate in future
                // const promise = Validator.__validateCollectionField(dataset[fieldName]).catch(fieldErrors => errors = errors.concat(fieldErrors));
                // promises.push(promise);
            }
            else if (fieldDefinition.dataset != undefined) {
                const promise = Validator.validateDataset(dataset[fieldName]).catch(fieldErrors => errors = errors.concat(fieldErrors));
                promises.push(promise);
            }
            else {
                const promise = Validator.__validateNormalField(dataset, fieldName, fieldDefinition).catch(fieldErrors => errors = errors.concat(fieldErrors));
                promises.push(promise);
            }

            Promise.all(promises).then(_ => {
                if (errors.length == 0) {
                    resolve();
                }
                else {
                    reject(errors);
                }
            })
        })
    }
}
