import {HierarchicalItem} from "./hierarchical-item.js";
import {ComponentUiStates} from "./component-ui-states.js";

export class UIGraph {
    /**
     * The ui graph is used to walk down the dom tree and set the state on interested elements
     * @param rootElement - The element to start the build the graph from e.g. pragma-form
     */
    constructor(rootElement) {
        this.rootElement = rootElement;
        this.containerComponents = window.uiGraphConstants.containerComponents;
        this.visualizations = window.uiGraphConstants.visualizationsComponents;
        this.interestedElements = [...this.containerComponents, ...this.visualizations];
        this.domPathMap = new Map();
        this.stopElements = window.uiGraphConstants.stopComponents;
    }

    dispose() {
        this.rootElement = null;
        this.domPathMap = null;
        this.stopElements = null;
        this.graph = null;
    }

    /**
     * This function needs to be called to start building the graph
     */
    build() {
        this.graph = this.recursiveDependencyGraph(this.rootElement);
        this.setStateOfChildren(this.graph, ComponentUiStates.active);
    }

    /**
     * Steps through elements and add them to the graph
     * @param target
     * @param depth
     * @param path
     * @returns {HierarchicalItem}
     */
    recursiveDependencyGraph(target, depth, path = "root") {
        const item = new HierarchicalItem(target, false, target.children.length > 0, depth);
        if (this.interestedElements.indexOf(target.nodeName.toLowerCase()) !== -1) {
            if (target.nodeName.toLowerCase() !== "pragma-form" && this.containerComponents.indexOf(target.nodeName.toLowerCase()) !== -1) {
                target.uiGraph = this;
            }
            // We add container components to the domPathMap to locate a container inside the graph.
            // A path property gets set on the container and that is used when you want to trigger state
            // changes for elements that sits behind a hidden container
            this.domPathMap.set(path, item);
            target.path = path;
        }
        if (target.children.length > 0) {
            item.items = [];
            for (let i = 0; i < target.children.length; i++) {
                item.items.push(this.recursiveDependencyGraph(target.children[i], item.depth, `${path}.children[${i}]`));
            }
        }
        return item;
    }

    /**
     * Sets the state of container children
     * @param path - The path of the container that triggered visibility of children
     * @param uiState - Active or suspended
     * @param specificChild - This is used to trigger state changes for specific child of the container.
     *                        For example the split view right slow becomes visible.
     *                        We don't want to fire the state changes for the left side again because visibility didn't change
     */
    setChildrenStateForPath(path, uiState, specificChild) {
        const item = this.domPathMap.get(path);
        if (item == null || item.hasChildren === false) return;
        for (const child of item.items) {
            if (specificChild == null || specificChild === child.model)
                this.setStateOfChildren(child, uiState);
        }
    }

    setStateOfChildren(item, uiState) {
        if (this.interestedElements.indexOf(item.model.nodeName.toLowerCase()) !== -1) {
            item.model.uiState = uiState;
        }
        if (item.hasChildren === false || this.stopElements.indexOf(item.model.nodeName.toLowerCase()) !== -1) return;
        for (const child of item.items) {
            this.setStateOfChildren(child, uiState);
        }
    }
}



