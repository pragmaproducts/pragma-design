import { intents } from "./intents/Intents.js";
import { isMobile } from "./device-helper.js";
import { pressDuration, longPressDuration } from "./intents/intention-helper-constants.js";

export class IntentionHelper {

    constructor() {
        this.startTime = null;
        this.endTime = null;
        this.dragStarted = false;
        this.latestTouch = {time: 0};
        this.latestDoubleTouch = {time: 0};
        this.registeredIntentions = [];

        this._isMobile = isMobile();

        this.intentions = new Map();

        this.initializeIntentions();
    }

    dispose() {
        this.endTime = null;
        this.startTime = null;
        this.latestTouch = null;
        this.dragStarted = null;
        this.intentions = null;

        for (const item of this.registeredIntentions) {
            if(this._isMobile === true) {
                for (const event of item.intention.requiresEventsMobile) {
                    item.element.removeEventListener(event, item.intention.handler)
                }
            }
            else {
                for (const event of item.intention.requiresEventsDesktop) {
                    item.element.removeEventListener(event, item.intention.handler)
                }
            }
        }

        this.registeredIntentions = null;

    }

    initializeIntentions() {

        this.intentions.set(intents.click,{
            handler: this._isMobile ? this.tap.bind(this) : this.leftclick.bind(this),
            requiresEventsMobile: ['touchstart', 'touchend'],
            requiresEventsDesktop: ['click']
        });

        this.intentions.set(intents.dblclick, {
            handler: this._isMobile? this.doubletap.bind(this) : this.doubleclick.bind(this),
            requiresEventsMobile: ['touchstart', 'touchend'],
            requiresEventsDesktop: ['dblclick']
        });

        this.intentions.set(intents.rightclick, {
            handler: this._isMobile ? this.longTouch.bind(this) : this.rightclick.bind(this),
            requiresEventsMobile: ['touchstart'],
            requiresEventsDesktop: ['mousedown', 'mouseup']
        });
        this.intentions.set(intents.contextmenu, {
            handler: this._isMobile ? this.longTouch.bind(this) : this.rightclick.bind(this),
            requiresEventsMobile: ['touchstart'],
            requiresEventsDesktop: ['contextmenu']
        });

        this.intentions.set(intents.dragstart, {
            handler: this.dragStart.bind(this),
            requiresEventsMobile: ['touchstart'],
            requiresEventsDesktop: ['mousedown']
        });

        this.intentions.set(intents.dragend, {
            handler: this.dragEnd.bind(this),
            requiresEventsMobile: ['touchend'],
            requiresEventsDesktop: ['mouseup']

        });

        this.intentions.set(intents.drag, {
            handler: this._isMobile ? this.dragTouchMove.bind(this) : this.dragMouseMove.bind(this),
            requiresEventsMobile: ['touchmove'],
            requiresEventsDesktop: ['mousemove']
        });
    }

    /**
     * This is the registerIntention method, it receives three Parameters, an element, a intent and a callback
     * It registers event listeners on the element based on your intention for the element.
     * @param element
     * @param intent
     * @param callback
     */
    registerIntention(element, intent, callback) {
        const intention = this.intentions.get(intent);
        if (intention === null) return;
        const handler = intention.handler.bind(this, callback);
        this.registeredIntentions.push({intention: intention, element});

        if (this._isMobile === true) {
            for (const reqEvent of intention.requiresEventsMobile ) {
                element.addEventListener(reqEvent,handler);
            }
        } else {
            for (const reqEvent of intention.requiresEventsDesktop ) {
                element.addEventListener(reqEvent, handler);
            }
        }

    }

    /**
     * This is the unRegisterIntention method, it receives three Parameters, an element, a intent and a callback
     * It unregisters event listeners on the element based on your intention for the element.
     * @param element {HTMLElement}
     * @param intent {String}
     * @param callback {Function}
     */
    unRegisterIntention(element, intent, callback) {
        const intention = this.intentions.get(intent);
        if (intention === null) return;

        const registeredIntention = this.registeredIntentions.find((x)=> x.intention === intention && callback === callback && element === element);

        if (this._isMobile === true) {
            for (const reqEvent of intention.requiresEventsMobile ) {
                element.removeEventListener(reqEvent, registeredIntention.handler);
            }
        } else {
            for (const reqEvent of intention.requiresEventsDesktop ) {
                element.removeEventListener(reqEvent, registeredIntention.handler);
            }
        }

        this.registeredIntentions.splice(this.registeredIntentions.indexOf(registeredIntention), 1);

    }

    /**
     * This is the longTouch handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */
    longTouch(callback,event) {
        if (event.type === 'touchstart') {
            // Since calling preventDefault() on a touchstart or the first touchmove event of a series prevents the corresponding mouse events from firing,
            // it's common to call preventDefault() on touchmove rather than touchstart. That way, mouse events can still fire and things like links will continue to work.
            // Alternatively, some frameworks have taken to re-firing touch events as mouse events for this same purpose.
            // (This example is oversimplified and may result in strange behavior. It is only intended as a guide.
            event.preventDefault();
            this.startTime = new Date().getTime();
        }
        if (event.type === 'touchend') {
            this.endTime = new Date().getTime();
            let duration = this.endTime - this.startTime;
            if (duration > longPressDuration ) {
                callback(event);
            }
            this.startTime = null;
            this.endTime = null;
        }
    }

    /**
     * This is the tap handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */
    tap(callback, event) {
        let currentTime = new Date().getTime();
        let sinceLastTouch = currentTime - this.latestTouch.time;

        if (event.type === "touchstart") {
            this.latestTouch.positionX = event.touches[0].clientX;
            this.latestTouch.positionY = event.touches[0].clientY;
        }

        if (sinceLastTouch < pressDuration ){

            event.pageX = this.latestTouch.positionX;
            event.pageY = this.latestTouch.positionY;
            callback(event);
        }
        this.latestTouch.time = new Date().getTime();
    }

    /**
     * This is the DoubleTap handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */

    doubletap(callback,event) {

        if (event.type === "touchstart") {
            this.latestDoubleTouch.positionX = event.touches[0].clientX;
            this.latestDoubleTouch.positionY = event.touches[0].clientY;
        }

        if (event.type === 'touchend') {
            let currentTime = new Date().getTime();
            let sinceLastTouch = currentTime - this.latestDoubleTouch.time;
            clearTimeout(this.timer);

            if (sinceLastTouch < 500 && sinceLastTouch > 0) {
                this.timer = setTimeout(() => {
                    event.clientX = this.latestDoubleTouch.positionX;
                    event.clientY = this.latestDoubleTouch.positionY;
                    callback(event);
                }, 100)
            }
            this.latestDoubleTouch.time = new Date().getTime();
        }
    }
    
    /**
     * This is the doubleClick handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */
    doubleclick(callback, event) {
        callback(event);
    }

    /**
     * This is the rightClick handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */
    rightclick(callback, event) {
        let mbRight = event.button;
        if (mbRight !== 2) { return; }
        //Todo ZM - Check right click on mac, make sure its al working. specify exact button.
        callback(event)
    }

    /**
     * This is the contextmenu handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */

    contextmenu(callback, event) {
        callback(event);
    }

    /**
     * This is the leftClick handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */
    leftclick(callback, event) {
        callback(event);
    }

    /**
     * This is the dragStart handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */
    dragStart(callback, event) {
        if (this.dragStarted === false) {
            //Since calling preventDefault() on a touchstart or the first touchmove event of a series prevents the corresponding mouse events from firing,
            // it's common to call preventDefault() on touchmove rather than touchstart. That way, mouse events can still fire and things like links will continue to work.
            // Alternatively, some frameworks have taken to re-firing touch events as mouse events for this same purpose.
            // (This example is oversimplified and may result in strange behavior. It is only intended as a guide.
            event.preventDefault();
            this.dragStarted = true;
            callback(event);
        }
    }

    /**
     * This is the dragEnd handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */
    dragEnd(callback, event) {
        if (this.dragStarted === true) {
            this.dragStarted = false;
            callback(event);
        }
    }

    /**
     * This is the dragTouchMove handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */
    dragTouchMove(callback, event) {
        if (this.dragStarted === true ) {
            callback(event);
        }
    }

    /**
     * This is the dragMouseMove handler, it receives two Parameters, a callback and an event object
     * It execute the callback with event as the callback's parameter
     * @param callback
     * @param event
     */
    dragMouseMove(callback, event) {
        if (this.dragStarted === true) {
            // Since calling preventDefault() on a touchstart or the first touchmove event of a series prevents the corresponding mouse events from firing,
            // it's common to call preventDefault() on touchmove rather than touchstart. That way, mouse events can still fire and things like links will continue to work.
            // Alternatively, some frameworks have taken to re-firing touch events as mouse events for this same purpose.
            // (This example is oversimplified and may result in strange behavior. It is only intended as a guide.
            event.preventDefault();
            callback(event);
        }
    }
}