import {DataSourceBase} from "../../../lib/datasource-base.js";
import {DataSourceStateConstants} from "./../../../lib/datasource-constants.js";

describe("datasource-base-tests", () => {
    const sandbox = sinon.createSandbox();
    let datasource;

    beforeEach(() => {
      
        datasource = new DataSourceBase({
            definition: {
                id: 0
            }
        });
        datasource._data = [
            {
                id: 1,
                code: "Code 1"
            },
            {
                id: 2,
                code: "Code 2"
            },
            {
                id: 3,
                code: "Code 3"
            }
        ];
    });

    it('itemsAdded', () => {
       const newItem = {
           id: 4,
           code: "Code 4"
       };
       
       const lengthBefore = datasource._data.length;

        // Act
        datasource.itemsAdded([newItem]);
        
        // Assert
        chai.assert.equal(datasource._data[datasource._data.length-1],newItem);
        chai.assert.equal(lengthBefore+1,datasource._data.length);
    });

    it('itemsUpdated', () => {
        // Arrange
      const updatedItem = {
          id: 1,
          code: "UPDATED"
      };

        const lengthBefore = datasource._data.length;

        // Act

        datasource.itemsUpdated([updatedItem]);
        // Assert
        chai.assert.equal(datasource._data[0].code,updatedItem.code);
        chai.assert.equal(lengthBefore,datasource._data.length);
    });


    it('itemsDeleted', () => {
        // Arrange

        const lengthBefore = datasource._data.length;
        const itemToDelete = datasource._data[0];
        // Act

        datasource.itemsDeleted([datasource._data[0]]);
        // Assert
        chai.assert.notEqual(datasource._data[0].code,itemToDelete.code);
        chai.assert.equal(datasource.selectedId[0],datasource._data[0].id);
        chai.assert.equal(lengthBefore - 1,datasource._data.length);
    });

    it('set selectedId', () => {
        // Arrange

        datasource._state = DataSourceStateConstants.none;
        
        // Act

        datasource.selectedId = [1,2];
        // Assert
        chai.assert.equal(datasource.selectedItemsMap.values().next().value.id, 1);
        chai.assert.equal(datasource.selectedItemsMap.size, datasource.selectedId.length);
    });

    it("filter data source", async () => {
        // Arrange
        const filterString = "Test";
        const filterResults = [datasource._data[0]];
        datasource.hasItems = false;
        const spyGetFilterRecords = sandbox.stub(datasource, "getFilterRecords").returns(filterResults);
        const spySetData = sandbox.stub(datasource, "_setData");
        const spyCreatePerspectives = sandbox.stub(datasource, "_createPerspectives");


        // Act
        await datasource.filter(filterString);

        // Assert
        chai.assert(spyGetFilterRecords.calledOnce, "Expect getFilterRecords() method on data source instance to be called once.");
        chai.assert(spyGetFilterRecords.calledWith("Test"));
        chai.assert(spySetData.calledOnce, "Expect _setData() method on data source instance to be called once.");
        chai.assert(spySetData.calledWith(filterResults));
        chai.assert(spyCreatePerspectives.notCalled, "Expect _createPerspectives() method on data source instance to NOT be called.");
        chai.assert.isTrue(datasource.hasItems);
    });
    
    it("filter data source with perspective", async () => {
        // Arrange
        const filterString = "Test";
        const filterResults = [datasource._data[0]];
        datasource.hasItems = false;
        datasource.definition = {perspective: 0};
        const spyGetFilterRecords = sandbox.stub(datasource, "getFilterRecords").returns(filterResults);
        const spySetData = sandbox.stub(datasource, "_setData");
        const spyCreatePerspectives = sandbox.stub(datasource, "_createPerspectives");

        
        // Act
        await datasource.filter(filterString);
        
        // Assert
        chai.assert(spyGetFilterRecords.calledOnce, "Expect getFilterRecords() method on data source instance to be called once.");
        chai.assert(spyGetFilterRecords.calledWith("Test"));
        chai.assert(spySetData.calledOnce, "Expect _setData() method on data source instance to be called once.");
        chai.assert(spySetData.calledWith(filterResults));
        chai.assert(spyCreatePerspectives.calledOnce, "Expect _createPerspectives() method on data source instance to be called once.");
        chai.assert(spyCreatePerspectives.calledWith(filterResults));
        chai.assert.isTrue(datasource.hasItems);
    });

    it("load (with no perspective) - sets state", async () => {
        // Arrange
        const items = datasource._data;
        const spyStateSetter = sandbox.spy(datasource, 'state', ['set']);
        const spyClear = sandbox.stub(datasource, "clear");
        window.groupWorker = {
            createCache: () => {} 
        };
        const spyCreateCache = sandbox.stub(window.groupWorker, "createCache");
        const spyCreatePerspectives = sandbox.stub(datasource, "_createPerspectives");
        datasource.hasItems = false;

        // Act
        await datasource.load(items);

        // Assert
        chai.assert.equal(spyStateSetter.set.callCount, 2, "Expect state property to be set twice.");
        chai.assert.equal(spyStateSetter.set.args[0], DataSourceStateConstants.busy, "Expect state property to be set to busy on first call.");
        chai.assert.equal(spyStateSetter.set.args[1], DataSourceStateConstants.none, "Expect state property to be set to non on second call.");
        chai.assert(spyClear.calledOnce, "Expect clear() method on data source instance to be called once.");
        chai.assert(spyCreateCache.calledOnce, "Expect spyCreateCache() method on group worker instance to be called once.");
        chai.assert(spyCreateCache.calledWith(datasource.initialDataCacheId, items));
        chai.assert(spyCreatePerspectives.notCalled, "Expect _createPerspectives() method on data source instance to NOT be called.");
        chai.assert.isTrue(datasource.hasItems);
    });

    it("load (with perspective) - sets state", async () => {
        // Arrange
        const items = datasource._data;
        const spyStateSetter = sandbox.spy(datasource, 'state', ['set']);
        const spyClear = sandbox.stub(datasource, "clear");
        window.groupWorker = {
            createCache: () => {}
        };
        const spyCreateCache = sandbox.stub(window.groupWorker, "createCache");
        const spyCreatePerspectives = sandbox.stub(datasource, "_createPerspectives");
        datasource.hasItems = false;
        datasource.definition.perspective = 0;
        let rootItemsLoadedCallbackCalled = false;


        // Act
        await datasource.load(items);

        // Assert
        chai.assert.equal(spyStateSetter.set.callCount, 2, "Expect state property to be set twice.");
        chai.assert.equal(spyStateSetter.set.args[0], DataSourceStateConstants.busy, "Expect state property to be set to busy on first call.");
        chai.assert.equal(spyStateSetter.set.args[1], DataSourceStateConstants.none, "Expect state property to be set to non on second call.");
        chai.assert(spyClear.calledOnce, "Expect clear() method on data source instance to be called once.");
        chai.assert(spyCreateCache.calledOnce, "Expect spyCreateCache() method on group worker instance to be called once.");
        chai.assert(spyCreateCache.calledWith(datasource.initialDataCacheId, items));
        chai.assert(spyCreatePerspectives.calledOnce, "Expect _createPerspectives() method on data source instance to be called once.");
        chai.assert.isTrue(datasource.hasItems);
    });
});
