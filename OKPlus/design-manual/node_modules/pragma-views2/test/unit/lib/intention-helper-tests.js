import { IntentionHelper } from "../../../lib/intention-helper.js";

describe('intention-helper-tests', () => {
    let instance;
    const sandbox = sinon.createSandbox();

    beforeEach(() => {
        instance = new IntentionHelper();
    });

    afterEach(() => {
        sandbox.restore();
    });

    it('constructor_intention-set-success', () => {
        // Arrange
        const intents = {
            rightclick: 'rightclick',
            click: 'click',
            doubleclick: 'doubleclick',
            dragstart: 'dragstart',
            drag: 'drag',
            dragend: 'dragend'
        };
        const Func1 = () => {
            return 'mobile';
        };

        const Func2 = () => {
            return 'desktop';
        };
        instance._isMobile = false;
        instance.intentions = new Map();

        //Act
        instance.intentions.set(intents.click, {
            handler: instance._isMobile ? Func1() : Func2(),
            requiresEventsMobile: ['touchstart', 'touchend'],
            requiresEventsDesktop: ['click']
        });
        // Assert
        chai.assert.equal(instance.intentions.get('click').handler, 'desktop', 'Expect intention handler to be desktop ');

    });

    it('constructor_intention-is-mobile-set-success', () => {
        // Arrange
        const intents = {
            rightclick: 'rightclick',
            click: 'click',
            doubleclick: 'doubleclick',
            dragstart: 'dragstart',
            drag: 'drag',
            tap: 'tap',
            dragend: 'dragend'
        };
        const Func1 = () => {
            return 'mobile';
        };

        const Func2 = () => {
            return 'desktop';
        };
        instance._isMobile = true;
        instance.intentions = new Map();

        //Act
        instance.intentions.set(intents.tap, {
            handler: instance._isMobile ? Func1() : Func2(),
            requiresEventsMobile: ['touchstart', 'touchend'],
            requiresEventsDesktop: ['click']
        });
        // Assert
        chai.assert.equal(instance.intentions.get('tap').handler, 'mobile', 'Expect intention handler to be desktop ');

    });

    it('constructor-intention-set-isMobile-success', () => {
        // Arrange
        const intents = {
            rightclick: 'rightclick',
            leftclick: 'leftclick',
            doubleclick: 'doubleclick',
            dragstart: 'dragstart',
            drag: 'drag',
            dragend: 'dragend'
        };
        const Func1 = () => {
            return 'mobile';
        };

        const Func2 = () => {
            return 'desktop';
        };
        instance._isMobile = true;
        instance.intentions = new Map();

        //Act
        instance.intentions.set(intents.leftclick, {
            handler: instance._isMobile ? Func1() : Func2(),
            requiresEventsMobile: ['touchstart', 'touchend'],
            requiresEventsDesktop: ['click']
        });
        // Assert
        chai.assert.equal(instance.intentions.get('leftclick').handler, 'mobile', 'Expect intention handler to be mobile ');

    });

    it('constructor-success', () => {
        // Arrange
        instance._isMobile = false;
        const intention = instance.intentions.get('click');
        const Func1 = () => {
            return 'mobile';
        };
        const Func2 = () => {
            return 'desktop';
        };
        intention.handler = instance._isMobile ? Func1() : Func2();
        // Assert
        chai.assert.equal(instance.startTime, null, 'Expect startTime be Null');
        chai.assert.equal(instance.endTime, null, 'Expect endTime be Null');
        chai.assert.equal(instance.latestTouch.time, 0, 'Expect latestTouch to  equal 0');
        chai.assert.equal(intention.requiresEventsDesktop[0], 'click', 'Expect intention requiresEventsDesktop to equal ["click"]');
        chai.assert.instanceOf(instance.intentions, Map, 'Expect Intentions to be instance of Map');
        chai.assert.equal(intention.handler, 'desktop', 'Expect instance intention handler to be desktop');
        chai.assert.equal(instance.registeredIntentions.length, 0, 'Expect registered intentions length to be 0');
    });

    it('constructor-success-isMobile', () => {
        // Arrange
        instance._isMobile = true;
        const intention = instance.intentions.get('click');

        const Func1 = () => {
            return 'mobile';
        };
        const Func2 = () => {
            return 'desktop';
        };
        intention.handler = instance._isMobile ? Func1() : Func2();
        // Assert
        chai.assert.equal(instance.startTime, null, 'Expect startTime be Null');
        chai.assert.equal(instance.endTime, null, 'Expect endTime be Null');
        chai.assert.equal(instance.latestTouch.time, 0, 'Expect latestTouch to  equal 0');
        chai.assert.instanceOf(instance.intentions, Map, 'Expect intentions to be instance of Map');
        chai.assert.equal(intention.requiresEventsMobile.length, 2, 'Expect intention requiresEventsMobile to equal 2');
        chai.assert.equal(intention.handler, 'mobile', 'Expect instance intention handler to be mobile');
        chai.assert.equal(instance.registeredIntentions.length, 0, 'Expect registered intentions length to be 0');
    });

    it('dispose-success', () => {
        // Arrange
        instance.latestTouch = new Date().getTime();
        // Act
        instance.dispose();
        // Assert
        chai.assert.isNull(instance.latestTouch, 'Expect latestTouch to be null');
    });

    it('dispose-success-isMobile-true', () => {
        // Arrange
        instance.latestTouch = new Date().getTime();
        const element = document.createElement('span');
        const intent = 'tap';
        const intention = {
            handler: (() => { }),
            requiresEventsMobile: ['touchstart', 'touchend'],
            requiresEventsDesktop: ['dblclick']
        };
        const callback = () => { return 'something' };

        instance._isMobile = true;
        instance.intentions.set('tap', intention);
        instance.registerIntention(element, intent, callback);
        const spyAremoveEventListener = sandbox.stub(element, 'removeEventListener');
        // Act
        instance.dispose();

        // Assert
        chai.assert(spyAremoveEventListener.calledTwice, 'Expects event listener to be called twice');
        chai.assert.isNull(instance.latestTouch, 'Expect latestTouch to be null');


    });

    it('dispose-success-isMobile-false', () => {
        // Arrange
        instance.latestTouch = new Date().getTime();
        const element = document.createElement('span');
        const intent = 'tap';
        const intention = {
            handler: (() => { }),
            requiresEventsMobile: ['touchstart', 'touchend'],
            requiresEventsDesktop: ['dblclick']
        };
        const callback = () => { return 'something' };

        instance._isMobile = false;
        instance.intentions.set('tap', intention);
        instance.registerIntention(element, intent, callback);
        const spyAremoveEventListener = sandbox.stub(element, 'removeEventListener');
        // Act
        instance.dispose();

        // Assert
        chai.assert(spyAremoveEventListener.calledOnce, 'Expects event listener to be called once');
        chai.assert.isNull(instance.latestTouch, 'Expect latestTouch to be null');

    });

    it('registerIntention-success', () => {
        // async needs await before,
        // arrange
        const intention = {
            handler: (() => { }),
            requiresEventsMobile: ['touchstart', 'touchend'],
            requiresEventsDesktop: ['dblclick']
        };

        instance.intentions.set('tap', intention);

        const element = document.createElement('span');
        const intent = 'tap';
        const callback = () => {
            return 'something'
        };

        instance._isMobile = true;
        const spyAddEventListener = sandbox.stub(element, 'addEventListener');
        // act
        instance.registerIntention(element, intent, callback);
        // assert
        chai.assert.include(instance.registeredIntentions, { intention: intention, element }, 'Expects registeredIntentions to include element ad intention callback');
        chai.assert(spyAddEventListener.calledTwice, 'Expects event listener to be called twice');
        chai.assert(spyAddEventListener.args, 'Expects event listener to be called twice');
    });

    it('registerIntention_register-sameIntentions-with-different-callback-success', () => {
        // arrange

        const spyRegisteredCallback = sandbox.stub();
        const intention = {
            handler: (() => { }),
            requiresEventsMobile: ['touchstart', 'touchend'],
            requiresEventsDesktop: ['click']
        };

        instance.intentions.set('leftclick', intention);

        const element = document.createElement('span');
        const registeredCallback1 = () => { };
        const registeredCallback2 = () => { };
        const eventObject = {};
        instance._isMobile = true;
        instance.registerIntention(element, 'leftclick', registeredCallback1);
        instance.registerIntention(element, 'leftclick', registeredCallback2);

        // act
        instance.leftclick(spyRegisteredCallback, eventObject);
        // assert
        // chai.assert.isTrue(testCase, 'Expect the callback result to be true');
        chai.assert(spyRegisteredCallback.called, 'Expect the callback to be called twice ')

    });

    it('registerIntention-success-intention-null', () => {
        // async needs await before,
        // arrange
        const intention = null;

        instance.intentions.set('tap', intention);

        const element = document.createElement('span');
        const intent = 'tap';
        const callback = () => {
            return 'something'
        };

        instance._isMobile = true;
        const spyAddEventListener = sandbox.stub(element, 'addEventListener');
        // act
        instance.registerIntention(element, intent, callback);
        // assert
        // chai.assert.include(instance.registeredIntentions, {intention: intention, element}, 'Expects registeredIntentions to include element ad intetion callback')
        chai.assert(spyAddEventListener.notCalled, 'Expects event listener not to be called twice');
        chai.assert(spyAddEventListener.args, 'Expects event listener to be called twice');
    });

    it('longTouch-touchstart-success', () => {
        // Arrange
        const event = { type: 'touchstart', preventDefault: (() => { }) };
        const spyPreventDefault = sandbox.stub(event, 'preventDefault');
        const callback = () => { };
        // Act
        instance.longTouch(callback, event);
        // Assert
        chai.assert(spyPreventDefault.called, 'Expect preventDefault to be called');
        chai.assert.isNotNull(instance.startTime, 'Expect instance startTime to get new time');
    });

    it('longTouch-touchend-success', () => {
        // Arrange
        const event = { type: 'touchend' };
        const callback = sandbox.stub();
        instance.startTime = new Date().getTime() - 1000;
        // Act
        instance.longTouch(callback, event);
        // Assert
        chai.assert(callback.called, 'Expect callback to be called');
        chai.assert.equal(instance.startTime, null, 'Expect instance startTime to be null');
        chai.assert.equal(instance.endTime, null, 'Expect instance endTime to be null');
    });

    it('longTouch-touchend-fail', () => {
        // Arrange
        const event = { type: 'touchend' };
        const callback = sandbox.stub();
        instance.startTime = new Date().getTime();
        setTimeout(() => {
            instance.endTime = new Date().getTime();
        }, 1000);
        // Act
        instance.longTouch(callback, event);
        // Assert
        chai.assert(callback.notCalled, 'Expect callback not to be called');
        // chai.assert.equal(instance.startTime, null, 'Expect instance startTime to be null');
        // chai.assert.equal(instance.endTime, null, 'Expect instance endTime to be null');

    });

    it('tap-success', () => {
        // Arrange
        const event = { type: 'touchend' };
        const callback = sandbox.stub();
        instance.latestTouch.time = new Date().getTime();
        // Act
        instance.tap(callback, event);
        // Assert
        chai.assert(callback.called, 'Expect callback to be called');
        chai.assert.notEqual(instance.latestTouch.time, null, 'Expect instance latestTouch not to be null');

    });

    it('tap-touchstart-success',()=>{
        // Arrange
        instance.isMobile = true;
        const event = {type: 'touchstart', touches: [{clientX: 100, clientY: 250},{clientX: 250, clientY: 100}]};
        const callback = sandbox.stub();

        // Act
        // Assert
        instance.tap(callback, event);

        // Assert
        chai.assert.equal(instance.latestTouch.positionX, event.touches[0].clientX, "expect instance.latestDoubleTouch.positionX to be equal to event.touches[0].clientX")

    });

    it('doubletap-touch-start-success',()=>{
        //Arrange
        instance.isMobile = true;
        const callback =() =>{};
        const event = {type: 'touchstart', touches: [{clientX: 100, clientY: 250},{clientX: 250, clientY: 100}]};
        // Act
        instance.doubletap(callback, event);

        // Assert
        chai.assert.equal(instance.latestDoubleTouch.positionX, event.touches[0].clientX, "expect instance.latestDoubleTouch.positionX to be equal to event.touches[0].clientX")
    });

    it ('doubletap-touch-end-success', ()=> {
        // Arrange
        instance.isMobile = true;
        instance.latestDoubleTouch.time = new Date().getTime() - 400;
        let testValue = 'Max';
        const callback =() =>{
            testValue = 'Susan';
        };
        const event = {type: 'touchend', touches: [{clientX: 100, clientY: 250},{clientX: 250, clientY: 100}]};
        // Act
        const promise = new Promise((resolve) =>{
            instance.doubletap(callback, event);
        });

        // Assert
        promise.then(()=>{
            chai.assert.equal(testValue,'Susan', 'Expect testValue to equal Susan');
            chai.assert.isNotNull(instance.latestDoubleTouch.time, 'Expect instance latestDoubleTouch not to be null');
        });
    });

    it('doubleClick-success', () => {
        // Arrange
        const event = 'someEvent';
        let callbackExecuted = false;
        const callback = () => {
            callbackExecuted = true;
        };
        // Act
        instance.doubleclick(callback, event);
        // Assert
        chai.assert.equal(callbackExecuted, true, 'Expects callback to be executed')

    });

    it('leftClick-success', () => {
        // Arrange
        const event = 'someEvent';
        let callbackExecuted = false;
        const callback = () => {
            callbackExecuted = true;
        };
        // Act
        instance.leftclick(callback, event);
        // Assert
        chai.assert.equal(callbackExecuted, true, 'Expects callback to be executed')

    });

    it('rightClick-success', () => {
        // Arrange
        const event = { button: 2 };
        let callbackExecuted = false;
        const callback = () => {
            callbackExecuted = true;
        };
        // Act
        instance.rightclick(callback, event);


        // Assert
        chai.assert.equal(callbackExecuted, true, 'Expects callback to be executed')

    });

    it('context-menu-success',()=> {
        // Arrange
        let testvalue = 10;
        const event = { type: 'contextmenu' };
        const callback = () =>{
            testvalue += 10
        };
        // act
        instance.contextmenu(callback,event);
        // assert
        chai.assert.equal(testvalue, 20, 'Expect test value to be 20 because callback was executed');
    });

    it('rightClick-fail', () => {
        // Arrange
        const event = { button: 0 };
        const callback = sandbox.stub();
        // Act
        instance.rightclick(callback, event);
        // Assert
        chai.assert(callback.notCalled, true, 'Expects callback not to be executed')

    });

    it('dragTouchStart-success', () => {
        // Arrange
        let callbackExecuted = false;
        const event = { type: 'touchstart', preventDefault: () => { } };
        const callback = () => {
            callbackExecuted = true
        };
        instance.dragStarted = false;
        // Act
        instance.dragStart(callback, event);
        // Assert
        chai.assert.equal(instance.dragStarted, true, 'Expects dragStarted to be true');
        chai.assert.equal(callbackExecuted, true, 'Expects callback to be executed');

    });

    it('dragTouchStart-fail', () => {
        // Arrange
        const event = { type: 'touchstart', preventDefault: () => { } };
        const callback = sandbox.stub();
        instance.dragStarted = true;
        // Act
        instance.dragStart(callback, event);
        // Assert
        chai.assert(callback.notCalled, 'Expects callback not to be executed');

    });

    it('dragTouchEnd-success', () => {
        // Arrange
        const event = { type: 'touchend' };
        const callback = sandbox.stub();
        instance.dragStarted = true;
        // Act
        instance.dragEnd(callback, event);
        // Assert
        chai.assert(callback.calledOnce, 'Expects callback to be executed');
        chai.assert.equal(instance.dragStarted, false, 'Expects drag started to be false');
        chai.assert.equal(instance.element, null, 'Expects element to be null');

    });

    it('dragTouchEnd-fail', () => {
        // Arrange
        const event = { type: 'touchend', preventDefault: () => { } };
        const callback = sandbox.stub();
        instance.dragStarted = false;
        // Act
        instance.dragEnd(callback, event);
        // Assert
        chai.assert(callback.notCalled, 'Expects callback not to be executed');

    });

    it('dragTouchMove-success', () => {
        // Arrange
        const event = { type: 'touchmove' };
        const callback = sandbox.stub();
        instance.dragStarted = true;
        // Act
        instance.dragTouchMove(callback, event);
        // Assert
        chai.assert(callback.calledOnce, 'Expects callback to be executed');

    });

    it('dragTouchMove-fail', () => {
        // Arrange
        const event = { type: 'touchmove', preventDefault: () => { } };
        const callback = sandbox.stub();
        instance.dragStarted = false;
        // Act
        instance.dragTouchMove(callback, event);
        // Assert
        chai.assert(callback.notCalled, 'Expects callback not to be executed');

    });

    it('dragMouseStart-success', () => {
        // Arrange
        const currentTarget = document.createElement('span');
        const event = { type: 'mousedown', preventDefault: () => { }, target: currentTarget };
        const spyPreventDefault = sandbox.stub(event, 'preventDefault');
        const callback = sandbox.stub();
        instance.dragStarted = false;
        // Act
        instance.dragStart(callback, event);
        // Assert
        chai.assert(spyPreventDefault.calledOnce, 'Expect preventDefault to be called');
        chai.assert.equal(instance.dragStarted, true, 'Expect instance dragStarted to be true');
        chai.assert(callback.calledOnce, 'Expects callback not to be executed');

    });

    it('dragMouseStart-fail', () => {
        // Arrange
        const currentTarget = document.createElement('span');
        const event = { type: 'mousedown', preventDefault: () => { }, target: currentTarget };
        const callback = sandbox.stub();
        instance.dragStarted = true;
        // Act
        instance.dragStart(callback, event);
        // Assert
        chai.assert(callback.notCalled, 'Expects callback not to be executed');

    });

    it('dragMouseEnd-success', () => {
        // Arrange
        const event = { type: 'mouseup' };
        const callback = sandbox.stub();
        instance.dragStarted = true;
        // Act
        instance.dragEnd(callback, event);
        // Assert
        chai.assert.equal(instance.dragStarted, false, 'Expects dragStarted to be false');
        chai.assert.equal(instance.element, null, 'Expects instance element to be null');
        chai.assert(callback.calledOnce, 'Expects callback to be executed');

    });

    it('dragMouseEnd-fail', () => {
        // Arrange
        const event = { type: 'mouseup', preventDefault: () => { } };
        const callback = sandbox.stub();
        instance.dragStarted = false;
        // Act
        instance.dragEnd(callback, event);
        // Assert
        chai.assert(callback.notCalled, 'Expects callback not to be executed');

    });

    it('dragMouseMove-success', () => {
        // Arrange
        const event = { type: 'mousemove', preventDefault: () => { } };
        const callback = sandbox.stub();
        const spyPreventDefault = sandbox.stub(event, 'preventDefault');
        instance.dragStarted = true;
        // Act
        instance.dragMouseMove(callback, event);
        // Assert

        chai.assert(spyPreventDefault.calledOnce, 'Expects preventDefault to be executed');
        chai.assert(callback.calledOnce, 'Expects callback to be executed');

    });

    it('dragMouseMove-fail', () => {
        // Arrange
        const event = { type: 'mousemove', preventDefault: () => { } };
        const callback = sandbox.stub();
        const spyPreventDefault = sandbox.stub(event, 'preventDefault');
        instance.dragStarted = false;
        // Act
        instance.dragMouseMove(callback, event);
        // Assert
        chai.assert(spyPreventDefault.notCalled, 'Expects preventDefault not to be executed');
        chai.assert(callback.notCalled, 'Expects callback not to be executed');

    });

});