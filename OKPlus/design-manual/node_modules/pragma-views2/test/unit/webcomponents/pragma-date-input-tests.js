import {PragmaInputDate} from "../../../webcomponents/pragma-input-date/pragma-input-date.js";

describe("pragma-date-input-tests", () => {

    let control;

    beforeEach(() => {
        control = new PragmaInputDate();
        sinon.stub(control, "_initTemplate");
        const inputStub = sinon.stub();
        inputStub.removeAttribute = () => {};
        inputStub.setAttribute = () => {};
        inputStub.value = '';
        const querySelectorStub = sinon.stub(control, "querySelector");
        querySelectorStub.onCall(0).returns(null);
        querySelectorStub.onCall(1).returns(inputStub);
        sinon.stub(control, "hasAttribute").returns(false);
        sinon.stub(control, "removeAttribute");
        control.connectedCallback();
    });

    afterEach(() => {
        // Restore the default sandbox here
        sinon.restore();
    });

    function testRegexPattern(isoDate, expectedIsoDate, displayDate, errorMessage) {
        // Arrange

        // Act
        control.date = isoDate;

        // Assert
        chai.assert.equal(control.date, expectedIsoDate, errorMessage);
        chai.assert.equal(control._dateInput.value, displayDate == null ? "" : displayDate, errorMessage);
    }

    it('testRegexPattern_1_success', async () => {
        testRegexPattern("2019-11-12", "2019-11-12", "12/11/2019");
    });
    it('testRegexPattern_2_success', async () => {
        testRegexPattern("2019-2-1", null, null);
    });
    it('testRegexPattern_3_success', async () => {
        testRegexPattern("19-12-01", null, null);
    });
    it('testRegexPattern_4_success', async () => {
        testRegexPattern("2018-02-29", null, null, "2018 is not a leap year and can not have 29 Feb.");
    });
    it('testRegexPattern_5_success', async () => {
        testRegexPattern("2014-02-29", null, null, "2014 is not a leap year and can not have 29 Feb.");
    });
    it('testRegexPattern_6_success', async () => {
        testRegexPattern("2100-02-29", null, null, "2100 is not a leap year and can not have 29 Feb.");
    });
    it('testRegexPattern_7_success', async () => {
        testRegexPattern("2400-02-29", "2400-02-29", "29/02/2400", "2400 is a leap year and must parse successfully.");
    });
    it('testRegexPattern_8_success', async () => {
        testRegexPattern("2012-02-29", "2012-02-29", "29/02/2012", "2012 is a leap year and must parse successfully.");
    });


    it('onKeyUp_onKeyUp_success', async () => {
        // Arrange

        // Act
        control._dateInput.value = "12/11/2019";
        control._dateInput.onkeyup({key: 'x'}); // Only here to simulate key press        

        // Assert
        chai.assert.equal(control.date, "2019-11-12");
    });

    it('setDate_withInvalidDate_clearValues', async () => {
        // Arrange

        // Act
        control.date = "01/03/201";

        // Assert
        chai.assert.isNull(control.date, "Expected date to be null.");
        chai.assert.equal(control._dateInput.value, "", "Expected date input control value to be null.");
    });


});