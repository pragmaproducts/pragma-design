import {PragmaColumnMove} from "../../../../webcomponents/pragma-column-move/pragma-column-move.js";
import {HotSpotsApi} from "../../../../lib/hotSpot-api/hotSpot-api.js";

describe('pragma-column-move',()=>{
    let instance;
    const sandbox = sinon.createSandbox();

    beforeEach(()=>{
        instance = new PragmaColumnMove();
        instance.animationLayer = document.createElement('div');
        instance.caret = document.createElement('span');
        instance.hotSpotApi = new HotSpotsApi();
    });

    afterEach(()=>{
       sandbox.restore();
    });

    function arrangeMouseDown(instance,role,eventType) {
        const spyAddCaret = sandbox.stub(instance,'addCaret');
        const target = document.createElement('div');
        const spyParentElement = sandbox.stub(instance, 'parentElement');
        const spyParentNode = sandbox.stub(target, 'parentNode');
        spyParentElement.value({style: {}});
        spyParentNode.value({childNodes: []});
        target.setAttribute('role', role);
        target.setAttribute('parentNode', document.createElement('div'));
        const event =  {
            type: eventType,
            clientX: 100,
            clientY: 250,
            target: target
        };

        // Act
        instance.handleMouseDown(event);
        // Assert
        if (role === 'columnheader') {
            chai.assert.instanceOf(instance.hotSpotApi, HotSpotsApi, 'Expect hotSpotApi to be instance of hotSpotApi');
            chai.assert(spyAddCaret.calledOnce, 'Expect function to be called once');
        } else {
            chai.assert(spyAddCaret.notCalled, 'Expect function not to be called');
        }

    }

    it('get-header', () => {
        // Arrange
        const element = document.createElement('div');
        element.setAttribute('role','rowgroup');
        const spyParentElement = sandbox.stub(instance, 'parentElement');
        spyParentElement.value({childNodes: [element]});
        const getprop = sandbox.stub(instance, 'getProperty');
        // Act
        instance.header;
        // Assert
        chai.assert(getprop.calledOnce, 'Expect getprop to be called once');

    });

    it('set-header', () => {
        // Arrange
        const header = document.createElement('div');
        const stubSetProp = sandbox.stub(instance, 'setProperty');
        // Act
        instance.header = header;
        // Assert
        chai.assert(stubSetProp.calledOnce, 'Expect spyHotSpots to be called once');

    });

    it('connectedCallback-success', () => {
        // Arrange
        const header = document.createElement('div');
        const spyHeader = sandbox.stub(instance, 'header');
        const spyIntents = sandbox.stub(instance, 'registerInputIntent');
        spyHeader.get(() => header);
        instance.timer = null;
        instance.hasEnded = null;
        // Act
        instance.connectedCallback();
        // Assert
        chai.assert.equal(instance.timer, 0, 'Expect timer to be 0');
        chai.assert.isFalse(instance.hasEnded, 'Expect hasEnded to be false');
        chai.assert(spyIntents.calledOnce, 'Expect registerInputIntent to be called once');

        const registerInputIntentArg = spyIntents.args[0];
        chai.assert.equal(registerInputIntentArg.length, 3, 'Expect args list count to be 3');
        chai.assert.equal(registerInputIntentArg[0],header, "Expect first arg to be header");
        chai.assert.equal(registerInputIntentArg[1],'dragstart', "Expect second arg to be string");
        chai.assert.isFunction(registerInputIntentArg[2], "Expect third arg to be function");
    });

    it('disconnectedCallback-success', () => {
        // Arrange
        const spyHotspotDispose = sandbox.stub(instance.hotSpotApi,'dispose');
        instance.timer = new Date().getTime();
        // Act
        instance.disconnectedCallback();
        // Assert
        chai.assert(spyHotspotDispose.calledOnce, 'Expect dispose to be called once');
    });

    it('handleMouseDown-success', () => {
        arrangeMouseDown(instance, 'columnheader', 'mousedown');
    });

    it('handleMouseDown-return-success', ()  => {
        arrangeMouseDown(instance, 'row', 'mousedown');
    });

    it('onMouseMove-success', () => {
        // Arrange
        instance.clone = document.createElement('div');
        instance.clone.rects = {top: 200, height: 200};
        const spyGetTarget = sandbox.stub(instance, 'getTargetElement');
        spyGetTarget.returns(document.createElement('div'));
        const target = spyGetTarget.returns(document.createElement('div'));
        const spyMoveCaret = sandbox.stub(instance, 'moveCaret');
        const point = {
            x: 10,
            y: 20
        };
        spyMoveCaret.withArgs(point);

        const event =  {
            type: 'mousemove',
            clientX: 100,
            clientY: 250,
            target: target
        };
        instance.hasEnded = true;
        // Act
        instance.onMouseMove(event);
        // Assert
        chai.assert(spyMoveCaret.calledOnce, 'Expect spyMoveCaret to be called once');
        chai.assert.equal(instance.hasEnded, false, 'Expect hasEnded to be false');
    });

    it('onMouseUp-success', () => {
        // Arrange
        const callback = () => {

        };
        const left = document.createElement('div');
        const right = document.createElement('div');
        right.classList.add('hotspot-right');
        left.classList.add('hotspot-left');
        instance.animationLayer.appendChild(left);
        instance.animationLayer.appendChild(right);
        instance.registerInputIntent(instance.animationLayer, 'drag', callback.bind(instance.animationLayer));
        instance.registerInputIntent(instance.animationLayer, 'dragend', callback.bind(instance.animationLayer));

        const event =  {
            type: 'mouseup',
            clientX: 100,
            clientY: 250
        };
        const spyColmove = sandbox.stub(instance, 'performColumnMove');
        // Act
        instance.onMouseUp(event);
        // Assert
        chai.assert(spyColmove.calledOnce, 'Expects perform column move to be called once');
        chai.assert.equal(instance.clone, null, 'Expects clone to be null');
        chai.assert.equal(instance.animationLayer,null, 'Expects animationLayer to be called once');

    });

    it('configureHotspots-is-mobile-success', () =>{
       instance.isMobile = true;
       instance.animationLayer = document.createElement('div');
        for (const key of instance.hotSpotApi.hotSpots.keys()) {
            const hotSpot = document.createElement('div');
            hotSpot.classList.add(`hotspot-${key}`);
            instance.animationLayer.appendChild(hotSpot);
        }
        const stubhotSpotEvents = sandbox.stub(instance.hotSpotApi, 'hotSpotEvents');
        // Act
        instance.configureHotspots();
        // Assert
        const eventArgs = stubhotSpotEvents.args[0];
        chai.assert.include(eventArgs[1], ["touchstart", "touchmove", "touchend"][0],  'Expect args to include touch events');

    });

    it('addCaret-success', () => {
        // Arrange
        instance.clone = document.createElement('div');
        instance.clone.rects = {top: 200, height: 200};
        instance.caret = null;
        // Act
        instance.addCaret();
        // Assert
        chai.assert.include(Array.from(instance.animationLayer.childNodes), instance.caret, 'Expects caret to be a child of the animation layer');
        chai.assert.include(Array.from(instance.caret.classList), 'caret', 'Expects caret to have caret class ');

    });

    it('performScroll-success', () => {
        // Arrange
        for (const key of instance.hotSpotApi.hotSpots.keys() ) {
            const child = document.createElement('div');
            child.classList.add(`hotspot-${key}`);
            child.style.width = 300;
            child.style.height = 50;
            instance.animationLayer.appendChild(child);
        }
        const target = document.createElement('div');
        target.setAttribute('data-direction', 'left');
        instance.isMobile = false;
        const event = {
            type: 'mousemove',
            target: target,
            clientX: 100,
            clientY: 50
        };
        // Act
        const promise = new Promise(resolve => {
            instance.performScroll(event);
        });
        // Assert
        promise.then(() => {
            chai.assert(instance.hotSpotApi.performElementScroll.called, 'Expect perform scroll to be called')
        });
    });

    it('performScroll-is-mobile-success', () => {
        // Arrange
        const target = document.createElement('div');
        for (const key of instance.hotSpotApi.hotSpots.keys() ) {
            const child = document.createElement('div');
            child.classList.add(`hotspot-${key}`);
            instance.animationLayer.appendChild(child);
        }
        target.setAttribute('data-direction', 'left');
        instance.isMobile = true;
        const event = {
            type: 'touchmove',
            target: target,
            touches: [
                {clientX: 100, clientY: 50}
            ]
        };
        // Act
        const promise = new Promise(resolve => {
            instance.performScroll(event);
        });
        // Assert
        promise.then(() => {
            chai.assert(instance.hotSpotApi.performElementScroll.called, 'Expect perform scroll to be called')
        });
    });

    it('performScroll-fail', () => {
        // Arrange
        instance.animationLayer = null;
        const event = {
            type: 'touchmove'
        };
        // Act
        const promise = new Promise(resolve => {
            instance.performScroll(event);
        });
        // Assert
        promise.then(() => {
            chai.assert(instance.hotSpotApi.performElementScroll.notCalled, 'Expect perform scroll not to be called')
        });

    });

    it('performScroll-touchend-fail', () => {
        // Arrange
        for (const key of instance.hotSpotApi.hotSpots.keys() ) {
            const child = document.createElement('div');
            child.classList.add(`hotspot-${key}`);
            instance.animationLayer.appendChild(child);
        }
        const target = document.createElement('div');
        target.setAttribute('data-direction', 'left');
        instance.isMobile = true;
        const event = {
            type: 'touchend',
            target: target,
            touches: [
                {clientX: 100, clientY: 50}
            ]

        };
        // Act
        const promise = new Promise(resolve => {
            instance.performScroll(event);
        });
        // Assert
        promise.then(() => {
            chai.assert.equal(instance.hasEnded, true, 'Expect has ended to be true');
            chai.assert(instance.hotSpotApi.performElementScroll.notCalled, 'Expect perform scroll not to be called')
        });

    });

    it('addColumnClone-success', () => {
        // Arrange
        const target = document.createElement('div');
        const spyParentElement = sandbox.stub(target, 'parentNode');
        target.style.height = '40px';
        target.style.width = '200px';
        spyParentElement.value({childNodes: []});
        instance.clone = null;

        const event = {
            type: 'mousedown',
            target: target
        };
        // Act
        instance.addColumnClone(event);
        // Assert
        chai.assert.include(Array.from(instance.clone.classList), 'column-clone', 'Expect instance clone to include class');
    });

    it('performColumnMove-success', () => {
        // Arrange
        let testValue = 'Sam';
        const fn = (fromIndex, toIndex) =>{
            testValue = 'Alex';
        };
        instance.colParent = document.createElement('div');
        const spyParentElement = sandbox.stub(instance, 'parentElement');
        spyParentElement.value({allowMultipleSelect: false, moveColumn: fn ,datasource : { schema: [] } });

        const el1 = document.createElement('div');
        const el2 = document.createElement('div');
        const el3 = document.createElement('div');
        const el4 = document.createElement('div');

        const collection = [el1,el2,el3,el4];

        for (const item of collection ) {
            instance.colParent.appendChild(item);
        }
        instance.performColumnMove();
        // Assert
        chai.assert.equal(testValue, 'Alex', 'Expect testValue to equal Alex because moveColumn is called');
    });

    it('checkIfCaretIsMoving-moving-fail', () => {
        // Arrange
        const spyAdd = sandbox.stub(instance.caret.classList, 'add');
        instance.clone = document.createElement('div');
        instance.clone.rects = {top: 200, height: 200};
        instance.timer = new Date().getTime();
        instance.caret = null;
        // Act
        instance.checkIfCaretIsMoving();
        // Assert
        chai.assert(spyAdd.notCalled, 'Expect spy add never to be called');
        chai.assert.equal(Array.from(instance.clone.classList).length, 0, 'Expect clone to include class pause');
    });

    it('checkIfCaretIsMoving-moving-success', () => {
        // Arrange
        instance.clone = document.createElement('div');
        instance.clone.classList.add('pause');
        instance.clone.rects = {top: 200, height: 200};
        instance.timer = new Date().getTime();
        // Act
        instance.checkIfCaretIsMoving();
        // Assert
        chai.assert.include(Array.from(instance.clone.classList), 'pause', 'Expect clone to include class pause');
    });

    it('checkIfCaretIsMoving-not-moving-success', () => {
        // Arrange
        instance.timer = new Date().getTime();
        // Act
        instance.checkIfCaretIsMoving();

        const promise = new Promise(resolve => {
            instance.checkIfCaretIsMoving();
        });

        // Assert
        // chai.assert.notInclude(Array.from(instance.clone.classList), 'pause', 'Expect clone not to include class pause');
        promise.then(()=>{
            chai.assert.notInclude(Array.from(instance.clone.classList), 'pause', 'Expect clone not to include class pause');
        });

    });

    it('focusTarget-success', () => {
       //Arrange

        instance.currentTarget = document.createElement('div');
        const element = document.createElement('div');
        element.style.width = '200px';
        element.style.width = '200px';

        const event = {
            type: 'mousemove',
            x: 500,
            y: 10
        };

        const spygetRect = sandbox.stub(instance, 'getRect');
        const spyMoveCaret = sandbox.stub(instance, 'moveCaret');
        spygetRect.withArgs(element).returns(element.getBoundingClientRect());
        spyMoveCaret.withArgs({x:500,y:10});

        // Act
        const promise = new Promise(resolve => {
            instance.focusTarget(element, event.x);
        });

        // Assert
        promise.then(()=> {
            chai.assert.equal(instance.currentTarget, element, 'Expect the current target to be the element');
        });


    });

    it('moveCaret-success', () => {

        // Arrange
        instance.clone = document.createElement('div');
        instance.clone.rects = {top: 200, height: 200};
        instance.colParent = document.createElement('div');

        const spyParentElement = sandbox.stub(instance, 'parentElement');
        spyParentElement.value({allowMultipleSelect: false});

        const el1 = document.createElement('div');
        const el2 = document.createElement('div');
        const el3 = document.createElement('div');
        const el4 = document.createElement('div');

        const collection = [el1,el2,el3,el4];

        for (const item of collection ) {
            instance.colParent.appendChild(item);
        }

        const startPosition = {x:instance.clone.offsetLeft, y:instance.clone.offsetTop};
        const point = {
            x: 500,
            y: 10
        };
        // Act
        const promise = new Promise(resolve =>{
            instance.moveCaret(point);
        });
        // Assert
        promise.then(()=> {
            chai.assert.notEqual(instance.clone.style.x, startPosition.x, 'Expect start position not to be the same as the clones new position')
        });


    });

    it('moveCaret-allowMultipleSelect-success', () => {

        // Arrange
        instance.clone = document.createElement('div');
        instance.clone.rects = {top: 200, height: 200};
        instance.colParent = document.createElement('div');

        const spyParentElement = sandbox.stub(instance, 'parentElement');
        spyParentElement.value({allowMultipleSelect: true});

        const el1 = document.createElement('div');
        const el2 = document.createElement('div');
        const el3 = document.createElement('div');
        const el4 = document.createElement('div');

        const collection = [el1,el2,el3,el4];

        for (const item of collection ) {
            instance.colParent.appendChild(item);
        }

        const startPosition = {x:instance.clone.offsetLeft, y:instance.clone.offsetTop};
        const point = {
            x: 500,
            y: 10
        };
        // Act
        const promise = new Promise(resolve =>{
            instance.moveCaret(point);
        });
        // Assert
        promise.then(()=> {
            chai.assert.notEqual(instance.clone.style.x, startPosition.x, 'Expect start position not to be the same as the clones new position')
        });


    });

    it('clientCoordinates-success', () => {
        //Arrange
        const event =  {
            type: 'mousedown',
            clientX: 100,
            clientY: 250
        };
        // Act
        const coordinates = instance.clientCoordinates(event);
        // Assert
        chai.assert.isNotNull(coordinates, 'Expect coordinates not to be null');
    });

    it('clientCoordinates-fail', () =>{
        //Arrange
        const event =  {
            type: 'touchend',
            clientX: 100,
            clientY: 250
        };
        // Act
        const coordinates = instance.clientCoordinates(event);
        // Assert
        chai.assert.isUndefined(coordinates, 'Expect coordinates undefined');

    });

    it('getTargetElement-success', () => {
        // Arrange
        const x = 0;
        const y = 0;
        const spyElementFromPoint = sandbox.stub(document, 'elementFromPoint');
        spyElementFromPoint.withArgs(x,y);
        // Act
        const target = instance.getTargetElement(x,y);
        // Assert
        chai.assert.isNotNull(target, 'Expect target not to be null');
    });

    it('getTargetElement-fail', () => {
        // Arrange
        const x = null;
        const y = null;
        const spyElementFromPoint = sandbox.stub(document, 'elementFromPoint');
        spyElementFromPoint.withArgs(x,y);
        // Act
        const target = instance.getTargetElement(x,y);
        // Assert
        chai.assert.isUndefined(target, 'Expect target not to be undefined');
    });

    it('getRect-success', () => {
        // Arrange
        const target = document.createElement('div');
        // Act
        const rect = instance.getRect(target);
        // Assert
        chai.assert.isNotNull(rect, 'Expect rect not be null');
        chai.assert.equal(rect.top,target.offsetTop, 'Expect rect.top to be equal to target offsetTop');
    });
});